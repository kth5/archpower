# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: package/*/kexec-tools/hotfix-ppc64-mem-ranges.patch
# Copyright (C) 2024 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

--- kexec-tools-2.0.29-rc1/kexec/arch/ppc64/kexec-ppc64.c.vanilla	2024-07-13 17:49:23.281467539 +0200
+++ kexec-tools-2.0.29-rc1/kexec/arch/ppc64/kexec-ppc64.c	2024-07-13 19:21:05.219767315 +0200
@@ -254,12 +254,13 @@
 /* Get base memory ranges */
 static int get_base_ranges(void)
 {
-	uint64_t start, end;
+	uint64_t start;
+	int64_t end;
 	char device_tree[256] = "/proc/device-tree/";
 	char fname[256];
 	char buf[MAXBYTES];
 	DIR *dir, *dmem;
 	FILE *file;
 	struct dirent *dentry, *mentry;
-	int n;
+	int i, n;
 
@@ -306,9 +307,14 @@
 				if (realloc_memory_ranges() < 0)
 					break;
 			}
-			start =  be64_to_cpu(((uint64_t *)buf)[0]);
-			end = start + be64_to_cpu(((uint64_t *)buf)[1]);
-			add_base_memory_range(start, end);
+			for (i = 0; i < n/8;) {
+				start = be64_to_cpu(((uint64_t *)buf)[i++]);
+				end = be64_to_cpu(((uint64_t *)buf)[i++]);
+				start &= ~(0x8000000000000003ULL);
+				if (end <= 0) continue;
+
+				add_base_memory_range(start, start + end);
+			}
 			fclose(file);
 		}
 		closedir(dmem);
@@ -717,6 +726,7 @@
 
 		if (!strncmp(dentry->d_name, "memory@", 7) ||
 			!strcmp(dentry->d_name, "memory")) {
+			uint64_t start; int64_t end;
 			strcat(fname, "/reg");
 			if ((file = fopen(fname, "r")) == NULL) {
 				perror(fname);
@@ -726,10 +736,17 @@
 				perror(fname);
 				goto error_openfile;
 			}
-			base = be64_to_cpu(((uint64_t *)buf)[0]);
-			if (base < rma_base) {
-				rma_base = base;
-				rma_top = base + be64_to_cpu(((uint64_t *)buf)[1]);
+
+			rma_top = 0;
+			for (int i = 0; i < n/8;) {
+				start = be64_to_cpu(((uint64_t *)buf)[i++]);
+				end = be64_to_cpu(((uint64_t *)buf)[i++]);
+				start &= ~(0x8000000000000003ULL);
+				if (end <= 0) continue;
+				end += start;
+
+				if (start < rma_base) rma_base = start;
+				if (end > rma_top) rma_top = end;
 			}
 
 			fclose(file);
