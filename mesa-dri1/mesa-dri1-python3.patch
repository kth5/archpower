diff --git a/common.py b/common.py
index 8f13186..f049fbc 100644
--- a/common.py
+++ b/common.py
@@ -31,7 +31,7 @@ _machine_map = {
 	'i486': 'x86',
 	'i586': 'x86',
 	'i686': 'x86',
-	'ppc' : 'ppc',
+	'ppc': 'ppc',
 	'AMD64': 'x86_64',
 	'x86_64': 'x86_64',
 }
diff --git a/scons/crossmingw.py b/scons/crossmingw.py
index cc04622..11641dd 100644
--- a/scons/crossmingw.py
+++ b/scons/crossmingw.py
@@ -96,7 +96,7 @@ def shlib_emitter(target, source, env):
     no_import_lib = env.get('no_import_lib', 0)
 
     if not dll:
-        raise SCons.Errors.UserError, "A shared library should have exactly one target with the suffix: %s" % env.subst("$SHLIBSUFFIX")
+        raise SCons.Errors.UserError("A shared library should have exactly one target with the suffix: %s" % env.subst("$SHLIBSUFFIX"))
     
     if not no_import_lib and \
        not env.FindIxes(target, 'LIBPREFIX', 'LIBSUFFIX'):
diff --git a/scons/dxsdk.py b/scons/dxsdk.py
index 920cc2f..9657f58 100644
--- a/scons/dxsdk.py
+++ b/scons/dxsdk.py
@@ -51,7 +51,7 @@ def generate(env):
     elif env['machine'] == 'x86_64':
         target_cpu = 'x64'
     else:
-        raise SCons.Errors.InternalError, "Unsupported target machine"
+        raise SCons.Errors.InternalError("Unsupported target machine")
 
     include_dir = os.path.join(dxsdk_root, 'Include')
     lib_dir = os.path.join(dxsdk_root, 'Lib', target_cpu)
diff --git a/scons/gallium.py b/scons/gallium.py
index 9d08efd..2f20527 100755
--- a/scons/gallium.py
+++ b/scons/gallium.py
@@ -132,7 +132,7 @@ def pkg_config_modules(env, name, modules):
     except OSError:
         return
     prefix = name.upper() + '_'
-    for flag_name, flag_value in flags.iteritems():
+    for flag_name, flag_value in flags.items():
         env[prefix + flag_name] = flag_value
 
     env[name] = True
@@ -156,7 +156,7 @@ def generate(env):
     env.Tool(env['toolchain'])
 
     # Allow override compiler and specify additional flags from environment
-    if os.environ.has_key('CC'):
+    if 'CC' in os.environ:
         env['CC'] = os.environ['CC']
         # Update CCVERSION to match
         pipe = SCons.Action._subproc(env, [env['CC'], '--version'],
@@ -168,13 +168,13 @@ def generate(env):
             match = re.search(r'[0-9]+(\.[0-9]+)+', line)
             if match:
                 env['CCVERSION'] = match.group(0)
-    if os.environ.has_key('CFLAGS'):
+    if 'CFLAGS' in os.environ:
         env['CCFLAGS'] += SCons.Util.CLVar(os.environ['CFLAGS'])
-    if os.environ.has_key('CXX'):
+    if 'CXX' in os.environ:
         env['CXX'] = os.environ['CXX']
-    if os.environ.has_key('CXXFLAGS'):
+    if 'CXXFLAGS' in os.environ:
         env['CXXFLAGS'] += SCons.Util.CLVar(os.environ['CXXFLAGS'])
-    if os.environ.has_key('LDFLAGS'):
+    if 'LDFLAGS' in os.environ:
         env['LINKFLAGS'] += SCons.Util.CLVar(os.environ['LDFLAGS'])
 
     env['gcc'] = 'gcc' in os.path.basename(env['CC']).split('-')
@@ -204,7 +204,7 @@ def generate(env):
         'i486': 'x86',
         'i586': 'x86',
         'i686': 'x86',
-        'ppc' : 'ppc',
+        'ppc': 'ppc',
         'AMD64': 'x86_64',
         'x86_64': 'x86_64',
     }.get(host_machine, 'generic')
@@ -216,16 +216,16 @@ def generate(env):
     # Backwards compatability with the debug= profile= options
     if env['build'] == 'debug':
         if not env['debug']:
-            print 'scons: warning: debug option is deprecated and will be removed eventually; use instead'
-            print
-            print ' scons build=release'
-            print
+            print('scons: warning: debug option is deprecated and will be removed eventually; use instead')
+            print()
+            print(' scons build=release')
+            print()
             env['build'] = 'release'
         if env['profile']:
-            print 'scons: warning: profile option is deprecated and will be removed eventually; use instead'
-            print
-            print ' scons build=profile'
-            print
+            print('scons: warning: profile option is deprecated and will be removed eventually; use instead')
+            print()
+            print(' scons build=profile')
+            print()
             env['build'] = 'profile'
     if False:
         # Enforce SConscripts to use the new build variable
@@ -259,7 +259,7 @@ def generate(env):
     env['build_dir'] = build_dir
     env.SConsignFile(os.path.join(build_dir, '.sconsign'))
     if 'SCONS_CACHE_DIR' in os.environ:
-        print 'scons: Using build cache in %s.' % (os.environ['SCONS_CACHE_DIR'],)
+        print('scons: Using build cache in %s.' % (os.environ['SCONS_CACHE_DIR'],))
         env.CacheDir(os.environ['SCONS_CACHE_DIR'])
     env['CONFIGUREDIR'] = os.path.join(build_dir, 'conf')
     env['CONFIGURELOG'] = os.path.join(os.path.abspath(build_dir), 'config.log')
@@ -377,7 +377,7 @@ def generate(env):
             ccflags += ['-O0']
         elif ccversion.startswith('4.2.'):
             # gcc 4.2.x optimizer is broken
-            print "warning: gcc 4.2.x optimizer is broken -- disabling optimizations"
+            print("warning: gcc 4.2.x optimizer is broken -- disabling optimizations")
             ccflags += ['-O0']
         else:
             ccflags += ['-O3']
diff --git a/scons/llvm.py b/scons/llvm.py
index b89899b..a17b639 100644
--- a/scons/llvm.py
+++ b/scons/llvm.py
@@ -47,7 +47,7 @@ def generate(env):
         llvm_dir = None
     else:
         if not os.path.isdir(llvm_dir):
-            raise SCons.Errors.InternalError, "Specified LLVM directory not found"
+            raise SCons.Errors.InternalError("Specified LLVM directory not found")
 
         if env['debug']:
             llvm_subdir = 'Debug'
@@ -58,20 +58,20 @@ def generate(env):
         if not os.path.isdir(llvm_bin_dir):
             llvm_bin_dir = os.path.join(llvm_dir, 'bin')
             if not os.path.isdir(llvm_bin_dir):
-                raise SCons.Errors.InternalError, "LLVM binary directory not found"
+                raise SCons.Errors.InternalError("LLVM binary directory not found")
 
         env.PrependENVPath('PATH', llvm_bin_dir)
 
     if env['platform'] == 'windows':
         # XXX: There is no llvm-config on Windows, so assume a standard layout
         if llvm_dir is None:
-            print 'scons: LLVM environment variable must be specified when building for windows'
+            print('scons: LLVM environment variable must be specified when building for windows')
             return
 
         # Try to determine the LLVM version from llvm/Config/config.h
         llvm_config = os.path.join(llvm_dir, 'include/llvm/Config/config.h')
         if not os.path.exists(llvm_config):
-            print 'scons: could not find %s' % llvm_config
+            print('scons: could not find %s' % llvm_config)
             return
         llvm_version_re = re.compile(r'^#define PACKAGE_VERSION "([^"]*)"')
         llvm_version = None
@@ -82,7 +82,7 @@ def generate(env):
                 llvm_version = distutils.version.LooseVersion(llvm_version)
                 break
         if llvm_version is None:
-            print 'scons: could not determine the LLVM version from %s' % llvm_config
+            print('scons: could not determine the LLVM version from %s' % llvm_config)
             return
 
         env.Prepend(CPPPATH = [os.path.join(llvm_dir, 'include')])
@@ -134,7 +134,7 @@ def generate(env):
                 env.Append(LINKFLAGS = ['/nodefaultlib:LIBCMT'])
     else:
         if not env.Detect('llvm-config'):
-            print 'scons: llvm-config script not found' % llvm_version
+            print('scons: llvm-config script not found' % llvm_version)
             return
 
         llvm_version = env.backtick('llvm-config --version').rstrip()
@@ -145,13 +145,13 @@ def generate(env):
             env.ParseConfig('llvm-config --libs')
             env.ParseConfig('llvm-config --ldflags')
         except OSError:
-            print 'scons: llvm-config version %s failed' % llvm_version
+            print('scons: llvm-config version %s failed' % llvm_version)
             return
 
     assert llvm_version is not None
     env['llvm'] = True
 
-    print 'scons: Found LLVM version %s' % llvm_version
+    print('scons: Found LLVM version %s' % llvm_version)
     env['LLVM_VERSION'] = llvm_version
 
     # Define HAVE_LLVM macro with the major/minor version number (e.g., 0x0206 for 2.6)
diff --git a/scons/mslib_sa.py b/scons/mslib_sa.py
index bdc0dd9..4b72baf 100644
--- a/scons/mslib_sa.py
+++ b/scons/mslib_sa.py
@@ -90,7 +90,7 @@ class TempFileMunge:
         else:
             split = 1
 
-        args = map(SCons.Subst.quote_spaces, cmd[split:])
+        args = list(map(SCons.Subst.quote_spaces, cmd[split:]))
         open(tmp, 'w').write(string.join(args, " ") + "\n")
         # XXX Using the SCons.Action.print_actions value directly
         # like this is bogus, but expedient.  This class should
@@ -108,8 +108,8 @@ class TempFileMunge:
         # purity get in the way of just being helpful, so we'll
         # reach into SCons.Action directly.
         if SCons.Action.print_actions:
-            print("Using tempfile "+native_tmp+" for command line:\n"+
-                  " ".join(map(str,cmd)))
+            print(("Using tempfile "+native_tmp+" for command line:\n"+
+                  " ".join(map(str, cmd))))
         return cmd[:split] + [ prefix + native_tmp + '\n' + rm, native_tmp ]
 
 def generate(env):
diff --git a/scons/mslink_sa.py b/scons/mslink_sa.py
index 0ecdf24..3f26061 100644
--- a/scons/mslink_sa.py
+++ b/scons/mslink_sa.py
@@ -96,7 +96,7 @@ def _dllEmitter(target, source, env, paramtp):
     no_import_lib = env.get('no_import_lib', 0)
 
     if not dll:
-        raise SCons.Errors.UserError, 'A shared library should have exactly one target with the suffix: %s' % env.subst('$%sSUFFIX' % paramtp)
+        raise SCons.Errors.UserError('A shared library should have exactly one target with the suffix: %s' % env.subst('$%sSUFFIX' % paramtp))
 
     insert_def = env.subst("$WINDOWS_INSERT_DEF")
     if not insert_def in ['', '0', 0] and \
@@ -108,7 +108,7 @@ def _dllEmitter(target, source, env, paramtp):
                             '%sPREFIX' % paramtp, '%sSUFFIX' % paramtp,
                             "WINDOWSDEFPREFIX", "WINDOWSDEFSUFFIX"))
 
-    if env.has_key('PDB') and env['PDB']:
+    if 'PDB' in env and env['PDB']:
         pdb = env.arg2nodes('$PDB', target=target, source=source)[0]
         extratargets.append(pdb)
         target[0].attributes.pdb = pdb
@@ -146,22 +146,22 @@ def prog_emitter(target, source, env):
 
     exe = env.FindIxes(target, "PROGPREFIX", "PROGSUFFIX")
     if not exe:
-        raise SCons.Errors.UserError, "An executable should have exactly one target with the suffix: %s" % env.subst("$PROGSUFFIX")
+        raise SCons.Errors.UserError("An executable should have exactly one target with the suffix: %s" % env.subst("$PROGSUFFIX"))
 
-    if env.has_key('PDB') and env['PDB']:
+    if 'PDB' in env and env['PDB']:
         pdb = env.arg2nodes('$PDB', target=target, source=source)[0]
         extratargets.append(pdb)
         target[0].attributes.pdb = pdb
 
-    return (target+extratargets,source)
+    return (target+extratargets, source)
 
 def RegServerFunc(target, source, env):
-    if env.has_key('register') and env['register']:
+    if 'register' in env and env['register']:
         ret = regServerAction([target[0]], [source[0]], env)
         if ret:
-            raise SCons.Errors.UserError, "Unable to register %s" % target[0]
+            raise SCons.Errors.UserError("Unable to register %s" % target[0])
         else:
-            print "Registered %s sucessfully" % target[0]
+            print("Registered %s sucessfully" % target[0])
         return ret
     return 0
 
@@ -211,7 +211,7 @@ def generate(env):
     env['WINDOWSPROGMANIFESTSUFFIX']  = '${PROGSUFFIX}.manifest'
 
     env['REGSVRACTION'] = regServerCheck
-    env['REGSVR'] = os.path.join(SCons.Platform.win32.get_system_root(),'System32','regsvr32')
+    env['REGSVR'] = os.path.join(SCons.Platform.win32.get_system_root(), 'System32', 'regsvr32')
     env['REGSVRFLAGS'] = '/s '
     env['REGSVRCOM'] = '$REGSVR $REGSVRFLAGS ${TARGET.windows}'
 
diff --git a/scons/msvc_sa.py b/scons/msvc_sa.py
index a913662..4f53c82 100644
--- a/scons/msvc_sa.py
+++ b/scons/msvc_sa.py
@@ -47,11 +47,11 @@ CXXSuffixes = ['.cc', '.cpp', '.cxx', '.c++', '.C++']
 
 def validate_vars(env):
     """Validate the PCH and PCHSTOP construction variables."""
-    if env.has_key('PCH') and env['PCH']:
-        if not env.has_key('PCHSTOP'):
-            raise SCons.Errors.UserError, "The PCHSTOP construction must be defined if PCH is defined."
+    if 'PCH' in env and env['PCH']:
+        if 'PCHSTOP' not in env:
+            raise SCons.Errors.UserError("The PCHSTOP construction must be defined if PCH is defined.")
         if not SCons.Util.is_String(env['PCHSTOP']):
-            raise SCons.Errors.UserError, "The PCHSTOP construction variable must be a string: %r"%env['PCHSTOP']
+            raise SCons.Errors.UserError("The PCHSTOP construction variable must be a string: %r"%env['PCHSTOP'])
 
 def pch_emitter(target, source, env):
     """Adds the object file target."""
@@ -81,7 +81,7 @@ def object_emitter(target, source, env, parent_emitter):
 
     parent_emitter(target, source, env)
 
-    if env.has_key('PCH') and env['PCH']:
+    if 'PCH' in env and env['PCH']:
         env.Depends(target, env['PCH'])
 
     return (target, source)
@@ -216,7 +216,7 @@ def generate(env):
 
     env['RC'] = 'rc'
     env['RCFLAGS'] = SCons.Util.CLVar('')
-    env['RCSUFFIXES']=['.rc','.rc2']
+    env['RCSUFFIXES']=['.rc', '.rc2']
     env['RCCOM'] = '$RC $_CPPDEFFLAGS $_CPPINCFLAGS $RCFLAGS /fo$TARGET $SOURCES'
     env['BUILDERS']['RES'] = res_builder
     env['OBJPREFIX']      = ''
@@ -231,9 +231,9 @@ def generate(env):
     env['PCHCOM'] = '$CXX /Fo${TARGETS[1]} $CXXFLAGS $CCFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Yc$PCHSTOP /Fp${TARGETS[0]} $CCPDBFLAGS $PCHPDBFLAGS'
     env['BUILDERS']['PCH'] = pch_builder
 
-    if not env.has_key('ENV'):
+    if 'ENV' not in env:
         env['ENV'] = {}
-    if not env['ENV'].has_key('SystemRoot'):    # required for dlls in the winsxs folders
+    if 'SystemRoot' not in env['ENV']:    # required for dlls in the winsxs folders
         env['ENV']['SystemRoot'] = SCons.Platform.win32.get_system_root()
 
 def exists(env):
diff --git a/scons/wcesdk.py b/scons/wcesdk.py
index e82f255..eeee70d 100644
--- a/scons/wcesdk.py
+++ b/scons/wcesdk.py
@@ -110,14 +110,14 @@ def get_wce600_paths(env):
 
     wince_root = get_wce600_root(env)
     if wince_root is None:
-        raise SCons.Errors.InternalError, "Windows CE 6.0 SDK not found"
+        raise SCons.Errors.InternalError("Windows CE 6.0 SDK not found")
     
     os_version = os.environ.get('_WINCEOSVER', '600')
     platform_root = os.environ.get('_PLATFORMROOT', os.path.join(wince_root, 'platform'))
-    sdk_root = os.environ.get('_SDKROOT' ,os.path.join(wince_root, 'sdk'))
+    sdk_root = os.environ.get('_SDKROOT', os.path.join(wince_root, 'sdk'))
 
     platform_root = os.environ.get('_PLATFORMROOT', os.path.join(wince_root, 'platform'))
-    sdk_root = os.environ.get('_SDKROOT' ,os.path.join(wince_root, 'sdk'))
+    sdk_root = os.environ.get('_SDKROOT', os.path.join(wince_root, 'sdk'))
 
     host_cpu = os.environ.get('_HOSTCPUTYPE', 'i386')
     target_cpu = os.environ.get('_TGTCPU', 'x86')
@@ -158,7 +158,7 @@ def generate(env):
     mslib_sa.generate(env)
     mslink_sa.generate(env)
 
-    if not env.has_key('ENV'):
+    if 'ENV' not in env:
         env['ENV'] = {}
     
     try:
diff --git a/scons/winddk.py b/scons/winddk.py
index 4dac16e..a16701d 100644
--- a/scons/winddk.py
+++ b/scons/winddk.py
@@ -62,7 +62,7 @@ def get_winddk_root(env, version):
     return None 
 
 def get_winddk_paths(env, version, root):
-    version_major, version_minor = map(int, version.split('.'))
+    version_major, version_minor = list(map(int, version.split('.')))
     
     if version_major >= 6000:
         target_os = 'wlh'
@@ -74,7 +74,7 @@ def get_winddk_paths(env, version, root):
     elif env['machine'] == 'x86_64':
         target_cpu = 'amd64'
     else:
-        raise SCons.Errors.InternalError, "Unsupported target machine"
+        raise SCons.Errors.InternalError("Unsupported target machine")
 
     if version_major >= 6000:
         # TODO: take in consideration the host cpu
@@ -125,7 +125,7 @@ def get_winddk_paths(env, version, root):
 
 
 def generate(env):
-    if not env.has_key('ENV'):
+    if 'ENV' not in env:
         env['ENV'] = {}
 
     for version in versions:
diff --git a/scons/winsdk.py b/scons/winsdk.py
index 7e874a5..3f21cbb 100644
--- a/scons/winsdk.py
+++ b/scons/winsdk.py
@@ -48,7 +48,7 @@ def get_vs_root(env):
 def get_vs_paths(env):
     vs_root = get_vs_root(env)
     if vs_root is None:
-        raise SCons.Errors.InternalError, "WINSDK compiler not found"
+        raise SCons.Errors.InternalError("WINSDK compiler not found")
 
     tool_path = os.path.join(vs_root, 'Common7', 'IDE')
 
@@ -62,7 +62,7 @@ def get_vc_root(env):
 def get_vc_paths(env):
     vc_root = get_vc_root(env)
     if vc_root is None:
-        raise SCons.Errors.InternalError, "WINSDK compiler not found"
+        raise SCons.Errors.InternalError("WINSDK compiler not found")
 
     target_cpu = env['machine']
 
@@ -74,7 +74,7 @@ def get_vc_paths(env):
         bin_dir = r'bin\x86_amd64'
         lib_dir = r'lib\amd64'
     else:
-        raise SCons.Errors.InternalError, "Unsupported target machine"
+        raise SCons.Errors.InternalError("Unsupported target machine")
     include_dir = 'include'
 
     env.PrependENVPath('PATH',    os.path.join(vc_root, bin_dir))
@@ -96,7 +96,7 @@ def get_sdk_root(env):
 def get_sdk_paths(env):
     sdk_root = get_sdk_root(env)
     if sdk_root is None:
-        raise SCons.Errors.InternalError, "WINSDK not found"
+        raise SCons.Errors.InternalError("WINSDK not found")
 
     target_cpu = env['machine']
 
@@ -106,7 +106,7 @@ def get_sdk_paths(env):
     elif target_cpu == 'x86_64':
         lib_dir = r'Lib\x64'
     else:
-        raise SCons.Errors.InternalError, "Unsupported target machine"
+        raise SCons.Errors.InternalError("Unsupported target machine")
     include_dir = 'Include'
 
     env.PrependENVPath('PATH',    os.path.join(sdk_root, bin_dir))
@@ -114,7 +114,7 @@ def get_sdk_paths(env):
     env.PrependENVPath('LIB',     os.path.join(sdk_root, lib_dir))
 
 def generate(env):
-    if not env.has_key('ENV'):
+    if 'ENV' not in env:
         env['ENV'] = {}
     
     get_vs_paths(env)
diff --git a/src/gallium/auxiliary/indices/u_indices_gen.py b/src/gallium/auxiliary/indices/u_indices_gen.py
index af63d09..6269810 100644
--- a/src/gallium/auxiliary/indices/u_indices_gen.py
+++ b/src/gallium/auxiliary/indices/u_indices_gen.py
@@ -53,16 +53,16 @@ LONGPRIMS=('PIPE_PRIM_POINTS',
            'PIPE_PRIM_QUAD_STRIP', 
            'PIPE_PRIM_POLYGON')
 
-longprim = dict(zip(PRIMS, LONGPRIMS))
+longprim = dict(list(zip(PRIMS, LONGPRIMS)))
 intype_idx = dict(ubyte='IN_UBYTE', ushort='IN_USHORT', uint='IN_UINT')
 outtype_idx = dict(ushort='OUT_USHORT', uint='OUT_UINT')
 pv_idx = dict(first='PV_FIRST', last='PV_LAST')
 
 
 def prolog():
-    print '''/* File automatically generated by indices.py */'''
-    print copyright
-    print r'''
+    print('''/* File automatically generated by indices.py */''')
+    print(copyright)
+    print(r'''
 
 /**
  * @file
@@ -101,7 +101,7 @@ static u_translate_func translate[IN_COUNT][OUT_COUNT][PV_COUNT][PV_COUNT][PRIM_
 static u_generate_func  generate[OUT_COUNT][PV_COUNT][PV_COUNT][PRIM_COUNT];
 
 
-'''
+''')
 
 def vert( intype, outtype, v0 ):
     if intype == GENERATE:
@@ -110,16 +110,16 @@ def vert( intype, outtype, v0 ):
         return '(' + outtype + ')in[' + v0 + ']'
 
 def point( intype, outtype, ptr, v0 ):
-    print '      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';'
+    print('      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';')
 
 def line( intype, outtype, ptr, v0, v1 ):
-    print '      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';'
-    print '      (' + ptr + ')[1] = ' + vert( intype, outtype, v1 ) + ';'
+    print('      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';')
+    print('      (' + ptr + ')[1] = ' + vert( intype, outtype, v1 ) + ';')
 
 def tri( intype, outtype, ptr, v0, v1, v2 ):
-    print '      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';'
-    print '      (' + ptr + ')[1] = ' + vert( intype, outtype, v1 ) + ';'
-    print '      (' + ptr + ')[2] = ' + vert( intype, outtype, v2 ) + ';'
+    print('      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';')
+    print('      (' + ptr + ')[1] = ' + vert( intype, outtype, v1 ) + ';')
+    print('      (' + ptr + ')[2] = ' + vert( intype, outtype, v2 ) + ';')
 
 def do_point( intype, outtype, ptr, v0 ):
     point( intype, outtype, ptr, v0 )
@@ -150,103 +150,103 @@ def name(intype, outtype, inpv, outpv, prim):
         return 'translate_' + prim + '_' + intype + '2' + outtype + '_' + inpv + '2' + outpv
 
 def preamble(intype, outtype, inpv, outpv, prim):
-    print 'static void ' + name( intype, outtype, inpv, outpv, prim ) + '('
+    print('static void ' + name( intype, outtype, inpv, outpv, prim ) + '(')
     if intype != GENERATE:
-        print '    const void * _in,'
-    print '    unsigned nr,'
-    print '    void *_out )'
-    print '{'
+        print('    const void * _in,')
+    print('    unsigned nr,')
+    print('    void *_out )')
+    print('{')
     if intype != GENERATE:
-        print '  const ' + intype + '*in = (const ' + intype + '*)_in;'
-    print '  ' + outtype + ' *out = (' + outtype + '*)_out;'
-    print '  unsigned i, j;'
-    print '  (void)j;'
+        print('  const ' + intype + '*in = (const ' + intype + '*)_in;')
+    print('  ' + outtype + ' *out = (' + outtype + '*)_out;')
+    print('  unsigned i, j;')
+    print('  (void)j;')
 
 def postamble():
-    print '}'
+    print('}')
 
 
 def points(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='points')
-    print '  for (i = 0; i < nr; i++) { '
+    print('  for (i = 0; i < nr; i++) { ')
     do_point( intype, outtype, 'out+i',  'i' );
-    print '   }'
+    print('   }')
     postamble()
 
 def lines(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='lines')
-    print '  for (i = 0; i < nr; i+=2) { '
+    print('  for (i = 0; i < nr; i+=2) { ')
     do_line( intype, outtype, 'out+i',  'i', 'i+1', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 def linestrip(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='linestrip')
-    print '  for (j = i = 0; j < nr; j+=2, i++) { '
+    print('  for (j = i = 0; j < nr; j+=2, i++) { ')
     do_line( intype, outtype, 'out+j',  'i', 'i+1', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 def lineloop(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='lineloop')
-    print '  for (j = i = 0; j < nr - 2; j+=2, i++) { '
+    print('  for (j = i = 0; j < nr - 2; j+=2, i++) { ')
     do_line( intype, outtype, 'out+j',  'i', 'i+1', inpv, outpv );
-    print '   }'
+    print('   }')
     do_line( intype, outtype, 'out+j',  'i', '0', inpv, outpv );
     postamble()
 
 def tris(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='tris')
-    print '  for (i = 0; i < nr; i+=3) { '
+    print('  for (i = 0; i < nr; i+=3) { ')
     do_tri( intype, outtype, 'out+i',  'i', 'i+1', 'i+2', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def tristrip(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='tristrip')
-    print '  for (j = i = 0; j < nr; j+=3, i++) { '
+    print('  for (j = i = 0; j < nr; j+=3, i++) { ')
     if inpv == FIRST:
         do_tri( intype, outtype, 'out+j',  'i', 'i+1+(i&1)', 'i+2-(i&1)', inpv, outpv );
     else:
         do_tri( intype, outtype, 'out+j',  'i+(i&1)', 'i+1-(i&1)', 'i+2', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def trifan(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='trifan')
-    print '  for (j = i = 0; j < nr; j+=3, i++) { '
+    print('  for (j = i = 0; j < nr; j+=3, i++) { ')
     do_tri( intype, outtype, 'out+j',  '0', 'i+1', 'i+2', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 
 
 def polygon(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='polygon')
-    print '  for (j = i = 0; j < nr; j+=3, i++) { '
+    print('  for (j = i = 0; j < nr; j+=3, i++) { ')
     if inpv == FIRST:
         do_tri( intype, outtype, 'out+j',  '0', 'i+1', 'i+2', inpv, outpv );
     else:
         do_tri( intype, outtype, 'out+j',  'i+1', 'i+2', '0', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def quads(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='quads')
-    print '  for (j = i = 0; j < nr; j+=6, i+=4) { '
+    print('  for (j = i = 0; j < nr; j+=6, i+=4) { ')
     do_quad( intype, outtype, 'out+j', 'i+0', 'i+1', 'i+2', 'i+3', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def quadstrip(intype, outtype, inpv, outpv):
     preamble(intype, outtype, inpv, outpv, prim='quadstrip')
-    print '  for (j = i = 0; j < nr; j+=6, i+=2) { '
+    print('  for (j = i = 0; j < nr; j+=6, i+=2) { ')
     do_quad( intype, outtype, 'out+j', 'i+2', 'i+0', 'i+1', 'i+3', inpv, outpv );
-    print '   }'
+    print('   }')
     postamble()
 
 
@@ -268,20 +268,20 @@ def emit_funcs():
 
 def init(intype, outtype, inpv, outpv, prim):
     if intype == GENERATE:
-        print ('generate[' + 
+        print(('generate[' + 
                outtype_idx[outtype] + 
                '][' + pv_idx[inpv] + 
                '][' + pv_idx[outpv] + 
                '][' + longprim[prim] + 
-               '] = ' + name( intype, outtype, inpv, outpv, prim ) + ';')
+               '] = ' + name( intype, outtype, inpv, outpv, prim ) + ';'))
     else:
-        print ('translate[' + 
+        print(('translate[' + 
                intype_idx[intype] + 
                '][' + outtype_idx[outtype] + 
                '][' + pv_idx[inpv] + 
                '][' + pv_idx[outpv] + 
                '][' + longprim[prim] + 
-               '] = ' + name( intype, outtype, inpv, outpv, prim ) + ';')
+               '] = ' + name( intype, outtype, inpv, outpv, prim ) + ';'))
 
 
 def emit_all_inits():
@@ -293,19 +293,19 @@ def emit_all_inits():
                         init(intype, outtype, inpv, outpv, prim)
 
 def emit_init():
-    print 'void u_index_init( void )'
-    print '{'
-    print '  static int firsttime = 1;'
-    print '  if (!firsttime) return;'
-    print '  firsttime = 0;'
+    print('void u_index_init( void )')
+    print('{')
+    print('  static int firsttime = 1;')
+    print('  if (!firsttime) return;')
+    print('  firsttime = 0;')
     emit_all_inits()
-    print '}'
+    print('}')
 
 
     
 
 def epilog():
-    print '#include "indices/u_indices.c"'
+    print('#include "indices/u_indices.c"')
 
 
 def main():
diff --git a/src/gallium/auxiliary/indices/u_unfilled_gen.py b/src/gallium/auxiliary/indices/u_unfilled_gen.py
index 085c47a..729d4e7 100644
--- a/src/gallium/auxiliary/indices/u_unfilled_gen.py
+++ b/src/gallium/auxiliary/indices/u_unfilled_gen.py
@@ -44,15 +44,15 @@ LONGPRIMS=('PIPE_PRIM_TRIANGLES',
            'PIPE_PRIM_QUAD_STRIP', 
            'PIPE_PRIM_POLYGON')
 
-longprim = dict(zip(PRIMS, LONGPRIMS))
+longprim = dict(list(zip(PRIMS, LONGPRIMS)))
 intype_idx = dict(ubyte='IN_UBYTE', ushort='IN_USHORT', uint='IN_UINT')
 outtype_idx = dict(ushort='OUT_USHORT', uint='OUT_UINT')
 
 
 def prolog():
-    print '''/* File automatically generated by u_unfilled_gen.py */'''
-    print copyright
-    print r'''
+    print('''/* File automatically generated by u_unfilled_gen.py */''')
+    print(copyright)
+    print(r'''
 
 /**
  * @file
@@ -90,7 +90,7 @@ static unsigned in_size_idx( unsigned index_size )
 static u_generate_func generate_line[OUT_COUNT][PRIM_COUNT];
 static u_translate_func translate_line[IN_COUNT][OUT_COUNT][PRIM_COUNT];
 
-'''
+''')
 
 def vert( intype, outtype, v0 ):
     if intype == GENERATE:
@@ -99,8 +99,8 @@ def vert( intype, outtype, v0 ):
         return '(' + outtype + ')in[' + v0 + ']'
 
 def line( intype, outtype, ptr, v0, v1 ):
-    print '      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';'
-    print '      (' + ptr + ')[1] = ' + vert( intype, outtype, v1 ) + ';'
+    print('      (' + ptr + ')[0] = ' + vert( intype, outtype, v0 ) + ';')
+    print('      (' + ptr + ')[1] = ' + vert( intype, outtype, v1 ) + ';')
 
 # XXX: have the opportunity here to avoid over-drawing shared lines in
 # tristrips, fans, etc, by integrating this into the calling functions
@@ -124,68 +124,68 @@ def name(intype, outtype, prim):
         return 'translate_' + prim + '_' + intype + '2' + outtype
 
 def preamble(intype, outtype, prim):
-    print 'static void ' + name( intype, outtype, prim ) + '('
+    print('static void ' + name( intype, outtype, prim ) + '(')
     if intype != GENERATE:
-        print '    const void * _in,'
-    print '    unsigned nr,'
-    print '    void *_out )'
-    print '{'
+        print('    const void * _in,')
+    print('    unsigned nr,')
+    print('    void *_out )')
+    print('{')
     if intype != GENERATE:
-        print '  const ' + intype + '*in = (const ' + intype + '*)_in;'
-    print '  ' + outtype + ' *out = (' + outtype + '*)_out;'
-    print '  unsigned i, j;'
-    print '  (void)j;'
+        print('  const ' + intype + '*in = (const ' + intype + '*)_in;')
+    print('  ' + outtype + ' *out = (' + outtype + '*)_out;')
+    print('  unsigned i, j;')
+    print('  (void)j;')
 
 def postamble():
-    print '}'
+    print('}')
 
 
 def tris(intype, outtype):
     preamble(intype, outtype, prim='tris')
-    print '  for (j = i = 0; j < nr; j+=6, i+=3) { '
+    print('  for (j = i = 0; j < nr; j+=6, i+=3) { ')
     do_tri( intype, outtype, 'out+j',  'i', 'i+1', 'i+2' );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def tristrip(intype, outtype):
     preamble(intype, outtype, prim='tristrip')
-    print '  for (j = i = 0; j < nr; j+=6, i++) { '
+    print('  for (j = i = 0; j < nr; j+=6, i++) { ')
     do_tri( intype, outtype, 'out+j',  'i', 'i+1/*+(i&1)*/', 'i+2/*-(i&1)*/' );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def trifan(intype, outtype):
     preamble(intype, outtype, prim='trifan')
-    print '  for (j = i = 0; j < nr; j+=6, i++) { '
+    print('  for (j = i = 0; j < nr; j+=6, i++) { ')
     do_tri( intype, outtype, 'out+j',  '0', 'i+1', 'i+2' );
-    print '   }'
+    print('   }')
     postamble()
 
 
 
 def polygon(intype, outtype):
     preamble(intype, outtype, prim='polygon')
-    print '  for (j = i = 0; j < nr; j+=2, i++) { '
+    print('  for (j = i = 0; j < nr; j+=2, i++) { ')
     line( intype, outtype, 'out+j', 'i', '(i+1)%(nr/2)' )
-    print '   }'
+    print('   }')
     postamble()
 
 
 def quads(intype, outtype):
     preamble(intype, outtype, prim='quads')
-    print '  for (j = i = 0; j < nr; j+=8, i+=4) { '
+    print('  for (j = i = 0; j < nr; j+=8, i+=4) { ')
     do_quad( intype, outtype, 'out+j', 'i+0', 'i+1', 'i+2', 'i+3' );
-    print '   }'
+    print('   }')
     postamble()
 
 
 def quadstrip(intype, outtype):
     preamble(intype, outtype, prim='quadstrip')
-    print '  for (j = i = 0; j < nr; j+=8, i+=2) { '
+    print('  for (j = i = 0; j < nr; j+=8, i+=2) { ')
     do_quad( intype, outtype, 'out+j', 'i+2', 'i+0', 'i+1', 'i+3' );
-    print '   }'
+    print('   }')
     postamble()
 
 
@@ -201,16 +201,16 @@ def emit_funcs():
 
 def init(intype, outtype, prim):
     if intype == GENERATE:
-        print ('generate_line[' + 
+        print(('generate_line[' + 
                outtype_idx[outtype] + 
                '][' + longprim[prim] + 
-               '] = ' + name( intype, outtype, prim ) + ';')
+               '] = ' + name( intype, outtype, prim ) + ';'))
     else:
-        print ('translate_line[' + 
+        print(('translate_line[' + 
                intype_idx[intype] + 
                '][' + outtype_idx[outtype] + 
                '][' + longprim[prim] + 
-               '] = ' + name( intype, outtype, prim ) + ';')
+               '] = ' + name( intype, outtype, prim ) + ';'))
 
 
 def emit_all_inits():
@@ -220,19 +220,19 @@ def emit_all_inits():
                 init(intype, outtype, prim)
 
 def emit_init():
-    print 'void u_unfilled_init( void )'
-    print '{'
-    print '  static int firsttime = 1;'
-    print '  if (!firsttime) return;'
-    print '  firsttime = 0;'
+    print('void u_unfilled_init( void )')
+    print('{')
+    print('  static int firsttime = 1;')
+    print('  if (!firsttime) return;')
+    print('  firsttime = 0;')
     emit_all_inits()
-    print '}'
+    print('}')
 
 
     
 
 def epilog():
-    print '#include "indices/u_unfilled_indices.c"'
+    print('#include "indices/u_unfilled_indices.c"')
 
 
 def main():
diff --git a/src/gallium/auxiliary/util/u_format_pack.py b/src/gallium/auxiliary/util/u_format_pack.py
index cc173f8..699035f 100644
--- a/src/gallium/auxiliary/util/u_format_pack.py
+++ b/src/gallium/auxiliary/util/u_format_pack.py
@@ -45,67 +45,67 @@ def generate_format_type(format):
 
     assert format.layout == PLAIN
     
-    print 'union util_format_%s {' % format.short_name()
+    print('union util_format_%s {' % format.short_name())
     
     if format.block_size() in (8, 16, 32, 64):
-        print '   uint%u_t value;' % (format.block_size(),)
+        print('   uint%u_t value;' % (format.block_size(),))
 
     use_bitfields = False
     for channel in format.channels:
         if channel.size % 8 or not is_pot(channel.size):
             use_bitfields = True
 
-    print '   struct {'
+    print('   struct {')
     for channel in format.channels:
         if use_bitfields:
             if channel.type == VOID:
                 if channel.size:
-                    print '      unsigned %s:%u;' % (channel.name, channel.size)
+                    print('      unsigned %s:%u;' % (channel.name, channel.size))
             elif channel.type == UNSIGNED:
-                print '      unsigned %s:%u;' % (channel.name, channel.size)
+                print('      unsigned %s:%u;' % (channel.name, channel.size))
             elif channel.type in (SIGNED, FIXED):
-                print '      int %s:%u;' % (channel.name, channel.size)
+                print('      int %s:%u;' % (channel.name, channel.size))
             elif channel.type == FLOAT:
                 if channel.size == 64:
-                    print '      double %s;' % (channel.name)
+                    print('      double %s;' % (channel.name))
                 elif channel.size == 32:
-                    print '      float %s;' % (channel.name)
+                    print('      float %s;' % (channel.name))
                 else:
-                    print '      unsigned %s:%u;' % (channel.name, channel.size)
+                    print('      unsigned %s:%u;' % (channel.name, channel.size))
             else:
                 assert 0
         else:
             assert channel.size % 8 == 0 and is_pot(channel.size)
             if channel.type == VOID:
                 if channel.size:
-                    print '      uint%u_t %s;' % (channel.size, channel.name)
+                    print('      uint%u_t %s;' % (channel.size, channel.name))
             elif channel.type == UNSIGNED:
-                print '      uint%u_t %s;' % (channel.size, channel.name)
+                print('      uint%u_t %s;' % (channel.size, channel.name))
             elif channel.type in (SIGNED, FIXED):
-                print '      int%u_t %s;' % (channel.size, channel.name)
+                print('      int%u_t %s;' % (channel.size, channel.name))
             elif channel.type == FLOAT:
                 if channel.size == 64:
-                    print '      double %s;' % (channel.name)
+                    print('      double %s;' % (channel.name))
                 elif channel.size == 32:
-                    print '      float %s;' % (channel.name)
+                    print('      float %s;' % (channel.name))
                 elif channel.size == 16:
-                    print '      uint16_t %s;' % (channel.name)
+                    print('      uint16_t %s;' % (channel.name))
                 else:
                     assert 0
             else:
                 assert 0
-    print '   } chan;'
-    print '};'
-    print
+    print('   } chan;')
+    print('};')
+    print()
 
 
 def bswap_format(format):
     '''Generate a structure that describes the format.'''
 
     if format.is_bitmask() and not format.is_array() and format.block_size() > 8:
-        print '#ifdef PIPE_ARCH_BIG_ENDIAN'
-        print '   pixel.value = util_bswap%u(pixel.value);' % format.block_size()
-        print '#endif'
+        print('#ifdef PIPE_ARCH_BIG_ENDIAN')
+        print('   pixel.value = util_bswap%u(pixel.value);' % format.block_size())
+        print('#endif')
 
 
 def is_format_supported(format):
@@ -387,20 +387,20 @@ def generate_unpack_kernel(format, dst_channel, dst_native_type):
 
     if format.is_bitmask():
         depth = format.block_size()
-        print '         uint%u_t value = *(const uint%u_t *)src;' % (depth, depth) 
+        print('         uint%u_t value = *(const uint%u_t *)src;' % (depth, depth)) 
 
         # Declare the intermediate variables
         for i in range(format.nr_channels()):
             src_channel = format.channels[i]
             if src_channel.type == UNSIGNED:
-                print '         uint%u_t %s;' % (depth, src_channel.name)
+                print('         uint%u_t %s;' % (depth, src_channel.name))
             elif src_channel.type == SIGNED:
-                print '         int%u_t %s;' % (depth, src_channel.name)
+                print('         int%u_t %s;' % (depth, src_channel.name))
 
         if depth > 8:
-            print '#ifdef PIPE_ARCH_BIG_ENDIAN'
-            print '         value = util_bswap%u(value);' % depth
-            print '#endif'
+            print('#ifdef PIPE_ARCH_BIG_ENDIAN')
+            print('         value = util_bswap%u(value);' % depth)
+            print('#endif')
 
         # Compute the intermediate unshifted values 
         shift = 0
@@ -427,7 +427,7 @@ def generate_unpack_kernel(format, dst_channel, dst_native_type):
                 value = None
                 
             if value is not None:
-                print '         %s = %s;' % (src_channel.name, value)
+                print('         %s = %s;' % (src_channel.name, value))
                 
             shift += src_channel.size
 
@@ -453,11 +453,11 @@ def generate_unpack_kernel(format, dst_channel, dst_native_type):
                 value = '0'
             else:
                 assert False
-            print '         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
+            print('         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i]))
         
     else:
-        print '         union util_format_%s pixel;' % format.short_name()
-        print '         memcpy(&pixel, src, sizeof pixel);'
+        print('         union util_format_%s pixel;' % format.short_name())
+        print('         memcpy(&pixel, src, sizeof pixel);')
         bswap_format(format)
     
         for i in range(4):
@@ -481,7 +481,7 @@ def generate_unpack_kernel(format, dst_channel, dst_native_type):
                 value = '0'
             else:
                 assert False
-            print '         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
+            print('         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i]))
     
 
 def generate_pack_kernel(format, src_channel, src_native_type):
@@ -497,7 +497,7 @@ def generate_pack_kernel(format, src_channel, src_native_type):
 
     if format.is_bitmask():
         depth = format.block_size()
-        print '         uint%u_t value = 0;' % depth 
+        print('         uint%u_t value = 0;' % depth) 
 
         shift = 0
         for i in range(4):
@@ -523,19 +523,19 @@ def generate_pack_kernel(format, src_channel, src_native_type):
                 else:
                     value = None
                 if value is not None:
-                    print '         value |= %s;' % (value)
+                    print('         value |= %s;' % (value))
                 
             shift += dst_channel.size
 
         if depth > 8:
-            print '#ifdef PIPE_ARCH_BIG_ENDIAN'
-            print '         value = util_bswap%u(value);' % depth
-            print '#endif'
+            print('#ifdef PIPE_ARCH_BIG_ENDIAN')
+            print('         value = util_bswap%u(value);' % depth)
+            print('#endif')
         
-        print '         *(uint%u_t *)dst = value;' % depth 
+        print('         *(uint%u_t *)dst = value;' % depth) 
 
     else:
-        print '         union util_format_%s pixel;' % format.short_name()
+        print('         union util_format_%s pixel;' % format.short_name())
     
         for i in range(4):
             dst_channel = format.channels[i]
@@ -551,10 +551,10 @@ def generate_pack_kernel(format, src_channel, src_native_type):
                                     dst_channel, dst_native_type, 
                                     value, 
                                     dst_colorspace = dst_colorspace)
-            print '         pixel.chan.%s = %s;' % (dst_channel.name, value)
+            print('         pixel.chan.%s = %s;' % (dst_channel.name, value))
     
         bswap_format(format)
-        print '         memcpy(dst, &pixel, sizeof pixel);'
+        print('         memcpy(dst, &pixel, sizeof pixel);')
     
 
 def generate_format_unpack(format, dst_channel, dst_native_type, dst_suffix):
@@ -562,28 +562,28 @@ def generate_format_unpack(format, dst_channel, dst_native_type, dst_suffix):
 
     name = format.short_name()
 
-    print 'static INLINE void'
-    print 'util_format_%s_unpack_%s(%s *dst_row, unsigned dst_stride, const uint8_t *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, dst_suffix, dst_native_type)
-    print '{'
+    print('static INLINE void')
+    print('util_format_%s_unpack_%s(%s *dst_row, unsigned dst_stride, const uint8_t *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, dst_suffix, dst_native_type))
+    print('{')
 
     if is_format_supported(format):
-        print '   unsigned x, y;'
-        print '   for(y = 0; y < height; y += %u) {' % (format.block_height,)
-        print '      %s *dst = dst_row;' % (dst_native_type)
-        print '      const uint8_t *src = src_row;'
-        print '      for(x = 0; x < width; x += %u) {' % (format.block_width,)
+        print('   unsigned x, y;')
+        print('   for(y = 0; y < height; y += %u) {' % (format.block_height,))
+        print('      %s *dst = dst_row;' % (dst_native_type))
+        print('      const uint8_t *src = src_row;')
+        print('      for(x = 0; x < width; x += %u) {' % (format.block_width,))
         
         generate_unpack_kernel(format, dst_channel, dst_native_type)
     
-        print '         src += %u;' % (format.block_size() / 8,)
-        print '         dst += 4;'
-        print '      }'
-        print '      src_row += src_stride;'
-        print '      dst_row += dst_stride/sizeof(*dst_row);'
-        print '   }'
-
-    print '}'
-    print
+        print('         src += %u;' % (format.block_size() / 8,))
+        print('         dst += 4;')
+        print('      }')
+        print('      src_row += src_stride;')
+        print('      dst_row += dst_stride/sizeof(*dst_row);')
+        print('   }')
+
+    print('}')
+    print()
     
 
 def generate_format_pack(format, src_channel, src_native_type, src_suffix):
@@ -591,28 +591,28 @@ def generate_format_pack(format, src_channel, src_native_type, src_suffix):
 
     name = format.short_name()
 
-    print 'static INLINE void'
-    print 'util_format_%s_pack_%s(uint8_t *dst_row, unsigned dst_stride, const %s *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, src_suffix, src_native_type)
-    print '{'
+    print('static INLINE void')
+    print('util_format_%s_pack_%s(uint8_t *dst_row, unsigned dst_stride, const %s *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, src_suffix, src_native_type))
+    print('{')
     
     if is_format_supported(format):
-        print '   unsigned x, y;'
-        print '   for(y = 0; y < height; y += %u) {' % (format.block_height,)
-        print '      const %s *src = src_row;' % (src_native_type)
-        print '      uint8_t *dst = dst_row;'
-        print '      for(x = 0; x < width; x += %u) {' % (format.block_width,)
+        print('   unsigned x, y;')
+        print('   for(y = 0; y < height; y += %u) {' % (format.block_height,))
+        print('      const %s *src = src_row;' % (src_native_type))
+        print('      uint8_t *dst = dst_row;')
+        print('      for(x = 0; x < width; x += %u) {' % (format.block_width,))
     
         generate_pack_kernel(format, src_channel, src_native_type)
             
-        print '         src += 4;'
-        print '         dst += %u;' % (format.block_size() / 8,)
-        print '      }'
-        print '      dst_row += dst_stride;'
-        print '      src_row += src_stride/sizeof(*src_row);'
-        print '   }'
+        print('         src += 4;')
+        print('         dst += %u;' % (format.block_size() / 8,))
+        print('      }')
+        print('      dst_row += dst_stride;')
+        print('      src_row += src_stride/sizeof(*src_row);')
+        print('   }')
         
-    print '}'
-    print
+    print('}')
+    print()
     
 
 def generate_format_fetch(format, dst_channel, dst_native_type, dst_suffix):
@@ -620,15 +620,15 @@ def generate_format_fetch(format, dst_channel, dst_native_type, dst_suffix):
 
     name = format.short_name()
 
-    print 'static INLINE void'
-    print 'util_format_%s_fetch_%s(%s *dst, const uint8_t *src, unsigned i, unsigned j)' % (name, dst_suffix, dst_native_type)
-    print '{'
+    print('static INLINE void')
+    print('util_format_%s_fetch_%s(%s *dst, const uint8_t *src, unsigned i, unsigned j)' % (name, dst_suffix, dst_native_type))
+    print('{')
 
     if is_format_supported(format):
         generate_unpack_kernel(format, dst_channel, dst_native_type)
 
-    print '}'
-    print
+    print('}')
+    print()
 
 
 def is_format_hand_written(format):
@@ -636,16 +636,16 @@ def is_format_hand_written(format):
 
 
 def generate(formats):
-    print
-    print '#include "pipe/p_compiler.h"'
-    print '#include "u_math.h"'
-    print '#include "u_half.h"'
-    print '#include "u_format.h"'
-    print '#include "u_format_other.h"'
-    print '#include "u_format_srgb.h"'
-    print '#include "u_format_yuv.h"'
-    print '#include "u_format_zs.h"'
-    print
+    print()
+    print('#include "pipe/p_compiler.h"')
+    print('#include "u_math.h"')
+    print('#include "u_half.h"')
+    print('#include "u_format.h"')
+    print('#include "u_format_other.h"')
+    print('#include "u_format_srgb.h"')
+    print('#include "u_format_yuv.h"')
+    print('#include "u_format_zs.h"')
+    print()
 
     for format in formats:
         if not is_format_hand_written(format):
diff --git a/src/gallium/auxiliary/util/u_format_parse.py b/src/gallium/auxiliary/util/u_format_parse.py
index ddb9f24..d1a72f8 100755
--- a/src/gallium/auxiliary/util/u_format_parse.py
+++ b/src/gallium/auxiliary/util/u_format_parse.py
@@ -30,9 +30,9 @@
 '''
 
 
-VOID, UNSIGNED, SIGNED, FIXED, FLOAT = range(5)
+VOID, UNSIGNED, SIGNED, FIXED, FLOAT = list(range(5))
 
-SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W, SWIZZLE_0, SWIZZLE_1, SWIZZLE_NONE, = range(7)
+SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W, SWIZZLE_0, SWIZZLE_1, SWIZZLE_NONE, = list(range(7))
 
 PLAIN = 'plain'
 
@@ -242,7 +242,7 @@ def parse(filename):
         
         name = fields[0]
         layout = fields[1]
-        block_width, block_height = map(int, fields[2:4])
+        block_width, block_height = list(map(int, fields[2:4]))
 
         swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
         colorspace = fields[9]
diff --git a/src/gallium/auxiliary/util/u_format_srgb.py b/src/gallium/auxiliary/util/u_format_srgb.py
index cd63ae7..6b3d16d 100644
--- a/src/gallium/auxiliary/util/u_format_srgb.py
+++ b/src/gallium/auxiliary/util/u_format_srgb.py
@@ -56,43 +56,43 @@ def linear_to_srgb(x):
         return 12.92 * x
 
 def generate_srgb_tables():
-    print 'const float'
-    print 'util_format_srgb_8unorm_to_linear_float_table[256] = {'
+    print('const float')
+    print('util_format_srgb_8unorm_to_linear_float_table[256] = {')
     for j in range(0, 256, 4):
-        print '   ',
+        print('   ', end=' ')
         for i in range(j, j + 4):
-            print '%.7e,' % (srgb_to_linear(i / 255.0),),
-        print
-    print '};'
-    print
-    print 'const uint8_t'
-    print 'util_format_srgb_to_linear_8unorm_table[256] = {'
+            print('%.7e,' % (srgb_to_linear(i / 255.0),), end=' ')
+        print()
+    print('};')
+    print()
+    print('const uint8_t')
+    print('util_format_srgb_to_linear_8unorm_table[256] = {')
     for j in range(0, 256, 16):
-        print '   ',
+        print('   ', end=' ')
         for i in range(j, j + 16):
-            print '%3u,' % (int(srgb_to_linear(i / 255.0) * 255.0 + 0.5),),
-        print
-    print '};'
-    print
-    print 'const uint8_t'
-    print 'util_format_linear_to_srgb_8unorm_table[256] = {'
+            print('%3u,' % (int(srgb_to_linear(i / 255.0) * 255.0 + 0.5),), end=' ')
+        print()
+    print('};')
+    print()
+    print('const uint8_t')
+    print('util_format_linear_to_srgb_8unorm_table[256] = {')
     for j in range(0, 256, 16):
-        print '   ',
+        print('   ', end=' ')
         for i in range(j, j + 16):
-            print '%3u,' % (int(linear_to_srgb(i / 255.0) * 255.0 + 0.5),),
-        print
-    print '};'
-    print
+            print('%3u,' % (int(linear_to_srgb(i / 255.0) * 255.0 + 0.5),), end=' ')
+        print()
+    print('};')
+    print()
 
 
 def main():
-    print '/* This file is autogenerated by u_format_srgb.py. Do not edit directly. */'
-    print
+    print('/* This file is autogenerated by u_format_srgb.py. Do not edit directly. */')
+    print()
     # This will print the copyright message on the top of this file
-    print CopyRight.strip()
-    print
-    print '#include "u_format_srgb.h"'
-    print
+    print(CopyRight.strip())
+    print()
+    print('#include "u_format_srgb.h"')
+    print()
     generate_srgb_tables()    
 
 
diff --git a/src/gallium/auxiliary/util/u_format_table.py b/src/gallium/auxiliary/util/u_format_table.py
index 55e0f78..116b765 100755
--- a/src/gallium/auxiliary/util/u_format_table.py
+++ b/src/gallium/auxiliary/util/u_format_table.py
@@ -80,32 +80,32 @@ swizzle_map = {
 
 
 def write_format_table(formats):
-    print '/* This file is autogenerated by u_format_table.py from u_format.csv. Do not edit directly. */'
-    print
+    print('/* This file is autogenerated by u_format_table.py from u_format.csv. Do not edit directly. */')
+    print()
     # This will print the copyright message on the top of this file
-    print CopyRight.strip()
-    print
-    print '#include "u_format.h"'
-    print '#include "u_format_s3tc.h"'
-    print '#include "u_format_rgtc.h"'
-    print '#include "u_format_latc.h"'
-    print
+    print(CopyRight.strip())
+    print()
+    print('#include "u_format.h"')
+    print('#include "u_format_s3tc.h"')
+    print('#include "u_format_rgtc.h"')
+    print('#include "u_format_latc.h"')
+    print()
     
     u_format_pack.generate(formats)
     
     for format in formats:
-        print 'const struct util_format_description'
-        print 'util_format_%s_description = {' % (format.short_name(),)
-        print "   %s," % (format.name,)
-        print "   \"%s\"," % (format.name,)
-        print "   \"%s\"," % (format.short_name(),)
-        print "   {%u, %u, %u},\t/* block */" % (format.block_width, format.block_height, format.block_size())
-        print "   %s," % (layout_map(format.layout),)
-        print "   %u,\t/* nr_channels */" % (format.nr_channels(),)
-        print "   %s,\t/* is_array */" % (bool_map(format.is_array()),)
-        print "   %s,\t/* is_bitmask */" % (bool_map(format.is_bitmask()),)
-        print "   %s,\t/* is_mixed */" % (bool_map(format.is_mixed()),)
-        print "   {"
+        print('const struct util_format_description')
+        print('util_format_%s_description = {' % (format.short_name(),))
+        print("   %s," % (format.name,))
+        print("   \"%s\"," % (format.name,))
+        print("   \"%s\"," % (format.short_name(),))
+        print("   {%u, %u, %u},\t/* block */" % (format.block_width, format.block_height, format.block_size()))
+        print("   %s," % (layout_map(format.layout),))
+        print("   %u,\t/* nr_channels */" % (format.nr_channels(),))
+        print("   %s,\t/* is_array */" % (bool_map(format.is_array()),))
+        print("   %s,\t/* is_bitmask */" % (bool_map(format.is_bitmask()),))
+        print("   %s,\t/* is_mixed */" % (bool_map(format.is_mixed()),))
+        print("   {")
         for i in range(4):
             channel = format.channels[i]
             if i < 3:
@@ -113,11 +113,11 @@ def write_format_table(formats):
             else:
                 sep = ""
             if channel.size:
-                print "      {%s, %s, %u}%s\t/* %s = %s */" % (type_map[channel.type], bool_map(channel.norm), channel.size, sep, "xyzw"[i], channel.name)
+                print("      {%s, %s, %u}%s\t/* %s = %s */" % (type_map[channel.type], bool_map(channel.norm), channel.size, sep, "xyzw"[i], channel.name))
             else:
-                print "      {0, 0, 0}%s" % (sep,)
-        print "   },"
-        print "   {"
+                print("      {0, 0, 0}%s" % (sep,))
+        print("   },")
+        print("   {")
         for i in range(4):
             swizzle = format.swizzles[i]
             if i < 3:
@@ -128,61 +128,61 @@ def write_format_table(formats):
                 comment = colorspace_channels_map[format.colorspace][i]
             except (KeyError, IndexError):
                 comment = 'ignored'
-            print "      %s%s\t/* %s */" % (swizzle_map[swizzle], sep, comment)
-        print "   },"
-        print "   %s," % (colorspace_map(format.colorspace),)
+            print("      %s%s\t/* %s */" % (swizzle_map[swizzle], sep, comment))
+        print("   },")
+        print("   %s," % (colorspace_map(format.colorspace),))
         if format.colorspace != ZS:
-            print "   &util_format_%s_unpack_rgba_8unorm," % format.short_name() 
-            print "   &util_format_%s_pack_rgba_8unorm," % format.short_name() 
+            print("   &util_format_%s_unpack_rgba_8unorm," % format.short_name()) 
+            print("   &util_format_%s_pack_rgba_8unorm," % format.short_name()) 
             if format.layout == 's3tc' or format.layout == 'rgtc':
-                print "   &util_format_%s_fetch_rgba_8unorm," % format.short_name()
+                print("   &util_format_%s_fetch_rgba_8unorm," % format.short_name())
             else:
-                print "   NULL, /* fetch_rgba_8unorm */" 
-            print "   &util_format_%s_unpack_rgba_float," % format.short_name() 
-            print "   &util_format_%s_pack_rgba_float," % format.short_name() 
-            print "   &util_format_%s_fetch_rgba_float," % format.short_name()
+                print("   NULL, /* fetch_rgba_8unorm */") 
+            print("   &util_format_%s_unpack_rgba_float," % format.short_name()) 
+            print("   &util_format_%s_pack_rgba_float," % format.short_name()) 
+            print("   &util_format_%s_fetch_rgba_float," % format.short_name())
         else:
-            print "   NULL, /* unpack_rgba_8unorm */" 
-            print "   NULL, /* pack_rgba_8unorm */" 
-            print "   NULL, /* fetch_rgba_8unorm */" 
-            print "   NULL, /* unpack_rgba_float */" 
-            print "   NULL, /* pack_rgba_float */" 
-            print "   NULL, /* fetch_rgba_float */" 
+            print("   NULL, /* unpack_rgba_8unorm */") 
+            print("   NULL, /* pack_rgba_8unorm */") 
+            print("   NULL, /* fetch_rgba_8unorm */") 
+            print("   NULL, /* unpack_rgba_float */") 
+            print("   NULL, /* pack_rgba_float */") 
+            print("   NULL, /* fetch_rgba_float */") 
         if format.colorspace == ZS and format.swizzles[0] != SWIZZLE_NONE:
-            print "   &util_format_%s_unpack_z_32unorm," % format.short_name() 
-            print "   &util_format_%s_pack_z_32unorm," % format.short_name() 
-            print "   &util_format_%s_unpack_z_float," % format.short_name() 
-            print "   &util_format_%s_pack_z_float," % format.short_name() 
+            print("   &util_format_%s_unpack_z_32unorm," % format.short_name()) 
+            print("   &util_format_%s_pack_z_32unorm," % format.short_name()) 
+            print("   &util_format_%s_unpack_z_float," % format.short_name()) 
+            print("   &util_format_%s_pack_z_float," % format.short_name()) 
         else:
-            print "   NULL, /* unpack_z_32unorm */" 
-            print "   NULL, /* pack_z_32unorm */" 
-            print "   NULL, /* unpack_z_float */" 
-            print "   NULL, /* pack_z_float */" 
+            print("   NULL, /* unpack_z_32unorm */") 
+            print("   NULL, /* pack_z_32unorm */") 
+            print("   NULL, /* unpack_z_float */") 
+            print("   NULL, /* pack_z_float */") 
         if format.colorspace == ZS and format.swizzles[1] != SWIZZLE_NONE:
-            print "   &util_format_%s_unpack_s_8uscaled," % format.short_name() 
-            print "   &util_format_%s_pack_s_8uscaled" % format.short_name() 
+            print("   &util_format_%s_unpack_s_8uscaled," % format.short_name()) 
+            print("   &util_format_%s_pack_s_8uscaled" % format.short_name()) 
         else:
-            print "   NULL, /* unpack_s_8uscaled */" 
-            print "   NULL /* pack_s_8uscaled */" 
-        print "};"
-        print
+            print("   NULL, /* unpack_s_8uscaled */") 
+            print("   NULL /* pack_s_8uscaled */") 
+        print("};")
+        print()
         
-    print "const struct util_format_description *"
-    print "util_format_description(enum pipe_format format)"
-    print "{"
-    print "   if (format >= PIPE_FORMAT_COUNT) {"
-    print "      return NULL;"
-    print "   }"
-    print
-    print "   switch (format) {"
+    print("const struct util_format_description *")
+    print("util_format_description(enum pipe_format format)")
+    print("{")
+    print("   if (format >= PIPE_FORMAT_COUNT) {")
+    print("      return NULL;")
+    print("   }")
+    print()
+    print("   switch (format) {")
     for format in formats:
-        print "   case %s:" % format.name
-        print "      return &util_format_%s_description;" % (format.short_name(),)
-    print "   default:"
-    print "      return NULL;"
-    print "   }"
-    print "}"
-    print
+        print("   case %s:" % format.name)
+        print("      return &util_format_%s_description;" % (format.short_name(),))
+    print("   default:")
+    print("      return NULL;")
+    print("   }")
+    print("}")
+    print()
 
 
 def main():
diff --git a/src/gallium/auxiliary/util/u_half.py b/src/gallium/auxiliary/util/u_half.py
index 915cf3b..61315da 100644
--- a/src/gallium/auxiliary/util/u_half.py
+++ b/src/gallium/auxiliary/util/u_half.py
@@ -55,29 +55,29 @@ def begin(t, n, l):
 	global table_index
 	table_index = 0
 	table_length = l
-	print
-	print "const " + t + " " + n + "[" + str(l) + "] = {"
+	print()
+	print("const " + t + " " + n + "[" + str(l) + "] = {")
 
 def value(v):
 	global table_index
 	table_index += 1
-	print "\t" + hex(v) + ","
+	print("\t" + hex(v) + ",")
 
 def end():
 	global table_length
 	global table_index
-	print "};"
+	print("};")
 	assert table_index == table_length
 
-print "/* This file is autogenerated by u_half.py. Do not edit directly. */"
-print "#include \"util/u_half.h\""
+print("/* This file is autogenerated by u_half.py. Do not edit directly. */")
+print("#include \"util/u_half.h\"")
 
 begin("uint32_t", "util_half_to_float_mantissa_table", 2048)
 # zero
 value(0)
 
 # denormals
-for i in xrange(1, 1024):
+for i in range(1, 1024):
 	m = i << 13
 	e = 0
 
@@ -91,7 +91,7 @@ for i in xrange(1, 1024):
 	value(m | e)
 
 # normals
-for i in xrange(1024, 2048):
+for i in range(1024, 2048):
 	value((i - 1024) << 13)
 end()
 
@@ -100,7 +100,7 @@ begin("uint32_t", "util_half_to_float_exponent_table", 64)
 value(0)
 
 # positive numbers
-for i in xrange(1, 31):
+for i in range(1, 31):
 	value(0x38000000 + (i << 23))
 
 # positive infinity/NaN
@@ -129,26 +129,26 @@ for i in range(1, 32):
 value(0)
 
 # negative normals
-for i in xrange(33, 64):
+for i in range(33, 64):
 	value(1024)
 end()
 
 begin("uint16_t", "util_float_to_half_base_table", 512)
 for sign in (0, 0x8000):
 	# very small numbers mapping to zero
-	for i in xrange(-127, -24):
+	for i in range(-127, -24):
 		value(sign | 0)
 
 	# small numbers mapping to denormals
-	for i in xrange(-24, -14):
+	for i in range(-24, -14):
 		value(sign | (0x400 >> (-14 -i)))
 
 	# normal numbers
-	for i in xrange(-14, 16):
+	for i in range(-14, 16):
 		value(sign | ((i + 15) << 10))
 
 	# large numbers mapping to infinity
-	for i in xrange(16, 128):
+	for i in range(16, 128):
 		value(sign | 0x7c00)
 
 	# infinity and NaNs
@@ -158,19 +158,19 @@ end()
 begin("uint8_t", "util_float_to_half_shift_table", 512)
 for sign in (0, 0x8000):
 	# very small numbers mapping to zero
-	for i in xrange(-127, -24):
+	for i in range(-127, -24):
 		value(24)
 
 	# small numbers mapping to denormals
-	for i in xrange(-24, -14):
+	for i in range(-24, -14):
 		value(-1 - i)
 
 	# normal numbers
-	for i in xrange(-14, 16):
+	for i in range(-14, 16):
 		value(13)
 
 	# large numbers mapping to infinity
-	for i in xrange(16, 128):
+	for i in range(16, 128):
 		value(24)
 
 	# infinity and NaNs
diff --git a/src/gallium/docs/source/conf.py b/src/gallium/docs/source/conf.py
index 0846e7d..fa694d5 100644
--- a/src/gallium/docs/source/conf.py
+++ b/src/gallium/docs/source/conf.py
@@ -37,8 +37,8 @@ source_suffix = '.rst'
 master_doc = 'index'
 
 # General information about the project.
-project = u'Gallium'
-copyright = u'2009, VMware, X.org, Nouveau'
+project = 'Gallium'
+copyright = '2009, VMware, X.org, Nouveau'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
@@ -175,8 +175,8 @@ htmlhelp_basename = 'Galliumdoc'
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title, author, documentclass [howto/manual]).
 latex_documents = [
-  ('index', 'Gallium.tex', u'Gallium Documentation',
-   u'VMware, X.org, Nouveau', 'manual'),
+  ('index', 'Gallium.tex', 'Gallium Documentation',
+   'VMware, X.org, Nouveau', 'manual'),
 ]
 
 # The name of an image file (relative to this directory) to place at the top of
diff --git a/src/gallium/drivers/llvmpipe/lp_tile_soa.py b/src/gallium/drivers/llvmpipe/lp_tile_soa.py
index f4324e6..97a4887 100644
--- a/src/gallium/drivers/llvmpipe/lp_tile_soa.py
+++ b/src/gallium/drivers/llvmpipe/lp_tile_soa.py
@@ -58,7 +58,7 @@ def is_format_supported(format):
         channel = format.channels[i]
         if channel.type not in (VOID, UNSIGNED, SIGNED, FLOAT):
             return False
-        if channel.type == FLOAT and channel.size not in (16, 32 ,64):
+        if channel.type == FLOAT and channel.size not in (16, 32, 64):
             return False
 
     if format.colorspace not in ('rgb', 'srgb'):
@@ -74,14 +74,14 @@ def generate_format_read(format, dst_channel, dst_native_type, dst_suffix):
 
     src_native_type = native_type(format)
 
-    print 'static void'
-    print 'lp_tile_%s_swizzle_%s(%s *dst, const uint8_t *src, unsigned src_stride, unsigned x0, unsigned y0)' % (name, dst_suffix, dst_native_type)
-    print '{'
-    print '   unsigned x, y;'
-    print '   const uint8_t *src_row = src + y0*src_stride;'
-    print '   for (y = 0; y < TILE_SIZE; ++y) {'
-    print '      const %s *src_pixel = (const %s *)(src_row + x0*%u);' % (src_native_type, src_native_type, format.stride())
-    print '      for (x = 0; x < TILE_SIZE; ++x) {'
+    print('static void')
+    print('lp_tile_%s_swizzle_%s(%s *dst, const uint8_t *src, unsigned src_stride, unsigned x0, unsigned y0)' % (name, dst_suffix, dst_native_type))
+    print('{')
+    print('   unsigned x, y;')
+    print('   const uint8_t *src_row = src + y0*src_stride;')
+    print('   for (y = 0; y < TILE_SIZE; ++y) {')
+    print('      const %s *src_pixel = (const %s *)(src_row + x0*%u);' % (src_native_type, src_native_type, format.stride()))
+    print('      for (x = 0; x < TILE_SIZE; ++x) {')
 
     names = ['']*4
     if format.colorspace in ('rgb', 'srgb'):
@@ -100,7 +100,7 @@ def generate_format_read(format, dst_channel, dst_native_type, dst_suffix):
 
     if format.layout == PLAIN:
         if not format.is_array():
-            print '         %s pixel = *src_pixel++;' % src_native_type
+            print('         %s pixel = *src_pixel++;' % src_native_type)
             shift = 0;
             for i in range(4):
                 src_channel = format.channels[i]
@@ -113,20 +113,20 @@ def generate_format_read(format, dst_channel, dst_native_type, dst_suffix):
                     if shift + width < format.block_size():
                         value = '(%s & 0x%x)' % (value, mask)
                     value = conversion_expr(src_channel, dst_channel, dst_native_type, value, clamp=False)
-                    print '         %s %s = %s;' % (dst_native_type, names[i], value)
+                    print('         %s %s = %s;' % (dst_native_type, names[i], value))
                 shift += width
         else:
             for i in range(4):
                 if names[i]:
-                    print '         %s %s;' % (dst_native_type, names[i])
+                    print('         %s %s;' % (dst_native_type, names[i]))
             for i in range(4):
                 src_channel = format.channels[i]
                 if names[i]:
                     value = '(*src_pixel++)'
                     value = conversion_expr(src_channel, dst_channel, dst_native_type, value, clamp=False)
-                    print '         %s = %s;' % (names[i], value)
+                    print('         %s = %s;' % (names[i], value))
                 elif src_channel.size:
-                    print '         ++src_pixel;'
+                    print('         ++src_pixel;')
     else:
         assert False
 
@@ -148,13 +148,13 @@ def generate_format_read(format, dst_channel, dst_native_type, dst_suffix):
                 value = get_one(dst_channel)
         else:
             assert False
-        print '         TILE_PIXEL(dst, x, y, %u) = %s; /* %s */' % (i, value, 'rgba'[i])
+        print('         TILE_PIXEL(dst, x, y, %u) = %s; /* %s */' % (i, value, 'rgba'[i]))
 
-    print '      }'
-    print '      src_row += src_stride;'
-    print '   }'
-    print '}'
-    print
+    print('      }')
+    print('      src_row += src_stride;')
+    print('   }')
+    print('}')
+    print()
     
 
 def pack_rgba(format, src_channel, r, g, b, a):
@@ -198,29 +198,29 @@ def emit_unrolled_unswizzle_code(format, src_channel):
     This is considerably faster than the TILE_PIXEL-based code below.
     '''
     dst_native_type = 'uint%u_t' % format.block_size()
-    print '   const unsigned dstpix_stride = dst_stride / %d;' % format.stride()
-    print '   %s *dstpix = (%s *) dst;' % (dst_native_type, dst_native_type)
-    print '   unsigned int qx, qy, i;'
-    print
-    print '   for (qy = 0; qy < TILE_SIZE; qy += TILE_VECTOR_HEIGHT) {'
-    print '      const unsigned py = y0 + qy;'
-    print '      for (qx = 0; qx < TILE_SIZE; qx += TILE_VECTOR_WIDTH) {'
-    print '         const unsigned px = x0 + qx;'
-    print '         const uint8_t *r = src + 0 * TILE_C_STRIDE;'
-    print '         const uint8_t *g = src + 1 * TILE_C_STRIDE;'
-    print '         const uint8_t *b = src + 2 * TILE_C_STRIDE;'
-    print '         const uint8_t *a = src + 3 * TILE_C_STRIDE;'
-    print '         (void) r; (void) g; (void) b; (void) a; /* silence warnings */'
-    print '         for (i = 0; i < TILE_C_STRIDE; i += 2) {'
-    print '            const uint32_t pixel0 = %s;' % pack_rgba(format, src_channel, "r[i+0]", "g[i+0]", "b[i+0]", "a[i+0]")
-    print '            const uint32_t pixel1 = %s;' % pack_rgba(format, src_channel, "r[i+1]", "g[i+1]", "b[i+1]", "a[i+1]")
-    print '            const unsigned offset = (py + tile_y_offset[i]) * dstpix_stride + (px + tile_x_offset[i]);'
-    print '            dstpix[offset + 0] = pixel0;'
-    print '            dstpix[offset + 1] = pixel1;'
-    print '         }'
-    print '         src += TILE_X_STRIDE;'
-    print '      }'
-    print '   }'
+    print('   const unsigned dstpix_stride = dst_stride / %d;' % format.stride())
+    print('   %s *dstpix = (%s *) dst;' % (dst_native_type, dst_native_type))
+    print('   unsigned int qx, qy, i;')
+    print()
+    print('   for (qy = 0; qy < TILE_SIZE; qy += TILE_VECTOR_HEIGHT) {')
+    print('      const unsigned py = y0 + qy;')
+    print('      for (qx = 0; qx < TILE_SIZE; qx += TILE_VECTOR_WIDTH) {')
+    print('         const unsigned px = x0 + qx;')
+    print('         const uint8_t *r = src + 0 * TILE_C_STRIDE;')
+    print('         const uint8_t *g = src + 1 * TILE_C_STRIDE;')
+    print('         const uint8_t *b = src + 2 * TILE_C_STRIDE;')
+    print('         const uint8_t *a = src + 3 * TILE_C_STRIDE;')
+    print('         (void) r; (void) g; (void) b; (void) a; /* silence warnings */')
+    print('         for (i = 0; i < TILE_C_STRIDE; i += 2) {')
+    print('            const uint32_t pixel0 = %s;' % pack_rgba(format, src_channel, "r[i+0]", "g[i+0]", "b[i+0]", "a[i+0]"))
+    print('            const uint32_t pixel1 = %s;' % pack_rgba(format, src_channel, "r[i+1]", "g[i+1]", "b[i+1]", "a[i+1]"))
+    print('            const unsigned offset = (py + tile_y_offset[i]) * dstpix_stride + (px + tile_x_offset[i]);')
+    print('            dstpix[offset + 0] = pixel0;')
+    print('            dstpix[offset + 1] = pixel1;')
+    print('         }')
+    print('         src += TILE_X_STRIDE;')
+    print('      }')
+    print('   }')
 
 
 def emit_tile_pixel_unswizzle_code(format, src_channel):
@@ -229,15 +229,15 @@ def emit_tile_pixel_unswizzle_code(format, src_channel):
 
     inv_swizzle = format.inv_swizzles()
 
-    print '   unsigned x, y;'
-    print '   uint8_t *dst_row = dst + y0*dst_stride;'
-    print '   for (y = 0; y < TILE_SIZE; ++y) {'
-    print '      %s *dst_pixel = (%s *)(dst_row + x0*%u);' % (dst_native_type, dst_native_type, format.stride())
-    print '      for (x = 0; x < TILE_SIZE; ++x) {'
+    print('   unsigned x, y;')
+    print('   uint8_t *dst_row = dst + y0*dst_stride;')
+    print('   for (y = 0; y < TILE_SIZE; ++y) {')
+    print('      %s *dst_pixel = (%s *)(dst_row + x0*%u);' % (dst_native_type, dst_native_type, format.stride()))
+    print('      for (x = 0; x < TILE_SIZE; ++x) {')
 
     if format.layout == PLAIN:
         if not format.is_array():
-            print '         %s pixel = 0;' % dst_native_type
+            print('         %s pixel = 0;' % dst_native_type)
             shift = 0;
             for i in range(4):
                 dst_channel = format.channels[i]
@@ -247,24 +247,24 @@ def emit_tile_pixel_unswizzle_code(format, src_channel):
                     value = conversion_expr(src_channel, dst_channel, dst_native_type, value, clamp=False)
                     if shift:
                         value = '(%s << %u)' % (value, shift)
-                    print '         pixel |= %s;' % value
+                    print('         pixel |= %s;' % value)
                 shift += width
-            print '         *dst_pixel++ = pixel;'
+            print('         *dst_pixel++ = pixel;')
         else:
             for i in range(4):
                 dst_channel = format.channels[i]
                 if inv_swizzle[i] is not None:
                     value = 'TILE_PIXEL(src, x, y, %u)' % inv_swizzle[i]
                     value = conversion_expr(src_channel, dst_channel, dst_native_type, value, clamp=False)
-                    print '         *dst_pixel++ = %s;' % value
+                    print('         *dst_pixel++ = %s;' % value)
                 elif dst_channel.size:
-                    print '         ++dst_pixel;'
+                    print('         ++dst_pixel;')
     else:
         assert False
 
-    print '      }'
-    print '      dst_row += dst_stride;'
-    print '   }'
+    print('      }')
+    print('      dst_row += dst_stride;')
+    print('   }')
 
 
 def generate_format_write(format, src_channel, src_native_type, src_suffix):
@@ -272,9 +272,9 @@ def generate_format_write(format, src_channel, src_native_type, src_suffix):
 
     name = format.short_name()
 
-    print 'static void'
-    print 'lp_tile_%s_unswizzle_%s(const %s *src, uint8_t *dst, unsigned dst_stride, unsigned x0, unsigned y0)' % (name, src_suffix, src_native_type)
-    print '{'
+    print('static void')
+    print('lp_tile_%s_unswizzle_%s(const %s *src, uint8_t *dst, unsigned dst_stride, unsigned x0, unsigned y0)' % (name, src_suffix, src_native_type))
+    print('{')
     if format.layout == PLAIN \
         and format.colorspace == 'rgb' \
         and format.block_size() <= 32 \
@@ -285,12 +285,12 @@ def generate_format_write(format, src_channel, src_native_type, src_suffix):
         emit_unrolled_unswizzle_code(format, src_channel)
     else:
         emit_tile_pixel_unswizzle_code(format, src_channel)
-    print '}'
-    print
+    print('}')
+    print()
     
 
 def generate_sse2():
-    print '''
+    print('''
 #if defined(PIPE_ARCH_SSE)
 
 #include "util/u_sse.h"
@@ -488,7 +488,7 @@ lp_tile_b8g8r8x8_unorm_unswizzle_4ub_sse2(const uint8_t * restrict src,
 }
 
 #endif /* PIPE_ARCH_SSE */
-'''
+''')
 
 
 def generate_swizzle(formats, dst_channel, dst_native_type, dst_suffix):
@@ -498,34 +498,34 @@ def generate_swizzle(formats, dst_channel, dst_native_type, dst_suffix):
         if is_format_supported(format):
             generate_format_read(format, dst_channel, dst_native_type, dst_suffix)
 
-    print 'void'
-    print 'lp_tile_swizzle_%s(enum pipe_format format, %s *dst, const void *src, unsigned src_stride, unsigned x, unsigned y)' % (dst_suffix, dst_native_type)
-    print '{'
-    print '   void (*func)(%s *dst, const uint8_t *src, unsigned src_stride, unsigned x0, unsigned y0);' % dst_native_type
-    print '#ifdef DEBUG'
-    print '   lp_tile_swizzle_count += 1;'
-    print '#endif'
-    print '   switch(format) {'
+    print('void')
+    print('lp_tile_swizzle_%s(enum pipe_format format, %s *dst, const void *src, unsigned src_stride, unsigned x, unsigned y)' % (dst_suffix, dst_native_type))
+    print('{')
+    print('   void (*func)(%s *dst, const uint8_t *src, unsigned src_stride, unsigned x0, unsigned y0);' % dst_native_type)
+    print('#ifdef DEBUG')
+    print('   lp_tile_swizzle_count += 1;')
+    print('#endif')
+    print('   switch(format) {')
     for format in formats:
         if is_format_supported(format):
-            print '   case %s:' % format.name
+            print('   case %s:' % format.name)
             func_name = 'lp_tile_%s_swizzle_%s' % (format.short_name(), dst_suffix)
             if format.name == 'PIPE_FORMAT_B8G8R8A8_UNORM' or format.name == 'PIPE_FORMAT_B8G8R8X8_UNORM':
-                print '#ifdef PIPE_ARCH_SSE'
-                print '      func = util_cpu_caps.has_sse2 ? %s_sse2 : %s;' % (func_name, func_name)
-                print '#else'
-                print '      func = %s;' % (func_name,)
-                print '#endif'
+                print('#ifdef PIPE_ARCH_SSE')
+                print('      func = util_cpu_caps.has_sse2 ? %s_sse2 : %s;' % (func_name, func_name))
+                print('#else')
+                print('      func = %s;' % (func_name,))
+                print('#endif')
             else:
-                print '      func = %s;' % (func_name,)
-            print '      break;'
-    print '   default:'
-    print '      debug_printf("%s: unsupported format %s\\n", __FUNCTION__, util_format_name(format));'
-    print '      return;'
-    print '   }'
-    print '   func(dst, (const uint8_t *)src, src_stride, x, y);'
-    print '}'
-    print
+                print('      func = %s;' % (func_name,))
+            print('      break;')
+    print('   default:')
+    print('      debug_printf("%s: unsupported format %s\\n", __FUNCTION__, util_format_name(format));')
+    print('      return;')
+    print('   }')
+    print('   func(dst, (const uint8_t *)src, src_stride, x, y);')
+    print('}')
+    print()
 
 
 def generate_unswizzle(formats, src_channel, src_native_type, src_suffix):
@@ -535,35 +535,35 @@ def generate_unswizzle(formats, src_channel, src_native_type, src_suffix):
         if is_format_supported(format):
             generate_format_write(format, src_channel, src_native_type, src_suffix)
 
-    print 'void'
-    print 'lp_tile_unswizzle_%s(enum pipe_format format, const %s *src, void *dst, unsigned dst_stride, unsigned x, unsigned y)' % (src_suffix, src_native_type)
+    print('void')
+    print('lp_tile_unswizzle_%s(enum pipe_format format, const %s *src, void *dst, unsigned dst_stride, unsigned x, unsigned y)' % (src_suffix, src_native_type))
     
-    print '{'
-    print '   void (*func)(const %s *src, uint8_t *dst, unsigned dst_stride, unsigned x0, unsigned y0);' % src_native_type
-    print '#ifdef DEBUG'
-    print '   lp_tile_unswizzle_count += 1;'
-    print '#endif'
-    print '   switch(format) {'
+    print('{')
+    print('   void (*func)(const %s *src, uint8_t *dst, unsigned dst_stride, unsigned x0, unsigned y0);' % src_native_type)
+    print('#ifdef DEBUG')
+    print('   lp_tile_unswizzle_count += 1;')
+    print('#endif')
+    print('   switch(format) {')
     for format in formats:
         if is_format_supported(format):
-            print '   case %s:' % format.name
+            print('   case %s:' % format.name)
             func_name = 'lp_tile_%s_unswizzle_%s' % (format.short_name(), src_suffix)
             if format.name == 'PIPE_FORMAT_B8G8R8A8_UNORM' or format.name == 'PIPE_FORMAT_B8G8R8X8_UNORM':
-                print '#ifdef PIPE_ARCH_SSE'
-                print '      func = util_cpu_caps.has_sse2 ? %s_sse2 : %s;' % (func_name, func_name)
-                print '#else'
-                print '      func = %s;' % (func_name,)
-                print '#endif'
+                print('#ifdef PIPE_ARCH_SSE')
+                print('      func = util_cpu_caps.has_sse2 ? %s_sse2 : %s;' % (func_name, func_name))
+                print('#else')
+                print('      func = %s;' % (func_name,))
+                print('#endif')
             else:
-                print '      func = %s;' % (func_name,)
-            print '      break;'
-    print '   default:'
-    print '      debug_printf("%s: unsupported format %s\\n", __FUNCTION__, util_format_name(format));'
-    print '      return;'
-    print '   }'
-    print '   func(src, (uint8_t *)dst, dst_stride, x, y);'
-    print '}'
-    print
+                print('      func = %s;' % (func_name,))
+            print('      break;')
+    print('   default:')
+    print('      debug_printf("%s: unsupported format %s\\n", __FUNCTION__, util_format_name(format));')
+    print('      return;')
+    print('   }')
+    print('   func(src, (uint8_t *)dst, dst_stride, x, y);')
+    print('}')
+    print()
 
 
 def main():
@@ -571,44 +571,44 @@ def main():
     for arg in sys.argv[1:]:
         formats.extend(parse(arg))
 
-    print '/* This file is autogenerated by lp_tile_soa.py from u_format.csv. Do not edit directly. */'
-    print
+    print('/* This file is autogenerated by lp_tile_soa.py from u_format.csv. Do not edit directly. */')
+    print()
     # This will print the copyright message on the top of this file
-    print CopyRight.strip()
-    print
-    print '#include "pipe/p_compiler.h"'
-    print '#include "util/u_format.h"'
-    print '#include "util/u_math.h"'
-    print '#include "util/u_half.h"'
-    print '#include "util/u_cpu_detect.h"'
-    print '#include "lp_tile_soa.h"'
-    print
-    print '#ifdef DEBUG'
-    print 'unsigned lp_tile_unswizzle_count = 0;'
-    print 'unsigned lp_tile_swizzle_count = 0;'
-    print '#endif'
-    print
-    print 'const unsigned char'
-    print 'tile_offset[TILE_VECTOR_HEIGHT][TILE_VECTOR_WIDTH] = {'
-    print '   {  0,  1,  4,  5},'
-    print '   {  2,  3,  6,  7},'
-    print '   {  8,  9, 12, 13},'
-    print '   { 10, 11, 14, 15}'
-    print '};'
-    print
-    print '/* Note: these lookup tables could be replaced with some'
-    print ' * bit-twiddling code, but this is a little faster.'
-    print ' */'
-    print 'static unsigned tile_x_offset[TILE_VECTOR_WIDTH * TILE_VECTOR_HEIGHT] = {'
-    print '   0, 1, 0, 1, 2, 3, 2, 3,'
-    print '   0, 1, 0, 1, 2, 3, 2, 3'
-    print '};'
-    print
-    print 'static unsigned tile_y_offset[TILE_VECTOR_WIDTH * TILE_VECTOR_HEIGHT] = {'
-    print '   0, 0, 1, 1, 0, 0, 1, 1,'
-    print '   2, 2, 3, 3, 2, 2, 3, 3'
-    print '};'
-    print
+    print(CopyRight.strip())
+    print()
+    print('#include "pipe/p_compiler.h"')
+    print('#include "util/u_format.h"')
+    print('#include "util/u_math.h"')
+    print('#include "util/u_half.h"')
+    print('#include "util/u_cpu_detect.h"')
+    print('#include "lp_tile_soa.h"')
+    print()
+    print('#ifdef DEBUG')
+    print('unsigned lp_tile_unswizzle_count = 0;')
+    print('unsigned lp_tile_swizzle_count = 0;')
+    print('#endif')
+    print()
+    print('const unsigned char')
+    print('tile_offset[TILE_VECTOR_HEIGHT][TILE_VECTOR_WIDTH] = {')
+    print('   {  0,  1,  4,  5},')
+    print('   {  2,  3,  6,  7},')
+    print('   {  8,  9, 12, 13},')
+    print('   { 10, 11, 14, 15}')
+    print('};')
+    print()
+    print('/* Note: these lookup tables could be replaced with some')
+    print(' * bit-twiddling code, but this is a little faster.')
+    print(' */')
+    print('static unsigned tile_x_offset[TILE_VECTOR_WIDTH * TILE_VECTOR_HEIGHT] = {')
+    print('   0, 1, 0, 1, 2, 3, 2, 3,')
+    print('   0, 1, 0, 1, 2, 3, 2, 3')
+    print('};')
+    print()
+    print('static unsigned tile_y_offset[TILE_VECTOR_WIDTH * TILE_VECTOR_HEIGHT] = {')
+    print('   0, 0, 1, 1, 0, 0, 1, 1,')
+    print('   2, 2, 3, 3, 2, 2, 3, 3')
+    print('};')
+    print()
 
     generate_sse2()
 
diff --git a/src/gallium/drivers/svga/svgadump/svga_dump.py b/src/gallium/drivers/svga/svgadump/svga_dump.py
index 0bc0b3a..3f71ff0 100755
--- a/src/gallium/drivers/svga/svgadump/svga_dump.py
+++ b/src/gallium/drivers/svga/svgadump/svga_dump.py
@@ -68,17 +68,17 @@ class decl_dumper_t(decl_visitor.decl_visitor_t):
 
     def visit_enumeration(self):
         if enums:
-            print '   switch(%s) {' % ("(*cmd)" + self._instance,)
+            print('   switch(%s) {' % ("(*cmd)" + self._instance,))
             for name, value in self.decl.values:
-                print '   case %s:' % (name,)
-                print '      _debug_printf("\\t\\t%s = %s\\n");' % (self._instance, name)
-                print '      break;'
-            print '   default:'
-            print '      _debug_printf("\\t\\t%s = %%i\\n", %s);' % (self._instance, "(*cmd)" + self._instance)
-            print '      break;'
-            print '   }'
+                print('   case %s:' % (name,))
+                print('      _debug_printf("\\t\\t%s = %s\\n");' % (self._instance, name))
+                print('      break;')
+            print('   default:')
+            print('      _debug_printf("\\t\\t%s = %%i\\n", %s);' % (self._instance, "(*cmd)" + self._instance))
+            print('      break;')
+            print('   }')
         else:
-            print '   _debug_printf("\\t\\t%s = %%i\\n", %s);' % (self._instance, "(*cmd)" + self._instance)
+            print('   _debug_printf("\\t\\t%s = %%i\\n", %s);' % (self._instance, "(*cmd)" + self._instance))
 
 
 def dump_decl(instance, decl):
@@ -154,7 +154,7 @@ class type_dumper_t(type_visitor.type_visitor_t):
         dump_decl(self.instance, decl)
 
     def print_instance(self, format):
-        print '   _debug_printf("\\t\\t%s = %s\\n", %s);' % (self.instance, format, "(*cmd)" + self.instance)
+        print('   _debug_printf("\\t\\t%s = %s\\n", %s);' % (self.instance, format, "(*cmd)" + self.instance))
 
 
 def dump_type(instance, type_):
@@ -164,12 +164,12 @@ def dump_type(instance, type_):
 
 
 def dump_struct(decls, class_):
-    print 'static void'
-    print 'dump_%s(const %s *cmd)' % (class_.name, class_.name)
-    print '{'
+    print('static void')
+    print('dump_%s(const %s *cmd)' % (class_.name, class_.name))
+    print('{')
     dump_decl('', class_)
-    print '}'
-    print ''
+    print('}')
+    print('')
 
 
 cmds = [
@@ -206,48 +206,48 @@ cmds = [
 ]
 
 def dump_cmds():
-    print r'''
+    print(r'''
 void            
 svga_dump_command(uint32_t cmd_id, const void *data, uint32_t size)
 {
    const uint8_t *body = (const uint8_t *)data;
    const uint8_t *next = body + size;
-'''
-    print '   switch(cmd_id) {'
+''')
+    print('   switch(cmd_id) {')
     indexes = 'ijklmn'
     for id, header, body, footer in cmds:
-        print '   case %s:' % id
-        print '      _debug_printf("\\t%s\\n");' % id
-        print '      {'
-        print '         const %s *cmd = (const %s *)body;' % (header, header)
+        print('   case %s:' % id)
+        print('      _debug_printf("\\t%s\\n");' % id)
+        print('      {')
+        print('         const %s *cmd = (const %s *)body;' % (header, header))
         if len(body):
-            print '         unsigned ' + ', '.join(indexes[:len(body)]) + ';'
-        print '         dump_%s(cmd);' % header
-        print '         body = (const uint8_t *)&cmd[1];'
+            print('         unsigned ' + ', '.join(indexes[:len(body)]) + ';')
+        print('         dump_%s(cmd);' % header)
+        print('         body = (const uint8_t *)&cmd[1];')
         for i in range(len(body)):
             struct, count = body[i]
             idx = indexes[i]
-            print '         for(%s = 0; %s < cmd->%s; ++%s) {' % (idx, idx, count, idx)
-            print '            dump_%s((const %s *)body);' % (struct, struct)
-            print '            body += sizeof(%s);' % struct
-            print '         }'
+            print('         for(%s = 0; %s < cmd->%s; ++%s) {' % (idx, idx, count, idx))
+            print('            dump_%s((const %s *)body);' % (struct, struct))
+            print('            body += sizeof(%s);' % struct)
+            print('         }')
         if footer is not None:
-            print '         while(body + sizeof(%s) <= next) {' % footer
-            print '            dump_%s((const %s *)body);' % (footer, footer)
-            print '            body += sizeof(%s);' % footer
-            print '         }'
+            print('         while(body + sizeof(%s) <= next) {' % footer)
+            print('            dump_%s((const %s *)body);' % (footer, footer))
+            print('            body += sizeof(%s);' % footer)
+            print('         }')
         if id == 'SVGA_3D_CMD_SHADER_DEFINE':
-            print '         svga_shader_dump((const uint32_t *)body,'
-            print '                          (unsigned)(next - body)/sizeof(uint32_t),'
-            print '                          FALSE);'
-            print '         body = next;'
-        print '      }'
-        print '      break;'
-    print '   default:'
-    print '      _debug_printf("\\t0x%08x\\n", cmd_id);'
-    print '      break;'
-    print '   }'
-    print r'''
+            print('         svga_shader_dump((const uint32_t *)body,')
+            print('                          (unsigned)(next - body)/sizeof(uint32_t),')
+            print('                          FALSE);')
+            print('         body = next;')
+        print('      }')
+        print('      break;')
+    print('   default:')
+    print('      _debug_printf("\\t0x%08x\\n", cmd_id);')
+    print('      break;')
+    print('   }')
+    print(r'''
    while(body + sizeof(uint32_t) <= next) {
       _debug_printf("\t\t0x%08x\n", *(const uint32_t *)body);
       body += sizeof(uint32_t);
@@ -255,8 +255,8 @@ svga_dump_command(uint32_t cmd_id, const void *data, uint32_t size)
    while(body + sizeof(uint32_t) <= next)
       _debug_printf("\t\t0x%02x\n", *body++);
 }
-'''
-    print r'''
+''')
+    print(r'''
 void            
 svga_dump_commands(const void *commands, uint32_t size)
 {
@@ -289,25 +289,25 @@ svga_dump_commands(const void *commands, uint32_t size)
       }
    }
 }
-'''
+''')
 
 def main():
-    print copyright.strip()
-    print
-    print '/**'
-    print ' * @file'
-    print ' * Dump SVGA commands.'
-    print ' *'
-    print ' * Generated automatically from svga3d_reg.h by svga_dump.py.'
-    print ' */'
-    print
-    print '#include "svga_types.h"'
-    print '#include "svga_shader_dump.h"'
-    print '#include "svga3d_reg.h"'
-    print
-    print '#include "util/u_debug.h"'
-    print '#include "svga_dump.h"'
-    print
+    print(copyright.strip())
+    print()
+    print('/**')
+    print(' * @file')
+    print(' * Dump SVGA commands.')
+    print(' *')
+    print(' * Generated automatically from svga3d_reg.h by svga_dump.py.')
+    print(' */')
+    print()
+    print('#include "svga_types.h"')
+    print('#include "svga_shader_dump.h"')
+    print('#include "svga3d_reg.h"')
+    print()
+    print('#include "util/u_debug.h"')
+    print('#include "svga_dump.h"')
+    print()
 
     config = parser.config_t(
         include_paths = ['../../../include', '../include'],
diff --git a/src/gallium/tools/trace/model.py b/src/gallium/tools/trace/model.py
index e76aad7..ea96c05 100755
--- a/src/gallium/tools/trace/model.py
+++ b/src/gallium/tools/trace/model.py
@@ -35,9 +35,9 @@ import string
 import format
 
 try:
-    from cStringIO import StringIO
+    from io import StringIO
 except ImportError:
-    from StringIO import StringIO
+    from io import StringIO
 
 
 class Node:
@@ -151,7 +151,7 @@ class PrettyPrinter:
         self.formatter = formatter
     
     def visit_literal(self, node):
-        if isinstance(node.value, basestring):
+        if isinstance(node.value, str):
             if len(node.value) >= 4096 or node.value.strip(string.printable):
                 self.formatter.address('blob(%u)' % len(node.value))
                 #self.formatter.text('...')
diff --git a/src/gallium/tools/trace/parse.py b/src/gallium/tools/trace/parse.py
index b08d368..bc46bb8 100755
--- a/src/gallium/tools/trace/parse.py
+++ b/src/gallium/tools/trace/parse.py
@@ -35,7 +35,7 @@ import optparse
 from model import *
 
 
-ELEMENT_START, ELEMENT_END, CHARACTER_DATA, EOF = range(4)
+ELEMENT_START, ELEMENT_END, CHARACTER_DATA, EOF = list(range(4))
 
 
 class XmlToken:
@@ -113,7 +113,7 @@ class XmlTokenizer:
             data = data.rstrip('\0')
             try:
                 self.parser.Parse(data, self.final)
-            except xml.parsers.expat.ExpatError, e:
+            except xml.parsers.expat.ExpatError as e:
                 #if e.code == xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS:
                 if e.code == 3:
                     pass
diff --git a/src/glsl/builtins/tools/generate_builtins.py b/src/glsl/builtins/tools/generate_builtins.py
index 17d528c..6a71e41 100755
--- a/src/glsl/builtins/tools/generate_builtins.py
+++ b/src/glsl/builtins/tools/generate_builtins.py
@@ -17,7 +17,7 @@ builtins_dir = path.join(path.dirname(path.abspath(__file__)), "..")
 
 # Get the path to the standalone GLSL compiler
 if len(argv) != 2:
-    print "Usage:", argv[0], "<path to compiler>"
+    print("Usage:", argv[0], "<path to compiler>")
     sys.exit(1)
 
 compiler = argv[1]
@@ -53,13 +53,13 @@ def stringify(s):
 
 def write_function_definitions():
     fs = get_builtin_definitions()
-    for k, v in sorted(fs.iteritems()):
-        print 'static const char builtin_' + k + '[] ='
-        print stringify(v), ';'
+    for k, v in sorted(fs.items()):
+        print('static const char builtin_' + k + '[] =')
+        print(stringify(v), ';')
 
 def run_compiler(args):
     command = [compiler, '--dump-lir'] + args
-    p = Popen(command, 1, stdout=PIPE, shell=False)
+    p = Popen(command, 1, stdout=PIPE, shell=False, encoding='utf-8')
     output = p.communicate()[0]
 
     # Clean up output a bit by killing whitespace before a closing paren.
@@ -75,15 +75,15 @@ def write_profile(filename, profile):
     (proto_ir, returncode) = run_compiler([filename])
 
     if returncode != 0:
-        print '#error builtins profile', profile, 'failed to compile'
+        print('#error builtins profile', profile, 'failed to compile')
         return
 
     # Kill any global variable declarations.  We don't want them.
     kill_globals = re.compile(r'^\(declare.*\n', re.MULTILINE)
     proto_ir = kill_globals.sub('', proto_ir)
 
-    print 'static const char prototypes_for_' + profile + '[] ='
-    print stringify(proto_ir), ';'
+    print('static const char prototypes_for_' + profile + '[] =')
+    print(stringify(proto_ir), ';')
 
     # Print a table of all the functions (not signatures) referenced.
     # This is done so we can avoid bothering with a hash table in the C++ code.
@@ -92,10 +92,10 @@ def write_profile(filename, profile):
     for func in re.finditer(r'\(function (.+)\n', proto_ir):
         function_names.add(func.group(1))
 
-    print 'static const char *functions_for_' + profile + ' [] = {'
+    print('static const char *functions_for_' + profile + ' [] = {')
     for func in sorted(function_names):
-        print '   builtin_' + func + ','
-    print '};'
+        print('   builtin_' + func + ',')
+    print('};')
 
 def write_profiles():
     profiles = get_profile_list()
@@ -109,7 +109,7 @@ def get_profile_list():
     return profiles
 
 if __name__ == "__main__":
-    print """/* DO NOT MODIFY - automatically generated by generate_builtins.py */
+    print("""/* DO NOT MODIFY - automatically generated by generate_builtins.py */
 /*
  * Copyright © 2010 Intel Corporation
  *
@@ -186,16 +186,16 @@ read_builtins(GLenum target, const char *protos, const char **functions, unsigne
 
    return sh;
 }
-"""
+""")
 
     write_function_definitions()
     write_profiles()
 
     profiles = get_profile_list()
 
-    print 'static gl_shader *builtin_profiles[%d];' % len(profiles)
+    print('static gl_shader *builtin_profiles[%d];' % len(profiles))
 
-    print """
+    print("""
 void *builtin_mem_ctx = NULL;
 
 void
@@ -234,7 +234,7 @@ _mesa_glsl_initialize_functions(struct _mesa_glsl_parse_state *state)
    }
 
    state->num_builtins_to_link = 0;
-"""
+""")
 
     i = 0
     for (filename, profile) in profiles:
@@ -249,13 +249,13 @@ _mesa_glsl_initialize_functions(struct _mesa_glsl_parse_state *state)
         else: # an extension name
             check += 'state->' + version + '_enable'
 
-        print '   if (' + check + ') {'
-        print '      _mesa_read_profile(state, %d,' % i
-        print '                         prototypes_for_' + profile + ','
-        print '                         functions_for_' + profile + ','
-        print '                         Elements(functions_for_' + profile + '));'
-        print '   }'
-        print
+        print('   if (' + check + ') {')
+        print('      _mesa_read_profile(state, %d,' % i)
+        print('                         prototypes_for_' + profile + ',')
+        print('                         functions_for_' + profile + ',')
+        print('                         Elements(functions_for_' + profile + '));')
+        print('   }')
+        print()
         i = i + 1
-    print '}'
+    print('}')
 
diff --git a/src/glsl/builtins/tools/generate_matrixCompMultGLSL.py b/src/glsl/builtins/tools/generate_matrixCompMultGLSL.py
index 391ad11..3a29a83 100755
--- a/src/glsl/builtins/tools/generate_matrixCompMultGLSL.py
+++ b/src/glsl/builtins/tools/generate_matrixCompMultGLSL.py
@@ -6,23 +6,23 @@ def gen_matrix(x, y = 0):
     type = "mat" + str(x)
     if x != y:
         type = type + "x" + str(y)
-    print type + " matrixCompMult(" + type + " x, " + type + " y)\n{"
-    print "    " + type + " z;"
+    print(type + " matrixCompMult(" + type + " x, " + type + " y)\n{")
+    print("    " + type + " z;")
 
     for i in range(x):
-        print "    z[" + str(i) + "] = x[" + str(i) + "] * y[" + str(i) + "];"
-    print "    return z;\n}"
+        print("    z[" + str(i) + "] = x[" + str(i) + "] * y[" + str(i) + "];")
+    print("    return z;\n}")
 
-print "#version 120"
+print("#version 120")
 # 1.10
 gen_matrix(2)
 gen_matrix(3)
 gen_matrix(4)
 
 # 1.20
-gen_matrix(2,3) # mat2x3 means 2 columns, 3 rows
-gen_matrix(3,2)
-gen_matrix(2,4)
-gen_matrix(4,2)
-gen_matrix(3,4)
-gen_matrix(4,3)
+gen_matrix(2, 3) # mat2x3 means 2 columns, 3 rows
+gen_matrix(3, 2)
+gen_matrix(2, 4)
+gen_matrix(4, 2)
+gen_matrix(3, 4)
+gen_matrix(4, 3)
diff --git a/src/glsl/builtins/tools/generate_outerProductGLSL.py b/src/glsl/builtins/tools/generate_outerProductGLSL.py
index c561cc3..a1aced5 100755
--- a/src/glsl/builtins/tools/generate_outerProductGLSL.py
+++ b/src/glsl/builtins/tools/generate_outerProductGLSL.py
@@ -4,20 +4,20 @@ def gen(x, y):
     type = "mat" + str(x)
     if x != y:
         type = type + "x" + str(y)
-    print type + " outerProduct(vec" + str(y) + " u, vec" + str(x) + " v)\n{"
-    print "    " + type + " m;"
+    print(type + " outerProduct(vec" + str(y) + " u, vec" + str(x) + " v)\n{")
+    print("    " + type + " m;")
 
     for i in range(x):
-        print "    m[" + str(i) + "] = u * v[" + str(i) + "];"
-    print "    return m;\n}"
+        print("    m[" + str(i) + "] = u * v[" + str(i) + "];")
+    print("    return m;\n}")
 
-print "#version 120"
-gen(2,2)
-gen(2,3) # mat2x3 means 2 columns, 3 rows
-gen(2,4)
-gen(3,2)
-gen(3,3)
-gen(3,4)
-gen(4,2)
-gen(4,3)
-gen(4,4)
+print("#version 120")
+gen(2, 2)
+gen(2, 3) # mat2x3 means 2 columns, 3 rows
+gen(2, 4)
+gen(3, 2)
+gen(3, 3)
+gen(3, 4)
+gen(4, 2)
+gen(4, 3)
+gen(4, 4)
diff --git a/src/glsl/builtins/tools/generate_transposeGLSL.py b/src/glsl/builtins/tools/generate_transposeGLSL.py
index 8f669ce..0e33c52 100755
--- a/src/glsl/builtins/tools/generate_transposeGLSL.py
+++ b/src/glsl/builtins/tools/generate_transposeGLSL.py
@@ -6,23 +6,23 @@ def gen(x, y):
     if x != y:
         origtype = origtype + "x" + str(y)
         trantype = trantype + "x" + str(x)
-    print trantype + " transpose(" + origtype + " m)\n{"
-    print "    " + trantype + " t;"
+    print(trantype + " transpose(" + origtype + " m)\n{")
+    print("    " + trantype + " t;")
 
     # The obvious implementation of transpose
     for i in range(x):
         for j in range(y):
-            print "    t[" + str(j) + "][" + str(i) + "] =",
-            print "m[" + str(i) + "][" + str(j) + "];"
-    print "    return t;\n}"
+            print("    t[" + str(j) + "][" + str(i) + "] =", end=' ')
+            print("m[" + str(i) + "][" + str(j) + "];")
+    print("    return t;\n}")
 
-print "#version 120"
-gen(2,2)
-gen(2,3) # mat2x3 means 2 columns, 3 rows
-gen(2,4)
-gen(3,2)
-gen(3,3)
-gen(3,4)
-gen(4,2)
-gen(4,3)
-gen(4,4)
+print("#version 120")
+gen(2, 2)
+gen(2, 3) # mat2x3 means 2 columns, 3 rows
+gen(2, 4)
+gen(3, 2)
+gen(3, 3)
+gen(3, 4)
+gen(4, 2)
+gen(4, 3)
+gen(4, 4)
diff --git a/src/glsl/builtins/tools/texture_builtins.py b/src/glsl/builtins/tools/texture_builtins.py
index a4054ca..ce2b2e7 100755
--- a/src/glsl/builtins/tools/texture_builtins.py
+++ b/src/glsl/builtins/tools/texture_builtins.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 
 import sys
-import StringIO
+import io
 
 # Bitfield constants for the 'variant' argument to generate_sigs
 Proj = 1
@@ -55,60 +55,60 @@ def generate_sigs(g, tex_inst, sampler_type, variant = 0, unused_fields = 0):
         return_type = g + "vec4"
 
     # Print parameters
-    print "   (signature", return_type
-    print "     (parameters"
-    print "       (declare (in) " + g + "sampler" + sampler_type + " sampler)"
-    print "       (declare (in) " + vec_type("i" if tex_inst == "txf" else "", coord_dim + extra_dim) + " P)",
+    print("   (signature", return_type)
+    print("     (parameters")
+    print("       (declare (in) " + g + "sampler" + sampler_type + " sampler)")
+    print("       (declare (in) " + vec_type("i" if tex_inst == "txf" else "", coord_dim + extra_dim) + " P)", end=' ')
     if tex_inst == "txl":
-        print "\n       (declare (in) float lod)",
+        print("\n       (declare (in) float lod)", end=' ')
     elif tex_inst == "txf":
-        print "\n       (declare (in) int lod)",
+        print("\n       (declare (in) int lod)", end=' ')
     elif tex_inst == "txd":
         grad_type = vec_type("", coord_dim)
-        print "\n       (declare (in) " + grad_type + " dPdx)",
-        print "\n       (declare (in) " + grad_type + " dPdy)",
+        print("\n       (declare (in) " + grad_type + " dPdx)", end=' ')
+        print("\n       (declare (in) " + grad_type + " dPdy)", end=' ')
 
     if variant & Offset:
-        print "\n       (declare (const_in) " + vec_type("i", offset_dim) + " offset)",
+        print("\n       (declare (const_in) " + vec_type("i", offset_dim) + " offset)", end=' ')
     if tex_inst == "txb":
-        print "\n       (declare (in) float bias)",
+        print("\n       (declare (in) float bias)", end=' ')
 
-    print ")\n     ((return (" + tex_inst, return_type, "(var_ref sampler)",
+    print(")\n     ((return (" + tex_inst, return_type, "(var_ref sampler)", end=' ')
 
     # Coordinate
     if extra_dim > 0:
-        print "(swiz " + "xyzw"[:coord_dim] + " (var_ref P))",
+        print("(swiz " + "xyzw"[:coord_dim] + " (var_ref P))", end=' ')
     else:
-        print "(var_ref P)",
+        print("(var_ref P)", end=' ')
 
     if variant & Offset:
-        print "(var_ref offset)",
+        print("(var_ref offset)", end=' ')
     else:
-        print "0",
+        print("0", end=' ')
 
     if tex_inst != "txf":
         # Projective divisor
         if variant & Proj:
-            print "(swiz " + "xyzw"[coord_dim + extra_dim-1] + " (var_ref P))",
+            print("(swiz " + "xyzw"[coord_dim + extra_dim-1] + " (var_ref P))", end=' ')
         else:
-            print "1",
+            print("1", end=' ')
 
         # Shadow comparitor
         if sampler_type == "2DArrayShadow": # a special case:
-            print "(swiz w (var_ref P))",   # ...array layer is z; shadow is w
+            print("(swiz w (var_ref P))", end=' ')   # ...array layer is z; shadow is w
         elif sampler_type.endswith("Shadow"):
-            print "(swiz z (var_ref P))",
+            print("(swiz z (var_ref P))", end=' ')
         else:
-            print "()",
+            print("()", end=' ')
 
     # Bias/explicit LOD/gradient:
     if tex_inst == "txb":
-        print "(var_ref bias)",
+        print("(var_ref bias)", end=' ')
     elif tex_inst == "txl" or tex_inst == "txf":
-        print "(var_ref lod)",
+        print("(var_ref lod)", end=' ')
     elif tex_inst == "txd":
-        print "((var_ref dPdx) (var_ref dPdy))",
-    print "))))\n"
+        print("((var_ref dPdx) (var_ref dPdy))", end=' ')
+    print("))))\n")
 
 def generate_fiu_sigs(tex_inst, sampler_type, variant = 0, unused_fields = 0):
     generate_sigs("",  tex_inst, sampler_type, variant, unused_fields)
@@ -116,11 +116,11 @@ def generate_fiu_sigs(tex_inst, sampler_type, variant = 0, unused_fields = 0):
     generate_sigs("u", tex_inst, sampler_type, variant, unused_fields)
 
 def start_function(name):
-    sys.stdout = StringIO.StringIO()
-    print "((function " + name
+    sys.stdout = io.StringIO()
+    print("((function " + name)
 
 def end_function(fs, name):
-    print "))"
+    print("))")
     fs[name] = sys.stdout.getvalue();
     sys.stdout.close()
 
@@ -546,5 +546,5 @@ def generate_texture_functions(fs):
 if __name__ == "__main__":
     fs = {}
     generate_texture_functions(fs);
-    for k, v in fs.iteritems():
-        print v
+    for k, v in fs.items():
+        print(v)
diff --git a/src/mapi/glapi/gen-es/gl_compare.py b/src/mapi/glapi/gen-es/gl_compare.py
index 6b5e43b..0309cc9 100644
--- a/src/mapi/glapi/gen-es/gl_compare.py
+++ b/src/mapi/glapi/gen-es/gl_compare.py
@@ -88,7 +88,7 @@ class ApiSet(object):
                         % (f1.name, l1, l2))
 
         pad = 0
-        for i in xrange(len(f1.parameters)):
+        for i in range(len(f1.parameters)):
             p1 = f1.parameters[i]
             p2 = f2.parameters[i + pad]
 
@@ -116,7 +116,7 @@ class ApiSet(object):
 
         if "enum" in self.elts:
             union.enums_by_name = other.enums_by_name.copy()
-            for key, val in self.api.enums_by_name.iteritems():
+            for key, val in self.api.enums_by_name.items():
                 if key not in union.enums_by_name:
                     union.enums_by_name[key] = val
                 else:
@@ -124,7 +124,7 @@ class ApiSet(object):
 
         if "type" in self.elts:
             union.types_by_name = other.types_by_name.copy()
-            for key, val in self.api.types_by_name.iteritems():
+            for key, val in self.api.types_by_name.items():
                 if key not in union.types_by_name:
                     union.types_by_name[key] = val
                 else:
@@ -132,7 +132,7 @@ class ApiSet(object):
 
         if "function" in self.elts:
             union.functions_by_name = other.functions_by_name.copy()
-            for key, val in self.api.functions_by_name.iteritems():
+            for key, val in self.api.functions_by_name.items():
                 if key not in union.functions_by_name:
                     union.functions_by_name[key] = val
                 else:
@@ -144,19 +144,19 @@ class ApiSet(object):
         intersection = gl_XML.gl_api(None)
 
         if "enum" in self.elts:
-            for key, val in self.api.enums_by_name.iteritems():
+            for key, val in self.api.enums_by_name.items():
                 if key in other.enums_by_name:
                     self._check_enum(val, other.enums_by_name[key])
                     intersection.enums_by_name[key] = val
 
         if "type" in self.elts:
-            for key, val in self.api.types_by_name.iteritems():
+            for key, val in self.api.types_by_name.items():
                 if key in other.types_by_name:
                     self._check_type(val, other.types_by_name[key])
                     intersection.types_by_name[key] = val
 
         if "function" in self.elts:
-            for key, val in self.api.functions_by_name.iteritems():
+            for key, val in self.api.functions_by_name.items():
                 if key in other.functions_by_name:
                     self._check_function(val, other.functions_by_name[key])
                     intersection.functions_by_name[key] = val
@@ -167,21 +167,21 @@ class ApiSet(object):
         difference = gl_XML.gl_api(None)
 
         if "enum" in self.elts:
-            for key, val in self.api.enums_by_name.iteritems():
+            for key, val in self.api.enums_by_name.items():
                 if key not in other.enums_by_name:
                     difference.enums_by_name[key] = val
                 else:
                     self._check_enum(val, other.enums_by_name[key])
 
         if "type" in self.elts:
-            for key, val in self.api.types_by_name.iteritems():
+            for key, val in self.api.types_by_name.items():
                 if key not in other.types_by_name:
                     difference.types_by_name[key] = val
                 else:
                     self._check_type(val, other.types_by_name[key])
 
         if "function" in self.elts:
-            for key, val in self.api.functions_by_name.iteritems():
+            for key, val in self.api.functions_by_name.items():
                 if key not in other.functions_by_name:
                     difference.functions_by_name[key] = val
                 else:
@@ -226,20 +226,20 @@ def output_enum(e, indent=0):
 
     # no child
     if not e.functions:
-        print '%s<enum %s/>' % (spaces(indent), attrs)
+        print('%s<enum %s/>' % (spaces(indent), attrs))
         return
 
-    print '%s<enum %s>' % (spaces(indent), attrs)
-    for key, val in e.functions.iteritems():
+    print('%s<enum %s>' % (spaces(indent), attrs))
+    for key, val in e.functions.items():
         attrs = 'name="%s"' % key
         if val[0] != e.default_count:
             attrs += ' count="%d"' % val[0]
         if not val[1]:
             attrs += ' mode="get"'
 
-        print '%s<size %s/>' % (spaces(indent * 2), attrs)
+        print('%s<size %s/>' % (spaces(indent * 2), attrs))
 
-    print '%s</enum>' % spaces(indent)
+    print('%s</enum>' % spaces(indent))
 
 def output_type(t, indent=0):
     tab = spaces(16, t.name)
@@ -249,7 +249,7 @@ def output_type(t, indent=0):
         attrs += ' unsigned="true"'
     elif ctype.find("signed") == -1:
         attrs += ' float="true"'
-    print '%s<type %s/>' % (spaces(indent), attrs)
+    print('%s<type %s/>' % (spaces(indent), attrs))
 
 def output_function(f, indent=0):
     attrs = 'name="%s"' % f.name
@@ -258,38 +258,38 @@ def output_function(f, indent=0):
             attrs += ' offset="assign"'
         else:
             attrs += ' offset="%d"' % f.offset
-    print '%s<function %s>' % (spaces(indent), attrs)
+    print('%s<function %s>' % (spaces(indent), attrs))
 
     for p in f.parameters:
         attrs = 'name="%s" type="%s"' \
                 % (p.name, p.type_expr.original_string)
-        print '%s<param %s/>' % (spaces(indent * 2), attrs)
+        print('%s<param %s/>' % (spaces(indent * 2), attrs))
     if f.return_type != "void":
         attrs = 'type="%s"' % f.return_type
-        print '%s<return %s/>' % (spaces(indent * 2), attrs)
+        print('%s<return %s/>' % (spaces(indent * 2), attrs))
 
-    print '%s</function>' % spaces(indent)
+    print('%s</function>' % spaces(indent))
 
 def output_category(api, indent=0):
-    enums = api.enums_by_name.values()
+    enums = list(api.enums_by_name.values())
     enums.sort(cmp_enum)
-    types = api.types_by_name.values()
+    types = list(api.types_by_name.values())
     types.sort(cmp_type)
-    functions = api.functions_by_name.values()
+    functions = list(api.functions_by_name.values())
     functions.sort(cmp_function)
 
     for e in enums:
         output_enum(e, indent)
     if enums and types:
-        print
+        print()
     for t in types:
         output_type(t, indent)
     if enums or types:
-        print
+        print()
     for f in functions:
         output_function(f, indent)
         if f != functions[-1]:
-            print
+            print()
 
 def is_api_empty(api):
     return bool(not api.enums_by_name and
@@ -297,9 +297,9 @@ def is_api_empty(api):
                 not api.functions_by_name)
 
 def show_usage(ops):
-    print "Usage: %s [-k elts] <%s> <file1> <file2>" % (sys.argv[0], "|".join(ops))
-    print "    -k elts   A comma separated string of types of elements to"
-    print "              skip.  Possible types are enum, type, and function."
+    print("Usage: %s [-k elts] <%s> <file1> <file2>" % (sys.argv[0], "|".join(ops)))
+    print("    -k elts   A comma separated string of types of elements to")
+    print("              skip.  Possible types are enum, type, and function.")
     sys.exit(1)
 
 def main():
@@ -308,7 +308,7 @@ def main():
 
     try:
         options, args = getopt.getopt(sys.argv[1:], "k:")
-    except Exception, e:
+    except Exception as e:
         show_usage(ops)
 
     if len(args) != 3:
@@ -339,16 +339,16 @@ def main():
         cat_name = "%s_of_%s_and_%s" \
                 % (op, os.path.basename(file1), os.path.basename(file2))
 
-        print '<?xml version="1.0"?>'
-        print '<!DOCTYPE OpenGLAPI SYSTEM "%s/gl_API.dtd">' % GLAPI
-        print
-        print '<OpenGLAPI>'
-        print
-        print '<category name="%s">' % (cat_name)
+        print('<?xml version="1.0"?>')
+        print('<!DOCTYPE OpenGLAPI SYSTEM "%s/gl_API.dtd">' % GLAPI)
+        print()
+        print('<OpenGLAPI>')
+        print()
+        print('<category name="%s">' % (cat_name))
         output_category(result, 4)
-        print '</category>'
-        print
-        print '</OpenGLAPI>'
+        print('</category>')
+        print()
+        print('</OpenGLAPI>')
 
 if __name__ == "__main__":
     main()
diff --git a/src/mapi/glapi/gen-es/gl_parse_header.py b/src/mapi/glapi/gen-es/gl_parse_header.py
index 5382eba..ca427a8 100644
--- a/src/mapi/glapi/gen-es/gl_parse_header.py
+++ b/src/mapi/glapi/gen-es/gl_parse_header.py
@@ -65,7 +65,7 @@ class HeaderParser(object):
         tmp = [s for s in tmp if s and s != " "]
 
         pretty = ""
-        for i in xrange(len(tmp)):
+        for i in range(len(tmp)):
             # add missing GL prefix
             if (fix and tmp[i] != "const" and tmp[i] != "*" and
                 not tmp[i].startswith("GL")):
@@ -106,7 +106,7 @@ class HeaderParser(object):
         m = self.DEFINE.search(line)
         if not m:
             if self.verbose and line.find("#define") >= 0:
-                print "ignore %s" % (line)
+                print("ignore %s" % (line))
             return None
 
         key = m.group("key").strip()
@@ -116,7 +116,7 @@ class HeaderParser(object):
         if ((not (key.startswith("GL_") and key.isupper())) or
             (self.ignore_enum.match(key) and val == "1")):
             if self.verbose:
-                print "ignore enum %s" % (key)
+                print("ignore enum %s" % (key))
             return None
 
         return (key, val)
@@ -126,14 +126,14 @@ class HeaderParser(object):
         m = self.TYPEDEF.search(line)
         if not m:
             if self.verbose and line.find("typedef") >= 0:
-                print "ignore %s" % (line)
+                print("ignore %s" % (line))
             return None
 
         f = m.group("from").strip()
         t = m.group("to").strip()
         if not t.startswith("GL"):
             if self.verbose:
-                print "ignore type %s" % (t)
+                print("ignore type %s" % (t))
             return None
         attrs = self._get_ctype_attrs(f)
 
@@ -144,7 +144,7 @@ class HeaderParser(object):
         m = self.GLAPI.search(line)
         if not m:
             if self.verbose and line.find("APIENTRY") >= 0:
-                print "ignore %s" % (line)
+                print("ignore %s" % (line))
             return None
 
         rettype = m.group("return")
@@ -212,8 +212,8 @@ class HeaderParser(object):
             fp = open(header, "rb")
             lines = fp.readlines()
             fp.close()
-        except IOError, e:
-            print "failed to read %s: %s" % (header, e)
+        except IOError as e:
+            print("failed to read %s: %s" % (header, e))
         return lines
 
     def _cmp_enum(self, enum1, enum2):
@@ -272,7 +272,7 @@ class HeaderParser(object):
         """Post-process a header dict and return an ordered list."""
         hlist = []
         largest = 0
-        for key, cat in hdict.iteritems():
+        for key, cat in hdict.items():
             size = len(cat["enums"]) + len(cat["types"]) + len(cat["functions"])
             # ignore empty category
             if not size:
@@ -281,13 +281,13 @@ class HeaderParser(object):
             cat["enums"].sort(self._cmp_enum)
             # remove duplicates
             dup = []
-            for i in xrange(1, len(cat["enums"])):
+            for i in range(1, len(cat["enums"])):
                 if cat["enums"][i] == cat["enums"][i - 1]:
                     dup.insert(0, i)
             for i in dup:
                 e = cat["enums"].pop(i)
                 if self.verbose:
-                    print "remove duplicate enum %s" % e[0]
+                    print("remove duplicate enum %s" % e[0])
 
             cat["types"].sort(self._cmp_type)
             cat["functions"].sort(self._cmp_function)
@@ -305,7 +305,7 @@ class HeaderParser(object):
         self._reset()
 
         if self.verbose:
-            print "Parsing %s" % (header)
+            print("Parsing %s" % (header))
 
         hdict = {}
         lines = self._read_header(header)
@@ -347,7 +347,7 @@ class HeaderParser(object):
 
         if self.need_char:
             if self.verbose:
-                print "define GLchar"
+                print("define GLchar")
             elem = self._parse_typedef("typedef char GLchar;")
             cat["types"].append(elem)
         return self._postprocess_dict(hdict)
@@ -361,10 +361,10 @@ def spaces(n, str=""):
 def output_xml(name, hlist):
     """Output a parsed header in OpenGLAPI XML."""
 
-    for i in xrange(len(hlist)):
+    for i in range(len(hlist)):
         cat_name, cat = hlist[i]
 
-        print '<category name="%s">' % (cat_name)
+        print('<category name="%s">' % (cat_name))
         indent = 4
 
         for enum in cat["enums"]:
@@ -372,10 +372,10 @@ def output_xml(name, hlist):
             value = enum[1]
             tab = spaces(41, name)
             attrs = 'name="%s"%svalue="%s"' % (name, tab, value)
-            print '%s<enum %s/>' % (spaces(indent), attrs)
+            print('%s<enum %s/>' % (spaces(indent), attrs))
 
         if cat["enums"] and cat["types"]:
-            print
+            print()
 
         for type in cat["types"]:
             ctype = type[0]
@@ -388,37 +388,37 @@ def output_xml(name, hlist):
             elif not is_signed:
                 attrs += ' unsigned="true"'
 
-            print '%s<type %s/>' % (spaces(indent), attrs)
+            print('%s<type %s/>' % (spaces(indent), attrs))
 
         for func in cat["functions"]:
-            print
+            print()
             ret = func[0]
             name = func[1][2:]
             params = func[2]
 
             attrs = 'name="%s" offset="assign"' % name
-            print '%s<function %s>' % (spaces(indent), attrs)
+            print('%s<function %s>' % (spaces(indent), attrs))
 
             for param in params:
                 attrs = 'name="%s" type="%s"' % (param[1], param[0])
-                print '%s<param %s/>' % (spaces(indent * 2), attrs)
+                print('%s<param %s/>' % (spaces(indent * 2), attrs))
             if ret:
                 attrs = 'type="%s"' % ret
-                print '%s<return %s/>' % (spaces(indent * 2), attrs)
+                print('%s<return %s/>' % (spaces(indent * 2), attrs))
 
-            print '%s</function>' % spaces(indent)
+            print('%s</function>' % spaces(indent))
 
-        print '</category>'
-        print
+        print('</category>')
+        print()
 
 def show_usage():
-    print "Usage: %s [-v] <header> ..." % sys.argv[0]
+    print("Usage: %s [-v] <header> ..." % sys.argv[0])
     sys.exit(1)
 
 def main():
     try:
         args, headers = getopt.getopt(sys.argv[1:], "v")
-    except Exception, e:
+    except Exception as e:
         show_usage()
     if not headers:
         show_usage()
@@ -435,16 +435,16 @@ def main():
         hlist = parser.parse(h)
 
         if need_xml_header:
-            print '<?xml version="1.0"?>'
-            print '<!DOCTYPE OpenGLAPI SYSTEM "%s/gl_API.dtd">' % GLAPI
+            print('<?xml version="1.0"?>')
+            print('<!DOCTYPE OpenGLAPI SYSTEM "%s/gl_API.dtd">' % GLAPI)
             need_xml_header = False
 
-        print
-        print '<!-- %s -->' % (h)
-        print '<OpenGLAPI>'
-        print
+        print()
+        print('<!-- %s -->' % (h))
+        print('<OpenGLAPI>')
+        print()
         output_xml(h, hlist)
-        print '</OpenGLAPI>'
+        print('</OpenGLAPI>')
 
 if __name__ == '__main__':
     main()
diff --git a/src/mapi/glapi/gen/extension_helper.py b/src/mapi/glapi/gen/extension_helper.py
index 2c83b4e..d30039a 100644
--- a/src/mapi/glapi/gen/extension_helper.py
+++ b/src/mapi/glapi/gen/extension_helper.py
@@ -150,9 +150,9 @@ class PrintGlExtensionGlue(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print '#include "utils.h"'
-		print '#include "main/dispatch.h"'
-		print ''
+		print('#include "utils.h"')
+		print('#include "main/dispatch.h"')
+		print('')
 		return
 
 
@@ -161,16 +161,16 @@ class PrintGlExtensionGlue(gl_XML.gl_print_base):
 
 		category_list = {}
 
-		print '#ifndef NULL'
-		print '# define NULL 0'
-		print '#endif'
-		print ''
+		print('#ifndef NULL')
+		print('# define NULL 0')
+		print('#endif')
+		print('')
 
 		for f in api.functionIterateAll():
 			condition = condition_for_function(f, abi, 0)
 			if len(condition):
-				print '#if %s' % (string.join(condition, " || "))
-				print 'static const char %s_names[] =' % (f.name)
+				print('#if %s' % (string.join(condition, " || ")))
+				print('static const char %s_names[] =' % (f.name))
 
 				parameter_signature = ''
 				for p in f.parameterIterator():
@@ -189,29 +189,28 @@ class PrintGlExtensionGlue(gl_XML.gl_print_base):
 					else:
 						parameter_signature += 'd'
 
-				print '    "%s\\0" /* Parameter signature */' % (parameter_signature)
+				print('    "%s\\0" /* Parameter signature */' % (parameter_signature))
 
 				for n in f.entry_points:
-					print '    "gl%s\\0"' % (n)
+					print('    "gl%s\\0"' % (n))
 
 					[category, num] = api.get_category_for_name( n )
 					if category not in abi:
 						c = gl_XML.real_category_name(category)
-						if not category_list.has_key(c):
+						if c not in category_list:
 							category_list[ c ] = []
 
 						category_list[ c ].append( f )
 
-				print '    "";'
-				print '#endif'
-				print ''
+				print('    "";')
+				print('#endif')
+				print('')
 
-		keys = category_list.keys()
-		keys.sort()
+		keys = sorted(category_list.keys())
 
 		for category in keys:
-			print '#if defined(need_%s)' % (category)
-			print 'static const struct dri_extension_function %s_functions[] = {' % (category)
+			print('#if defined(need_%s)' % (category))
+			print('static const struct dri_extension_function %s_functions[] = {' % (category))
 			
 			for f in category_list[ category ]:
 				# A function either has an offset that is
@@ -224,13 +223,13 @@ class PrintGlExtensionGlue(gl_XML.gl_print_base):
 					index_name = "%s_remap_index" % (f.name)
 					offset = -1
 
-				print '    { %s_names, %s, %d },' % (f.name, index_name, offset)
+				print('    { %s_names, %s, %d },' % (f.name, index_name, offset))
 
 
-			print '    { NULL, 0, 0 }'
-			print '};'
-			print '#endif'
-			print ''
+			print('    { NULL, 0, 0 }')
+			print('};')
+			print('#endif')
+			print('')
 		
 		return
 
@@ -258,42 +257,42 @@ class PrintInitDispatch(gl_XML.gl_print_base):
 
 			if condition_string != last_condition_string:
 				if last_condition_string:
-					print '#endif /* %s */' % (last_condition_string)
+					print('#endif /* %s */' % (last_condition_string))
 
 				if condition_string:
-					print '#if %s' % (condition_string)
+					print('#if %s' % (condition_string))
 				
 			if vtxfmt_only:
-				print '   disp->%s = vfmt->%s;' % (f.name, f.name)
+				print('   disp->%s = vfmt->%s;' % (f.name, f.name))
 			else:
-				print '   disp->%s = _mesa_%s;' % (f.name, f.name)
+				print('   disp->%s = _mesa_%s;' % (f.name, f.name))
 
 			last_condition_string = condition_string
 
 		if last_condition_string:
-			print '#endif /* %s */' % (last_condition_string)
+			print('#endif /* %s */' % (last_condition_string))
 		
 
 
 	def printBody(self, api):
 		abi = [ "1.0", "1.1", "1.2", "GL_ARB_multitexture" ]
 		
-		print 'void driver_init_exec_table(struct _glapi_table *disp)'
-		print '{'
+		print('void driver_init_exec_table(struct _glapi_table *disp)')
+		print('{')
 		self.do_function_body(api, abi, 0)
-		print '}'
-		print ''
-		print 'void driver_install_vtxfmt(struct _glapi_table *disp, const GLvertexformat *vfmt)'
-		print '{'
+		print('}')
+		print('')
+		print('void driver_install_vtxfmt(struct _glapi_table *disp, const GLvertexformat *vfmt)')
+		print('{')
 		self.do_function_body(api, abi, 1)
-		print '}'
+		print('}')
 
 		return
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0]
-	print "    -m output_mode   Output mode can be one of 'extensions' or 'exec_init'."
+	print("Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0])
+	print("    -m output_mode   Output mode can be one of 'extensions' or 'exec_init'.")
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -301,11 +300,11 @@ if __name__ == '__main__':
     
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	mode = "extensions"
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		if arg == '-m':
diff --git a/src/mapi/glapi/gen/glX_XML.py b/src/mapi/glapi/gen/glX_XML.py
index 4c2e0f9..7e80ab9 100644
--- a/src/mapi/glapi/gen/glX_XML.py
+++ b/src/mapi/glapi/gen/glX_XML.py
@@ -67,7 +67,7 @@ class glx_enum(gl_XML.gl_enum):
 				else:
 					mode = 1
 
-				if not self.functions.has_key(n):
+				if n not in self.functions:
 					self.functions[ n ] = [c, mode]
 
 			child = child.next
@@ -478,7 +478,7 @@ class glx_function(gl_XML.gl_function):
 	def needs_reply(self):
 		try:
 			x = self._needs_reply
-		except Exception, e:
+		except Exception as e:
 			x = 0
 			if self.return_type != 'void':
 				x = 1
diff --git a/src/mapi/glapi/gen/glX_doc.py b/src/mapi/glapi/gen/glX_doc.py
index e9fbbe6..6349cb4 100644
--- a/src/mapi/glapi/gen/glX_doc.py
+++ b/src/mapi/glapi/gen/glX_doc.py
@@ -52,7 +52,7 @@ class glx_doc_parameter(gl_XML.gl_parameter):
 			list_of = "LISTof"
 
 		t_name = self.get_base_type_string()
-		if not type_dict.has_key( t_name ):
+		if t_name not in type_dict:
 			type_name = "CARD8"
 		else:
 			type_name = type_dict[ t_name ]
@@ -107,7 +107,7 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 			[s, pad] = p.packet_size()
 			try: 
 				size += int(s)
-			except Exception,e:
+			except Exception as e:
 				size_str += "%s%s" % (plus, s)
 				plus = "+"
 
@@ -128,8 +128,8 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 		else:
 			s = "%u+%s" % (size, size_str)
 
-		print '            2        %-15s rendering command length' % (s)
-		print '            2        %-4u            rendering command opcode' % (f.glx_rop)
+		print('            2        %-15s rendering command length' % (s))
+		print('            2        %-4u            rendering command opcode' % (f.glx_rop))
 		return
 
 
@@ -140,8 +140,8 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 		if f.glx_vendorpriv != 0:
 			size += 1
 
-		print '            1        CARD8           opcode (X assigned)'
-		print '            1        %-4u            GLX opcode (%s)' % (f.opcode_real_value(), f.opcode_real_name())
+		print('            1        CARD8           opcode (X assigned)')
+		print('            1        %-4u            GLX opcode (%s)' % (f.opcode_real_value(), f.opcode_real_name()))
 
 		if size_str == "":
 			s = "%u" % (size)
@@ -150,28 +150,28 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 		else:
 			s = "%u+((%s)/4)" % (size, size_str)
 
-		print '            2        %-15s request length' % (s)
+		print('            2        %-15s request length' % (s))
 
 		if f.glx_vendorpriv != 0:
-			print '            4        %-4u            vendor specific opcode' % (f.opcode_value())
+			print('            4        %-4u            vendor specific opcode' % (f.opcode_value()))
 			
-		print '            4        GLX_CONTEXT_TAG context tag'
+		print('            4        GLX_CONTEXT_TAG context tag')
 
 		return
 		
 
 	def print_reply(self, f):
-		print '          =>'
-		print '            1        1               reply'
-		print '            1                        unused'
-		print '            2        CARD16          sequence number'
+		print('          =>')
+		print('            1        1               reply')
+		print('            1                        unused')
+		print('            2        CARD16          sequence number')
 
 		if f.output == None:
-			print '            4        0               reply length'
+			print('            4        0               reply length')
 		elif f.reply_always_array:
-			print '            4        m               reply length'
+			print('            4        m               reply length')
 		else:
-			print '            4        m               reply length, m = (n == 1 ? 0 : n)'
+			print('            4        m               reply length, m = (n == 1 ? 0 : n)')
 
 
 		output = None
@@ -182,53 +182,53 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 
 		unused = 24
 		if f.return_type != 'void':
-			print '            4        %-15s return value' % (f.return_type)
+			print('            4        %-15s return value' % (f.return_type))
 			unused -= 4
 		elif output != None:
-			print '            4                        unused'
+			print('            4                        unused')
 			unused -= 4
 
 		if output != None:
-			print '            4        CARD32          n'
+			print('            4        CARD32          n')
 			unused -= 4
 
 		if output != None:
 			if not f.reply_always_array:
-				print ''
-				print '            if (n = 1) this follows:'
-				print ''
-				print '            4        CARD32          %s' % (output.name)
-				print '            %-2u                       unused' % (unused - 4)
-				print ''
-				print '            otherwise this follows:'
-				print ''
+				print('')
+				print('            if (n = 1) this follows:')
+				print('')
+				print('            4        CARD32          %s' % (output.name))
+				print('            %-2u                       unused' % (unused - 4))
+				print('')
+				print('            otherwise this follows:')
+				print('')
 
-			print '            %-2u                       unused' % (unused)
+			print('            %-2u                       unused' % (unused))
 
 			[s, pad] = output.packet_size()
-			print '            %-8s %-15s %s' % (s, output.packet_type( self.type_map ), output.name)
+			print('            %-8s %-15s %s' % (s, output.packet_type( self.type_map ), output.name))
 			if pad != None:
 				try:
 					bytes = int(s)
 					bytes = 4 - (bytes & 3)
-					print '            %-8u %-15s unused' % (bytes, "")
-				except Exception,e:
-					print '            %-8s %-15s unused, %s=pad(%s)' % (pad, "", pad, s)
+					print('            %-8u %-15s unused' % (bytes, ""))
+				except Exception as e:
+					print('            %-8s %-15s unused, %s=pad(%s)' % (pad, "", pad, s))
 		else:
-			print '            %-2u                       unused' % (unused)
+			print('            %-2u                       unused' % (unused))
 
 
 	def print_body(self, f):
 		for p in f.parameterIterateGlxSend():
 			[s, pad] = p.packet_size()
-			print '            %-8s %-15s %s' % (s, p.packet_type( self.type_map ), p.name)
+			print('            %-8s %-15s %s' % (s, p.packet_type( self.type_map ), p.name))
 			if pad != None:
 				try:
 					bytes = int(s)
 					bytes = 4 - (bytes & 3)
-					print '            %-8u %-15s unused' % (bytes, "")
-				except Exception,e:
-					print '            %-8s %-15s unused, %s=pad(%s)' % (pad, "", pad, s)
+					print('            %-8u %-15s unused' % (bytes, ""))
+				except Exception as e:
+					print('            %-8s %-15s unused, %s=pad(%s)' % (pad, "", pad, s))
 
 	def printBody(self, api):
 		self.type_map = {}
@@ -245,10 +245,10 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 
 
 			if f.glx_rop:
-				print '        %s' % (f.name)
+				print('        %s' % (f.name))
 				self.print_render_header(f)
 			elif f.glx_sop or f.glx_vendorpriv:
-				print '        %s' % (f.name)
+				print('        %s' % (f.name))
 				self.print_single_header(f)
 			else:
 				continue
@@ -258,7 +258,7 @@ class PrintGlxProtoText(gl_XML.gl_print_base):
 			if f.needs_reply():
 				self.print_reply(f)
 
-			print ''
+			print('')
 		return
 
 
@@ -267,10 +267,10 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 
diff --git a/src/mapi/glapi/gen/glX_proto_common.py b/src/mapi/glapi/gen/glX_proto_common.py
index 6f094e2..4989e4b 100644
--- a/src/mapi/glapi/gen/glX_proto_common.py
+++ b/src/mapi/glapi/gen/glX_proto_common.py
@@ -84,12 +84,12 @@ class glx_print_proto(gl_XML.gl_print_base):
 
 		compsize = self.size_call(f)
 		if compsize:
-			print '    const GLuint compsize = %s;' % (compsize)
+			print('    const GLuint compsize = %s;' % (compsize))
 
 		if bias:
-			print '    const GLuint cmdlen = %s - %u;' % (f.command_length(), bias)
+			print('    const GLuint cmdlen = %s - %u;' % (f.command_length(), bias))
 		else:
-			print '    const GLuint cmdlen = %s;' % (f.command_length())
+			print('    const GLuint cmdlen = %s;' % (f.command_length()))
 
 		#print ''
 		return compsize
diff --git a/src/mapi/glapi/gen/glX_proto_recv.py b/src/mapi/glapi/gen/glX_proto_recv.py
index 31745fc..154d917 100644
--- a/src/mapi/glapi/gen/glX_proto_recv.py
+++ b/src/mapi/glapi/gen/glX_proto_recv.py
@@ -42,8 +42,8 @@ class PrintGlxDispatch_h(gl_XML.gl_print_base):
 
 	def printRealHeader(self):
 		self.printVisibility( "HIDDEN", "hidden" )
-		print 'struct __GLXclientStateRec;'
-		print ''
+		print('struct __GLXclientStateRec;')
+		print('')
 		return
 
 
@@ -51,16 +51,16 @@ class PrintGlxDispatch_h(gl_XML.gl_print_base):
 		for func in api.functionIterateAll():
 			if not func.ignore and not func.vectorequiv:
 				if func.glx_rop:
-					print 'extern HIDDEN void __glXDisp_%s(GLbyte * pc);' % (func.name)
-					print 'extern HIDDEN void __glXDispSwap_%s(GLbyte * pc);' % (func.name)
+					print('extern HIDDEN void __glXDisp_%s(GLbyte * pc);' % (func.name))
+					print('extern HIDDEN void __glXDispSwap_%s(GLbyte * pc);' % (func.name))
 				elif func.glx_sop or func.glx_vendorpriv:
-					print 'extern HIDDEN int __glXDisp_%s(struct __GLXclientStateRec *, GLbyte *);' % (func.name)
-					print 'extern HIDDEN int __glXDispSwap_%s(struct __GLXclientStateRec *, GLbyte *);' % (func.name)
+					print('extern HIDDEN int __glXDisp_%s(struct __GLXclientStateRec *, GLbyte *);' % (func.name))
+					print('extern HIDDEN int __glXDispSwap_%s(struct __GLXclientStateRec *, GLbyte *);' % (func.name))
 
 					if func.glx_sop and func.glx_vendorpriv:
 						n = func.glx_vendorpriv_names[0]
-						print 'extern HIDDEN int __glXDisp_%s(struct __GLXclientStateRec *, GLbyte *);' % (n)
-						print 'extern HIDDEN int __glXDispSwap_%s(struct __GLXclientStateRec *, GLbyte *);' % (n)
+						print('extern HIDDEN int __glXDisp_%s(struct __GLXclientStateRec *, GLbyte *);' % (n))
+						print('extern HIDDEN int __glXDispSwap_%s(struct __GLXclientStateRec *, GLbyte *);' % (n))
 
 		return
 
@@ -77,34 +77,34 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 
 
 	def printRealHeader(self):
-		print '#include <X11/Xmd.h>'
-		print '#include <GL/gl.h>'
-		print '#include <GL/glxproto.h>'
-
-		print '#include <inttypes.h>'
-		print '#include "indirect_size.h"'
-		print '#include "indirect_size_get.h"'
-		print '#include "indirect_dispatch.h"'
-		print '#include "glxserver.h"'
-		print '#include "glxbyteorder.h"'
-		print '#include "indirect_util.h"'
-		print '#include "singlesize.h"'
-		print '#include "glapi.h"'
-		print '#include "glapitable.h"'
-		print '#include "glthread.h"'
-		print '#include "glapidispatch.h"'
-		print ''
-		print '#define __GLX_PAD(x)  (((x) + 3) & ~3)'
-		print ''
-		print 'typedef struct {'
-		print '    __GLX_PIXEL_3D_HDR;'
-		print '} __GLXpixel3DHeader;'
-		print ''
-		print 'extern GLboolean __glXErrorOccured( void );'
-		print 'extern void __glXClearErrorOccured( void );'
-		print ''
-		print 'static const unsigned dummy_answer[2] = {0, 0};'
-		print ''
+		print('#include <X11/Xmd.h>')
+		print('#include <GL/gl.h>')
+		print('#include <GL/glxproto.h>')
+
+		print('#include <inttypes.h>')
+		print('#include "indirect_size.h"')
+		print('#include "indirect_size_get.h"')
+		print('#include "indirect_dispatch.h"')
+		print('#include "glxserver.h"')
+		print('#include "glxbyteorder.h"')
+		print('#include "indirect_util.h"')
+		print('#include "singlesize.h"')
+		print('#include "glapi.h"')
+		print('#include "glapitable.h"')
+		print('#include "glthread.h"')
+		print('#include "glapidispatch.h"')
+		print('')
+		print('#define __GLX_PAD(x)  (((x) + 3) & ~3)')
+		print('')
+		print('typedef struct {')
+		print('    __GLX_PIXEL_3D_HDR;')
+		print('} __GLXpixel3DHeader;')
+		print('')
+		print('extern GLboolean __glXErrorOccured( void );')
+		print('extern void __glXClearErrorOccured( void );')
+		print('')
+		print('static const unsigned dummy_answer[2] = {0, 0};')
+		print('')
 		return
 
 
@@ -133,11 +133,11 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			base = '__glXDispSwap'
 
 		if f.glx_rop:
-			print 'void %s_%s(GLbyte * pc)' % (base, name)
+			print('void %s_%s(GLbyte * pc)' % (base, name))
 		else:
-			print 'int %s_%s(__GLXclientState *cl, GLbyte *pc)' % (base, name)
+			print('int %s_%s(__GLXclientState *cl, GLbyte *pc)' % (base, name))
 
-		print '{'
+		print('{')
 
 		if f.glx_rop or f.vectorequiv:
 			self.printRenderFunction(f)
@@ -145,10 +145,10 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			if len(f.get_images()) == 0: 
 				self.printSingleFunction(f, name)
 		else:
-			print "/* Missing GLX protocol for %s. */" % (name)
+			print("/* Missing GLX protocol for %s. */" % (name))
 
-		print '}'
-		print ''
+		print('}')
+		print('')
 		return
 
 
@@ -172,30 +172,30 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 				if t.glx_name not in already_done:
 					real_name = self.real_types[t_size]
 
-					print 'static %s' % (t_name)
-					print 'bswap_%s( const void * src )' % (t.glx_name)
-					print '{'
-					print '    union { %s dst; %s ret; } x;' % (real_name, t_name)
-					print '    x.dst = bswap_%u( *(%s *) src );' % (t_size * 8, real_name)
-					print '    return x.ret;'
-					print '}'
-					print ''
+					print('static %s' % (t_name))
+					print('bswap_%s( const void * src )' % (t.glx_name))
+					print('{')
+					print('    union { %s dst; %s ret; } x;' % (real_name, t_name))
+					print('    x.dst = bswap_%u( *(%s *) src );' % (t_size * 8, real_name))
+					print('    return x.ret;')
+					print('}')
+					print('')
 					already_done.append( t.glx_name )
 
 		for bits in [16, 32, 64]:
-			print 'static void *'
-			print 'bswap_%u_array( uint%u_t * src, unsigned count )' % (bits, bits)
-			print '{'
-			print '    unsigned  i;'
-			print ''
-			print '    for ( i = 0 ; i < count ; i++ ) {'
-			print '        uint%u_t temp = bswap_%u( src[i] );' % (bits, bits)
-			print '        src[i] = temp;'
-			print '    }'
-			print ''
-			print '    return src;'
-			print '}'
-			print ''
+			print('static void *')
+			print('bswap_%u_array( uint%u_t * src, unsigned count )' % (bits, bits))
+			print('{')
+			print('    unsigned  i;')
+			print('')
+			print('    for ( i = 0 ; i < count ; i++ ) {')
+			print('        uint%u_t temp = bswap_%u( src[i] );' % (bits, bits))
+			print('        src[i] = temp;')
+			print('    }')
+			print('')
+			print('    return src;')
+			print('}')
+			print('')
 			
 
 	def fetch_param(self, param):
@@ -237,11 +237,11 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			
 
 		if len( list ):
-			print '%s    %sCALL_%s( GET_DISPATCH(), (' % (indent, retval_assign, f.name)
-			print string.join( list, ",\n" )
-			print '%s    ) );' % (indent)
+			print('%s    %sCALL_%s( GET_DISPATCH(), (' % (indent, retval_assign, f.name))
+			print(string.join( list, ",\n" ))
+			print('%s    ) );' % (indent))
 		else:
-			print '%s    %sCALL_%s( GET_DISPATCH(), () );' % (indent, retval_assign, f.name)
+			print('%s    %sCALL_%s( GET_DISPATCH(), () );' % (indent, retval_assign, f.name))
 		return
 
 
@@ -266,7 +266,7 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			# FIXME or something similar.
 
 			if param.img_null_flag:
-				print '%s    const CARD32 ptr_is_null = *(CARD32 *)(pc + %s);' % (indent, param.offset - 4)
+				print('%s    const CARD32 ptr_is_null = *(CARD32 *)(pc + %s);' % (indent, param.offset - 4))
 				cond = '(ptr_is_null != 0) ? NULL : '
 			else:
 				cond = ""
@@ -277,33 +277,33 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			if param.is_image():
 				offset = f.offset_of( param.name )
 
-				print '%s    %s const %s = (%s) (%s(pc + %s));' % (indent, type_string, param.name, type_string, cond, offset)
+				print('%s    %s const %s = (%s) (%s(pc + %s));' % (indent, type_string, param.name, type_string, cond, offset))
 				
 				if param.depth:
-					print '%s    __GLXpixel3DHeader * const hdr = (__GLXpixel3DHeader *)(pc);' % (indent)
+					print('%s    __GLXpixel3DHeader * const hdr = (__GLXpixel3DHeader *)(pc);' % (indent))
 				else:
-					print '%s    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);' % (indent)
+					print('%s    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);' % (indent))
 
 				need_blank = 1
 			elif param.is_counter or param.name in f.count_parameter_list:
 				location = self.fetch_param(param)
-				print '%s    const %s %s = %s;' % (indent, type_string, param.name, location)
+				print('%s    const %s %s = %s;' % (indent, type_string, param.name, location))
 				need_blank = 1
 			elif len(param.count_parameter_list):
 				if param.size() == 1 and not self.do_swap:
 					location = self.fetch_param(param)
-					print '%s    %s %s = %s%s;' % (indent, type_string, param.name, cond, location)
+					print('%s    %s %s = %s%s;' % (indent, type_string, param.name, cond, location))
 				else:
-					print '%s    %s %s;' % (indent, type_string, param.name)
+					print('%s    %s %s;' % (indent, type_string, param.name))
 				need_blank = 1
 
 
 
 		if need_blank:
-			print ''
+			print('')
 
 		if align64:
-			print '#ifdef __GLX_ALIGN64'
+			print('#ifdef __GLX_ALIGN64')
 
 			if f.has_variable_size_request():
 				self.emit_packet_size_calculation(f, 4)
@@ -311,12 +311,12 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			else:
 				s = str((f.command_fixed_length() + 3) & ~3)
 
-			print '    if ((unsigned long)(pc) & 7) {'
-			print '        (void) memmove(pc-4, pc, %s);' % (s)
-			print '        pc -= 4;'
-			print '    }'
-			print '#endif'
-			print ''
+			print('    if ((unsigned long)(pc) & 7) {')
+			print('        (void) memmove(pc-4, pc, %s);' % (s))
+			print('        pc -= 4;')
+			print('    }')
+			print('#endif')
+			print('')
 
 
 		need_blank = 0
@@ -341,35 +341,35 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 						x.append( [2, ['SHORT', 'UNSIGNED_SHORT']] )
 						x.append( [4, ['INT', 'UNSIGNED_INT', 'FLOAT']] )
 
-						print '    switch(%s) {' % (param.count_parameter_list[0])
+						print('    switch(%s) {' % (param.count_parameter_list[0]))
 						for sub in x:
 							for t_name in sub[1]:
-								print '    case GL_%s:' % (t_name)
+								print('    case GL_%s:' % (t_name))
 
 							if sub[0] == 1:
-								print '        %s = (%s) (pc + %s); break;' % (param.name, param.type_string(), o)
+								print('        %s = (%s) (pc + %s); break;' % (param.name, param.type_string(), o))
 							else:
 								swap_func = self.swap_name(sub[0])
-								print '        %s = (%s) %s( (%s *) (pc + %s), %s ); break;' % (param.name, param.type_string(), swap_func, self.real_types[sub[0]], o, count_name)
-						print '    default:'
-						print '        return;'
-						print '    }'
+								print('        %s = (%s) %s( (%s *) (pc + %s), %s ); break;' % (param.name, param.type_string(), swap_func, self.real_types[sub[0]], o, count_name))
+						print('    default:')
+						print('        return;')
+						print('    }')
 					else:
 						swap_func = self.swap_name(type_size)
 						compsize = self.size_call(f, 1)
-						print '    %s = (%s) %s( (%s *) (pc + %s), %s );' % (param.name, param.type_string(), swap_func, self.real_types[type_size], o, compsize)
+						print('    %s = (%s) %s( (%s *) (pc + %s), %s );' % (param.name, param.type_string(), swap_func, self.real_types[type_size], o, compsize))
 
 					need_blank = 1
 
 		else:
 			for param in f.parameterIterateGlxSend():
 				if param.count_parameter_list:
-					print '%s    %s = (%s) (pc + %s);' % (indent, param.name, param.type_string(), param.offset)
+					print('%s    %s = (%s) (pc + %s);' % (indent, param.name, param.type_string(), param.offset))
 					need_blank = 1
 
 
 		if need_blank:
-			print ''
+			print('')
 
 
 		return
@@ -377,29 +377,29 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 
 	def printSingleFunction(self, f, name):
 		if name not in f.glx_vendorpriv_names:
-			print '    xGLXSingleReq * const req = (xGLXSingleReq *) pc;'
+			print('    xGLXSingleReq * const req = (xGLXSingleReq *) pc;')
 		else:
-			print '    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;'
+			print('    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;')
 
-		print '    int error;'
+		print('    int error;')
 
 		if self.do_swap:
-		    print '    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);'
+		    print('    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);')
 		else:
-		    print '    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);'
+		    print('    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);')
 
-		print ''
+		print('')
 		if name not in f.glx_vendorpriv_names:
-			print '    pc += __GLX_SINGLE_HDR_SIZE;'
+			print('    pc += __GLX_SINGLE_HDR_SIZE;')
 		else:
-			print '    pc += __GLX_VENDPRIV_HDR_SIZE;'
+			print('    pc += __GLX_VENDPRIV_HDR_SIZE;')
 
-		print '    if ( cx != NULL ) {'
+		print('    if ( cx != NULL ) {')
 		self.common_func_print_just_start(f, "    ")
 		
 
 		if f.return_type != 'void':
-			print '        %s retval;' % (f.return_type)
+			print('        %s retval;' % (f.return_type))
 			retval_string = "retval"
 			retval_assign = "retval = "
 		else:
@@ -427,23 +427,23 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 
 
 			if param.count_parameter_list:
-				print '        const GLuint compsize = %s;' % (self.size_call(f, 1))
-				print '        %s answerBuffer[200];' %  (answer_type)
-				print '        %s %s = __glXGetAnswerBuffer(cl, compsize%s, answerBuffer, sizeof(answerBuffer), %u);' % (param.type_string(), param.name, size_scale, type_size )
+				print('        const GLuint compsize = %s;' % (self.size_call(f, 1)))
+				print('        %s answerBuffer[200];' %  (answer_type))
+				print('        %s %s = __glXGetAnswerBuffer(cl, compsize%s, answerBuffer, sizeof(answerBuffer), %u);' % (param.type_string(), param.name, size_scale, type_size ))
 				answer_string = param.name
 				answer_count = "compsize"
 
-				print ''
-				print '        if (%s == NULL) return BadAlloc;' % (param.name)
-				print '        __glXClearErrorOccured();'
-				print ''
+				print('')
+				print('        if (%s == NULL) return BadAlloc;' % (param.name))
+				print('        __glXClearErrorOccured();')
+				print('')
 			elif param.counter:
-				print '        %s answerBuffer[200];' %  (answer_type)
-				print '        %s %s = __glXGetAnswerBuffer(cl, %s%s, answerBuffer, sizeof(answerBuffer), %u);' % (param.type_string(), param.name, param.counter, size_scale, type_size)
+				print('        %s answerBuffer[200];' %  (answer_type))
+				print('        %s %s = __glXGetAnswerBuffer(cl, %s%s, answerBuffer, sizeof(answerBuffer), %u);' % (param.type_string(), param.name, param.counter, size_scale, type_size))
 				answer_string = param.name
 				answer_count = param.counter
 			elif c >= 1:
-				print '        %s %s[%u];' % (answer_type, param.name, c)
+				print('        %s %s[%u];' % (answer_type, param.name, c))
 				answer_string = param.name
 				answer_count = "%u" % (c)
 
@@ -462,21 +462,21 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 
 					if type_size > 1:
 						swap_name = self.swap_name( type_size )
-						print '        (void) %s( (uint%u_t *) %s, %s );' % (swap_name, 8 * type_size, param.name, answer_count)
+						print('        (void) %s( (uint%u_t *) %s, %s );' % (swap_name, 8 * type_size, param.name, answer_count))
 
 
 				reply_func = '__glXSendReplySwap'
 			else:
 				reply_func = '__glXSendReply'
 
-			print '        %s(cl->client, %s, %s, %u, %s, %s);' % (reply_func, answer_string, answer_count, type_size, is_array_string, retval_string)
+			print('        %s(cl->client, %s, %s, %u, %s, %s);' % (reply_func, answer_string, answer_count, type_size, is_array_string, retval_string))
 		#elif f.note_unflushed:
 		#	print '        cx->hasUnflushedCommands = GL_TRUE;'
 
-		print '        error = Success;'
-		print '    }'
-		print ''
-		print '    return error;'
+		print('        error = Success;')
+		print('    }')
+		print('')
+		print('    return error;')
 		return
 
 
@@ -505,19 +505,19 @@ class PrintGlxDispatchFunctions(glX_proto_common.glx_print_proto):
 			# the must NEVER be byte-swapped.
 
 			if not (img.img_type == "GL_BITMAP" and img.img_format == "GL_COLOR_INDEX"):
-				print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );'
+				print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );')
 
-			print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );'
+			print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );')
 
-			print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) %shdr->rowLength%s) );' % (pre, post)
+			print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) %shdr->rowLength%s) );' % (pre, post))
 			if img.depth:
-				print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_IMAGE_HEIGHT, (GLint) %shdr->imageHeight%s) );' % (pre, post)
-			print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) %shdr->skipRows%s) );' % (pre, post)
+				print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_IMAGE_HEIGHT, (GLint) %shdr->imageHeight%s) );' % (pre, post))
+			print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) %shdr->skipRows%s) );' % (pre, post))
 			if img.depth:
-				print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_IMAGES,  (GLint) %shdr->skipImages%s) );' % (pre, post)
-			print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) %shdr->skipPixels%s) );' % (pre, post)
-			print '    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) %shdr->alignment%s) );' % (pre, post)
-			print ''
+				print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_IMAGES,  (GLint) %shdr->skipImages%s) );' % (pre, post))
+			print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) %shdr->skipPixels%s) );' % (pre, post))
+			print('    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) %shdr->alignment%s) );' % (pre, post))
+			print('')
 
 
 		self.emit_function_call(f, "", "")
@@ -529,12 +529,12 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:s")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	mode = "dispatch_c"
 	do_swap = 0
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-m":
diff --git a/src/mapi/glapi/gen/glX_proto_send.py b/src/mapi/glapi/gen/glX_proto_send.py
index 6330d91..52f10e1 100644
--- a/src/mapi/glapi/gen/glX_proto_send.py
+++ b/src/mapi/glapi/gen/glX_proto_send.py
@@ -161,39 +161,39 @@ class PrintGlxProtoStubs(glX_proto_common.glx_print_proto):
 		return
 
 	def printRealHeader(self):
-		print ''
-		print '#include <GL/gl.h>'
-		print '#include "indirect.h"'
-		print '#include "glxclient.h"'
-		print '#include "indirect_size.h"'
-		print '#include "glapi.h"'
-		print '#include "glthread.h"'
-		print '#include <GL/glxproto.h>'
-		print '#ifdef USE_XCB'
-		print '#include <X11/Xlib-xcb.h>'
-		print '#include <xcb/xcb.h>'
-		print '#include <xcb/glx.h>'
-		print '#endif /* USE_XCB */'
-
-		print ''
-		print '#define __GLX_PAD(n) (((n) + 3) & ~3)'
-		print ''
+		print('')
+		print('#include <GL/gl.h>')
+		print('#include "indirect.h"')
+		print('#include "glxclient.h"')
+		print('#include "indirect_size.h"')
+		print('#include "glapi.h"')
+		print('#include "glthread.h"')
+		print('#include <GL/glxproto.h>')
+		print('#ifdef USE_XCB')
+		print('#include <X11/Xlib-xcb.h>')
+		print('#include <xcb/xcb.h>')
+		print('#include <xcb/glx.h>')
+		print('#endif /* USE_XCB */')
+
+		print('')
+		print('#define __GLX_PAD(n) (((n) + 3) & ~3)')
+		print('')
 		self.printFastcall()
 		self.printNoinline()
-		print ''
-		print '#ifndef __GNUC__'
-		print '#  define __builtin_expect(x, y) x'
-		print '#endif'
-		print ''
-		print '/* If the size and opcode values are known at compile-time, this will, on'
-		print ' * x86 at least, emit them with a single instruction.'
-		print ' */'
-		print '#define emit_header(dest, op, size)            \\'
-		print '    do { union { short s[2]; int i; } temp;    \\'
-		print '         temp.s[0] = (size); temp.s[1] = (op); \\'
-		print '         *((int *)(dest)) = temp.i; } while(0)'
-		print ''
-		print """NOINLINE CARD32
+		print('')
+		print('#ifndef __GNUC__')
+		print('#  define __builtin_expect(x, y) x')
+		print('#endif')
+		print('')
+		print('/* If the size and opcode values are known at compile-time, this will, on')
+		print(' * x86 at least, emit them with a single instruction.')
+		print(' */')
+		print('#define emit_header(dest, op, size)            \\')
+		print('    do { union { short s[2]; int i; } temp;    \\')
+		print('         temp.s[0] = (size); temp.s[1] = (op); \\')
+		print('         *((int *)(dest)) = temp.i; } while(0)')
+		print('')
+		print("""NOINLINE CARD32
 __glXReadReply( Display *dpy, size_t size, void * dest, GLboolean reply_is_always_array )
 {
     xGLXSingleReply reply;
@@ -305,7 +305,7 @@ const GLuint __glXDefaultPixelStore[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 1 };
 #define default_pixel_store_3D_size 36
 #define default_pixel_store_4D      (__glXDefaultPixelStore+0)
 #define default_pixel_store_4D_size 36
-"""
+""")
 
 		for size in self.generic_sizes:
 			self.print_generic_function(size)
@@ -360,20 +360,19 @@ const GLuint __glXDefaultPixelStore[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 1 };
 				if func.has_different_protocol(n):
 					procs[n] = func.static_glx_name(n)
 
-		print """
+		print("""
 #ifdef GLX_SHARED_GLAPI
 
 static const struct proc_pair
 {
    const char *name;
    _glapi_proc proc;
-} proc_pairs[%d] = {""" % len(procs)
-		names = procs.keys()
-		names.sort()
-		for i in xrange(len(names)):
+} proc_pairs[%d] = {""" % len(procs))
+		names = sorted(procs.keys())
+		for i in range(len(names)):
 			comma = ',' if i < len(names) - 1 else ''
-			print '   { "%s", (_glapi_proc) gl%s }%s' % (names[i], procs[names[i]], comma)
-		print """};
+			print('   { "%s", (_glapi_proc) gl%s }%s' % (names[i], procs[names[i]], comma))
+		print("""};
 
 static int
 __indirect_get_proc_compare(const void *key, const void *memb)
@@ -398,16 +397,16 @@ __indirect_get_proc_address(const char *name)
 }
 
 #endif /* GLX_SHARED_GLAPI */
-"""
+""")
 		return
 
 
 	def printFunction(self, func, name):
 		footer = '}\n'
 		if func.glx_rop == ~0:
-			print 'static %s' % (func.return_type)
-			print '%s( unsigned opcode, unsigned dim, %s )' % (func.name, func.get_parameter_string())
-			print '{'
+			print('static %s' % (func.return_type))
+			print('%s( unsigned opcode, unsigned dim, %s )' % (func.name, func.get_parameter_string()))
+			print('{')
 		else:
 			if func.has_different_protocol(name):
 				if func.return_type == "void":
@@ -416,24 +415,24 @@ __indirect_get_proc_address(const char *name)
 					ret_string = "return "
 
 				func_name = func.static_glx_name(name)
-				print '#define %s %d' % (func.opcode_vendor_name(name), func.glx_vendorpriv)
-				print '%s gl%s(%s)' % (func.return_type, func_name, func.get_parameter_string())
-				print '{'
-				print '    struct glx_context * const gc = __glXGetCurrentContext();'
-				print ''
-				print '#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)'
-				print '    if (gc->isDirect) {'
-				print '    %sGET_DISPATCH()->%s(%s);' % (ret_string, func.name, func.get_called_parameter_string())
-				print '    } else'
-				print '#endif'
-				print '    {'
+				print('#define %s %d' % (func.opcode_vendor_name(name), func.glx_vendorpriv))
+				print('%s gl%s(%s)' % (func.return_type, func_name, func.get_parameter_string()))
+				print('{')
+				print('    struct glx_context * const gc = __glXGetCurrentContext();')
+				print('')
+				print('#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)')
+				print('    if (gc->isDirect) {')
+				print('    %sGET_DISPATCH()->%s(%s);' % (ret_string, func.name, func.get_called_parameter_string()))
+				print('    } else')
+				print('#endif')
+				print('    {')
 
 				footer = '}\n}\n'
 			else:
-				print '#define %s %d' % (func.opcode_name(), func.opcode_value())
+				print('#define %s %d' % (func.opcode_name(), func.opcode_value()))
 
-				print '%s __indirect_gl%s(%s)' % (func.return_type, name, func.get_parameter_string())
-				print '{'
+				print('%s __indirect_gl%s(%s)' % (func.return_type, name, func.get_parameter_string()))
+				print('{')
 
 
 		if func.glx_rop != 0 or func.vectorequiv != None:
@@ -445,15 +444,15 @@ __indirect_get_proc_address(const char *name)
 			self.printSingleFunction(func, name)
 			pass
 		else:
-			print "/* Missing GLX protocol for %s. */" % (name)
+			print("/* Missing GLX protocol for %s. */" % (name))
 
-		print footer
+		print(footer)
 		return
 
 
 	def print_generic_function(self, n):
 		size = (n + 3) & ~3
-		print """static FASTCALL NOINLINE void
+		print("""static FASTCALL NOINLINE void
 generic_%u_byte( GLint rop, const void * ptr )
 {
     struct glx_context * const gc = __glXGetCurrentContext();
@@ -464,7 +463,7 @@ generic_%u_byte( GLint rop, const void * ptr )
     gc->pc += cmdlen;
     if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
 }
-""" % (n, size + 4, size)
+""" % (n, size + 4, size))
 		return
 
 
@@ -475,14 +474,14 @@ generic_%u_byte( GLint rop, const void * ptr )
 			src_ptr = "&" + p.name
 
 		if p.is_padding:
-			print '(void) memset((void *)(%s + %u), 0, %s);' \
-			    % (pc, p.offset + adjust, p.size_string() )
+			print('(void) memset((void *)(%s + %u), 0, %s);' \
+			    % (pc, p.offset + adjust, p.size_string() ))
 		elif not extra_offset:
-			print '(void) memcpy((void *)(%s + %u), (void *)(%s), %s);' \
-			    % (pc, p.offset + adjust, src_ptr, p.size_string() )
+			print('(void) memcpy((void *)(%s + %u), (void *)(%s), %s);' \
+			    % (pc, p.offset + adjust, src_ptr, p.size_string() ))
 		else:
-			print '(void) memcpy((void *)(%s + %u + %s), (void *)(%s), %s);' \
-			    % (pc, p.offset + adjust, extra_offset, src_ptr, p.size_string() )
+			print('(void) memcpy((void *)(%s + %u + %s), (void *)(%s), %s);' \
+			    % (pc, p.offset + adjust, extra_offset, src_ptr, p.size_string() ))
 
 	def common_emit_args(self, f, pc, adjust, skip_vla):
 		extra_offset = None
@@ -518,7 +517,7 @@ generic_%u_byte( GLint rop, const void * ptr )
 				self.common_emit_one_arg(param, pc, adjust, None)
 
 				if f.pad_after(param):
-					print '(void) memcpy((void *)(%s + %u), zero, 4);' % (pc, (param.offset + param.size()) + adjust)
+					print('(void) memcpy((void *)(%s + %u), zero, 4);' % (pc, (param.offset + param.size()) + adjust))
 
 			else:
 				[dim, width, height, depth, extent] = param.get_dimensions()
@@ -528,14 +527,14 @@ generic_%u_byte( GLint rop, const void * ptr )
 					dim_str = str(dim)
 
 				if param.is_padding:
-					print '(void) memset((void *)(%s + %u), 0, %s);' \
-					% (pc, (param.offset - 4) + adjust, param.size_string() )
+					print('(void) memset((void *)(%s + %u), 0, %s);' \
+					% (pc, (param.offset - 4) + adjust, param.size_string() ))
 
 				if param.img_null_flag:
 					if large:
-						print '(void) memcpy((void *)(%s + %u), zero, 4);' % (pc, (param.offset - 4) + adjust)
+						print('(void) memcpy((void *)(%s + %u), zero, 4);' % (pc, (param.offset - 4) + adjust))
 					else:
-						print '(void) memcpy((void *)(%s + %u), (void *)((%s == NULL) ? one : zero), 4);' % (pc, (param.offset - 4) + adjust, param.name)
+						print('(void) memcpy((void *)(%s + %u), (void *)((%s == NULL) ? one : zero), 4);' % (pc, (param.offset - 4) + adjust, param.name))
 
 
 				pixHeaderPtr = "%s + %u" % (pc, adjust)
@@ -547,13 +546,13 @@ generic_%u_byte( GLint rop, const void * ptr )
 					else:
 						condition = 'compsize > 0'
 
-					print 'if (%s) {' % (condition)
-					print '    (*gc->fillImage)(gc, %s, %s, %s, %s, %s, %s, %s, %s, %s);' % (dim_str, width, height, depth, param.img_format, param.img_type, param.name, pcPtr, pixHeaderPtr)
-					print '} else {'
-					print '    (void) memcpy( %s, default_pixel_store_%uD, default_pixel_store_%uD_size );' % (pixHeaderPtr, dim, dim)
-					print '}'
+					print('if (%s) {' % (condition))
+					print('    (*gc->fillImage)(gc, %s, %s, %s, %s, %s, %s, %s, %s, %s);' % (dim_str, width, height, depth, param.img_format, param.img_type, param.name, pcPtr, pixHeaderPtr))
+					print('} else {')
+					print('    (void) memcpy( %s, default_pixel_store_%uD, default_pixel_store_%uD_size );' % (pixHeaderPtr, dim, dim))
+					print('}')
 				else:
-					print '__glXSendLargeImage(gc, compsize, %s, %s, %s, %s, %s, %s, %s, %s, %s);' % (dim_str, width, height, depth, param.img_format, param.img_type, param.name, pcPtr, pixHeaderPtr)
+					print('__glXSendLargeImage(gc, compsize, %s, %s, %s, %s, %s, %s, %s, %s, %s);' % (dim_str, width, height, depth, param.img_format, param.img_type, param.name, pcPtr, pixHeaderPtr))
 
 		return
 
@@ -562,16 +561,16 @@ generic_%u_byte( GLint rop, const void * ptr )
 		if not op_name:
 			op_name = f.opcode_real_name()
 
-		print 'const GLint op = %s;' % (op_name)
-		print 'const GLuint cmdlenLarge = cmdlen + 4;'
-		print 'GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);'
-		print '(void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);'
-		print '(void) memcpy((void *)(pc + 4), (void *)(&op), 4);'
+		print('const GLint op = %s;' % (op_name))
+		print('const GLuint cmdlenLarge = cmdlen + 4;')
+		print('GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);')
+		print('(void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);')
+		print('(void) memcpy((void *)(pc + 4), (void *)(&op), 4);')
 		return
 
 
 	def common_func_print_just_start(self, f, name):
-		print '    struct glx_context * const gc = __glXGetCurrentContext();'
+		print('    struct glx_context * const gc = __glXGetCurrentContext();')
 
 		# The only reason that single and vendor private commands need
 		# a variable called 'dpy' is becuase they use the SyncHandle
@@ -589,10 +588,10 @@ generic_%u_byte( GLint rop, const void * ptr )
 		if not f.glx_rop:
 			for p in f.parameterIterateOutputs():
 				if p.is_image() and (p.img_format != "GL_COLOR_INDEX" or p.img_type != "GL_BITMAP"):
-					print '    const __GLXattribute * const state = gc->client_state_private;'
+					print('    const __GLXattribute * const state = gc->client_state_private;')
 					break
 
-			print '    Display * const dpy = gc->currentDpy;'
+			print('    Display * const dpy = gc->currentDpy;')
 			skip_condition = "dpy != NULL"
 		elif f.can_be_large:
 			skip_condition = "gc->currentDpy != NULL"
@@ -601,26 +600,26 @@ generic_%u_byte( GLint rop, const void * ptr )
 
 
 		if f.return_type != 'void':
-			print '    %s retval = (%s) 0;' % (f.return_type, f.return_type)
+			print('    %s retval = (%s) 0;' % (f.return_type, f.return_type))
 
 
 		if name != None and name not in f.glx_vendorpriv_names:
-			print '#ifndef USE_XCB'
+			print('#ifndef USE_XCB')
 		self.emit_packet_size_calculation(f, 0)
 		if name != None and name not in f.glx_vendorpriv_names:
-			print '#endif'
+			print('#endif')
 
 		condition_list = []
 		for p in f.parameterIterateCounters():
 			condition_list.append( "%s >= 0" % (p.name) )
 			# 'counter' parameters cannot be negative
-			print "    if (%s < 0) {" % p.name
-			print "        __glXSetError(gc, GL_INVALID_VALUE);"
+			print("    if (%s < 0) {" % p.name)
+			print("        __glXSetError(gc, GL_INVALID_VALUE);")
 			if f.return_type != 'void':
-				print "        return 0;"
+				print("        return 0;")
 			else:
-				print "        return;"
-			print "    }"
+				print("        return;")
+			print("    }")
 
 		if skip_condition:
 			condition_list.append( skip_condition )
@@ -631,7 +630,7 @@ generic_%u_byte( GLint rop, const void * ptr )
 			else:
 				skip_condition = "%s" % (condition_list.pop(0))
 
-			print '    if (__builtin_expect(%s, 1)) {' % (skip_condition)
+			print('    if (__builtin_expect(%s, 1)) {' % (skip_condition))
 			return 1
 		else:
 			return 0
@@ -641,16 +640,16 @@ generic_%u_byte( GLint rop, const void * ptr )
 		self.common_func_print_just_start(f, name)
 
 		if self.debug:
-			print '        printf( "Enter %%s...\\n", "gl%s" );' % (f.name)
+			print('        printf( "Enter %%s...\\n", "gl%s" );' % (f.name))
 
 		if name not in f.glx_vendorpriv_names:
 
 			# XCB specific:
-			print '#ifdef USE_XCB'
+			print('#ifdef USE_XCB')
 			if self.debug:
-				print '        printf("\\tUsing XCB.\\n");'
-			print '        xcb_connection_t *c = XGetXCBConnection(dpy);'
-			print '        (void) __glXFlushRenderBuffer(gc, gc->pc);'
+				print('        printf("\\tUsing XCB.\\n");')
+			print('        xcb_connection_t *c = XGetXCBConnection(dpy);')
+			print('        (void) __glXFlushRenderBuffer(gc, gc->pc);')
 			xcb_name = 'xcb_glx%s' % convertStringForXCB(name)
 
 			iparams=[]
@@ -677,24 +676,24 @@ generic_%u_byte( GLint rop, const void * ptr )
 			xcb_request = '%s(%s)' % (xcb_name, ", ".join(["c", "gc->currentContextTag"] + iparams + extra_iparams))
 
 			if f.needs_reply():
-				print '        %s_reply_t *reply = %s_reply(c, %s, NULL);' % (xcb_name, xcb_name, xcb_request)
+				print('        %s_reply_t *reply = %s_reply(c, %s, NULL);' % (xcb_name, xcb_name, xcb_request))
 				if output and f.reply_always_array:
-					print '        (void)memcpy(%s, %s_data(reply), %s_data_length(reply) * sizeof(%s));' % (output.name, xcb_name, xcb_name, output.get_base_type_string())
+					print('        (void)memcpy(%s, %s_data(reply), %s_data_length(reply) * sizeof(%s));' % (output.name, xcb_name, xcb_name, output.get_base_type_string()))
 
 				elif output and not f.reply_always_array:
 					if not output.is_image():
-						print '        if (%s_data_length(reply) == 0)' % (xcb_name)
-						print '            (void)memcpy(%s, &reply->datum, sizeof(reply->datum));' % (output.name)
-						print '        else'
-					print '        (void)memcpy(%s, %s_data(reply), %s_data_length(reply) * sizeof(%s));' % (output.name, xcb_name, xcb_name, output.get_base_type_string())
+						print('        if (%s_data_length(reply) == 0)' % (xcb_name))
+						print('            (void)memcpy(%s, &reply->datum, sizeof(reply->datum));' % (output.name))
+						print('        else')
+					print('        (void)memcpy(%s, %s_data(reply), %s_data_length(reply) * sizeof(%s));' % (output.name, xcb_name, xcb_name, output.get_base_type_string()))
 
 
 				if f.return_type != 'void':
-					print '        retval = reply->ret_val;'
-				print '        free(reply);'
+					print('        retval = reply->ret_val;')
+				print('        free(reply);')
 			else:
-				print '        ' + xcb_request + ';'
-			print '#else'
+				print('        ' + xcb_request + ';')
+			print('#else')
 			# End of XCB specific.
 
 
@@ -704,9 +703,9 @@ generic_%u_byte( GLint rop, const void * ptr )
 			pc_decl = "(void)"
 
 		if name in f.glx_vendorpriv_names:
-			print '        %s __glXSetupVendorRequest(gc, %s, %s, cmdlen);' % (pc_decl, f.opcode_real_name(), f.opcode_vendor_name(name))
+			print('        %s __glXSetupVendorRequest(gc, %s, %s, cmdlen);' % (pc_decl, f.opcode_real_name(), f.opcode_vendor_name(name)))
 		else:
-			print '        %s __glXSetupSingleRequest(gc, %s, cmdlen);' % (pc_decl, f.opcode_name())
+			print('        %s __glXSetupSingleRequest(gc, %s, cmdlen);' % (pc_decl, f.opcode_name()))
 
 		self.common_emit_args(f, "pc", 0, 0)
 
@@ -715,12 +714,12 @@ generic_%u_byte( GLint rop, const void * ptr )
 		for img in images:
 			if img.is_output:
 				o = f.command_fixed_length() - 4
-				print '        *(int32_t *)(pc + %u) = 0;' % (o)
+				print('        *(int32_t *)(pc + %u) = 0;' % (o))
 				if img.img_format != "GL_COLOR_INDEX" or img.img_type != "GL_BITMAP":
-					print '        * (int8_t *)(pc + %u) = state->storePack.swapEndian;' % (o)
+					print('        * (int8_t *)(pc + %u) = state->storePack.swapEndian;' % (o))
 		
 				if f.img_reset:
-					print '        * (int8_t *)(pc + %u) = %s;' % (o + 1, f.img_reset)
+					print('        * (int8_t *)(pc + %u) = %s;' % (o + 1, f.img_reset))
 
 
 		return_name = ''
@@ -737,9 +736,9 @@ generic_%u_byte( GLint rop, const void * ptr )
 				if p.is_image():
 					[dim, w, h, d, junk] = p.get_dimensions()
 					if f.dimensions_in_reply:
-						print "        __glXReadPixelReply(dpy, gc, %u, 0, 0, 0, %s, %s, %s, GL_TRUE);" % (dim, p.img_format, p.img_type, p.name)
+						print("        __glXReadPixelReply(dpy, gc, %u, 0, 0, 0, %s, %s, %s, GL_TRUE);" % (dim, p.img_format, p.img_type, p.name))
 					else:
-						print "        __glXReadPixelReply(dpy, gc, %u, %s, %s, %s, %s, %s, %s, GL_FALSE);" % (dim, w, h, d, p.img_format, p.img_type, p.name)
+						print("        __glXReadPixelReply(dpy, gc, %u, %s, %s, %s, %s, %s, %s, GL_FALSE);" % (dim, w, h, d, p.img_format, p.img_type, p.name))
 
 					got_reply = 1
 				else:
@@ -759,7 +758,7 @@ generic_%u_byte( GLint rop, const void * ptr )
 					# non-arrays) gives us this.
 
 					s = p.size() / p.get_element_count()
-					print "       %s __glXReadReply(dpy, %s, %s, %s);" % (return_str, s, p.name, aa)
+					print("       %s __glXReadReply(dpy, %s, %s, %s);" % (return_str, s, p.name, aa))
 					got_reply = 1
 
 
@@ -767,30 +766,30 @@ generic_%u_byte( GLint rop, const void * ptr )
 			# read a NULL reply to get the return value.
 
 			if not got_reply:
-				print "       %s __glXReadReply(dpy, 0, NULL, GL_FALSE);" % (return_str)
+				print("       %s __glXReadReply(dpy, 0, NULL, GL_FALSE);" % (return_str))
 
 
 		elif self.debug:
 			# Only emit the extra glFinish call for functions
 			# that don't already require a reply from the server.
-			print '        __indirect_glFinish();'
+			print('        __indirect_glFinish();')
 
 		if self.debug:
-			print '        printf( "Exit %%s.\\n", "gl%s" );' % (name)
+			print('        printf( "Exit %%s.\\n", "gl%s" );' % (name))
 
 
-		print '        UnlockDisplay(dpy); SyncHandle();'
+		print('        UnlockDisplay(dpy); SyncHandle();')
 
 		if name not in f.glx_vendorpriv_names:
-			print '#endif /* USE_XCB */'
+			print('#endif /* USE_XCB */')
 
-		print '    }'
-		print '    return%s;' % (return_name)
+		print('    }')
+		print('    return%s;' % (return_name))
 		return
 
 
 	def printPixelFunction(self, f):
-		if self.pixel_stubs.has_key( f.name ):
+		if f.name in self.pixel_stubs:
 			# Normally gl_function::get_parameter_string could be
 			# used.  However, this call needs to have the missing
 			# dimensions (e.g., a fake height value for
@@ -809,7 +808,7 @@ generic_%u_byte( GLint rop, const void * ptr )
 				if f.pad_after(param):
 					p_string += ", 1"
 
-			print '    %s(%s, %u%s );' % (self.pixel_stubs[f.name] , f.opcode_name(), dim, p_string)
+			print('    %s(%s, %u%s );' % (self.pixel_stubs[f.name], f.opcode_name(), dim, p_string))
 			return
 
 
@@ -820,32 +819,32 @@ generic_%u_byte( GLint rop, const void * ptr )
 
 
 		if f.can_be_large:
-			print 'if (cmdlen <= gc->maxSmallRenderCommandSize) {'
-			print '    if ( (gc->pc + cmdlen) > gc->bufEnd ) {'
-			print '        (void) __glXFlushRenderBuffer(gc, gc->pc);'
-			print '    }'
+			print('if (cmdlen <= gc->maxSmallRenderCommandSize) {')
+			print('    if ( (gc->pc + cmdlen) > gc->bufEnd ) {')
+			print('        (void) __glXFlushRenderBuffer(gc, gc->pc);')
+			print('    }')
 
 		if f.glx_rop == ~0:
 			opcode = "opcode"
 		else:
 			opcode = f.opcode_real_name()
 
-		print 'emit_header(gc->pc, %s, cmdlen);' % (opcode)
+		print('emit_header(gc->pc, %s, cmdlen);' % (opcode))
 
 		self.pixel_emit_args( f, "gc->pc", 0 )
-		print 'gc->pc += cmdlen;'
-		print 'if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }'
+		print('gc->pc += cmdlen;')
+		print('if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }')
 
 		if f.can_be_large:
-			print '}'
-			print 'else {'
+			print('}')
+			print('else {')
 
 			self.large_emit_begin(f, opcode)
 			self.pixel_emit_args(f, "pc", 1)
 
-			print '}'
+			print('}')
 
-		if trailer: print trailer
+		if trailer: print(trailer)
 		return
 
 
@@ -862,7 +861,7 @@ generic_%u_byte( GLint rop, const void * ptr )
 			if p.is_pointer():
 				cmdlen = f.command_fixed_length()
 				if cmdlen in self.generic_sizes:
-					print '    generic_%u_byte( %s, %s );' % (cmdlen, f.opcode_real_name(), p.name)
+					print('    generic_%u_byte( %s, %s );' % (cmdlen, f.opcode_real_name(), p.name))
 					return
 
 		if self.common_func_print_just_start(f, None):
@@ -871,36 +870,36 @@ generic_%u_byte( GLint rop, const void * ptr )
 			trailer = None
 
 		if self.debug:
-			print 'printf( "Enter %%s...\\n", "gl%s" );' % (f.name)
+			print('printf( "Enter %%s...\\n", "gl%s" );' % (f.name))
 
 		if f.can_be_large:
-			print 'if (cmdlen <= gc->maxSmallRenderCommandSize) {'
-			print '    if ( (gc->pc + cmdlen) > gc->bufEnd ) {'
-			print '        (void) __glXFlushRenderBuffer(gc, gc->pc);'
-			print '    }'
+			print('if (cmdlen <= gc->maxSmallRenderCommandSize) {')
+			print('    if ( (gc->pc + cmdlen) > gc->bufEnd ) {')
+			print('        (void) __glXFlushRenderBuffer(gc, gc->pc);')
+			print('    }')
 
-		print 'emit_header(gc->pc, %s, cmdlen);' % (f.opcode_real_name())
+		print('emit_header(gc->pc, %s, cmdlen);' % (f.opcode_real_name()))
 
 		self.common_emit_args(f, "gc->pc", 4, 0)
-		print 'gc->pc += cmdlen;'
-		print 'if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }'
+		print('gc->pc += cmdlen;')
+		print('if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }')
 
 		if f.can_be_large:
-			print '}'
-			print 'else {'
+			print('}')
+			print('else {')
 
 			self.large_emit_begin(f)
 			self.common_emit_args(f, "pc", 8, 1)
 
 			p = f.variable_length_parameter()
-			print '    __glXSendLargeCommand(gc, pc, %u, %s, %s);' % (p.offset + 8, p.name, p.size_string())
-			print '}'
+			print('    __glXSendLargeCommand(gc, pc, %u, %s, %s);' % (p.offset + 8, p.name, p.size_string()))
+			print('}')
 
 		if self.debug:
-			print '__indirect_glFinish();'
-			print 'printf( "Exit %%s.\\n", "gl%s" );' % (f.name)
+			print('__indirect_glFinish();')
+			print('printf( "Exit %%s.\\n", "gl%s" );' % (f.name))
 
-		if trailer: print trailer
+		if trailer: print(trailer)
 		return
 
 
@@ -916,7 +915,7 @@ class PrintGlxProtoInit_c(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print """/**
+		print("""/**
  * \\file indirect_init.c
  * Initialize indirect rendering dispatch table.
  *
@@ -960,13 +959,13 @@ struct _glapi_table * __glXNewIndirectAPI( void )
        }
     }
 
-    /* now, initialize the entries we understand */"""
+    /* now, initialize the entries we understand */""")
 
 	def printRealFooter(self):
-		print """
+		print("""
     return glAPI;
 }
-"""
+""")
 		return
 
 
@@ -979,7 +978,7 @@ struct _glapi_table * __glXNewIndirectAPI( void )
 
 			for func in api.functionIterateByCategory(name):
 				if func.client_supported_for_indirect():
-					print '%s    glAPI->%s = __indirect_gl%s;' % (preamble, func.name, func.name)
+					print('%s    glAPI->%s = __indirect_gl%s;' % (preamble, func.name, func.name))
 					preamble = ''
 
 		return
@@ -1000,19 +999,19 @@ class PrintGlxProtoInit_h(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print """/**
+		print("""/**
  * \\file
  * Prototypes for indirect rendering functions.
  *
  * \\author Kevin E. Martin <kevin@precisioninsight.com>
  * \\author Ian Romanick <idr@us.ibm.com>
  */
-"""
+""")
 		self.printVisibility( "HIDDEN", "hidden" )
 		self.printFastcall()
 		self.printNoinline()
 
-		print """
+		print("""
 #include "glxclient.h"
 
 extern HIDDEN NOINLINE CARD32 __glXReadReply( Display *dpy, size_t size,
@@ -1028,38 +1027,38 @@ extern HIDDEN NOINLINE FASTCALL GLubyte * __glXSetupSingleRequest(
 
 extern HIDDEN NOINLINE FASTCALL GLubyte * __glXSetupVendorRequest(
     struct glx_context * gc, GLint code, GLint vop, GLint cmdlen );
-"""
+""")
 
 
 	def printBody(self, api):
 		for func in api.functionIterateGlx():
 			params = func.get_parameter_string()
 
-			print 'extern HIDDEN %s __indirect_gl%s(%s);' % (func.return_type, func.name, params)
+			print('extern HIDDEN %s __indirect_gl%s(%s);' % (func.return_type, func.name, params))
 
 			for n in func.entry_points:
 				if func.has_different_protocol(n):
 					asdf = func.static_glx_name(n)
 					if asdf not in func.static_entry_points:
-						print 'extern HIDDEN %s gl%s(%s);' % (func.return_type, asdf, params)
+						print('extern HIDDEN %s gl%s(%s);' % (func.return_type, asdf, params))
 						# give it a easy-to-remember name
 						if func.client_handcode:
-							print '#define gl_dispatch_stub_%s gl%s' % (n, asdf)
+							print('#define gl_dispatch_stub_%s gl%s' % (n, asdf))
 					else:
-						print 'GLAPI %s GLAPIENTRY gl%s(%s);' % (func.return_type, asdf, params)
+						print('GLAPI %s GLAPIENTRY gl%s(%s);' % (func.return_type, asdf, params))
 						
 					break
 
-		print ''
-		print '#ifdef GLX_SHARED_GLAPI'
-		print 'extern HIDDEN void (*__indirect_get_proc_address(const char *name))(void);'
-		print '#endif'
+		print('')
+		print('#ifdef GLX_SHARED_GLAPI')
+		print('extern HIDDEN void (*__indirect_get_proc_address(const char *name))(void);')
+		print('#endif')
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m output_mode] [-d]" % sys.argv[0]
-	print "    -m output_mode   Output mode can be one of 'proto', 'init_c' or 'init_h'."
-	print "    -d               Enable extra debug information in the generated code."
+	print("Usage: %s [-f input_file_name] [-m output_mode] [-d]" % sys.argv[0])
+	print("    -m output_mode   Output mode can be one of 'proto', 'init_c' or 'init_h'.")
+	print("    -d               Enable extra debug information in the generated code.")
 	sys.exit(1)
 
 
@@ -1068,12 +1067,12 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:d")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	debug = 0
 	mode = "proto"
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-m":
diff --git a/src/mapi/glapi/gen/glX_proto_size.py b/src/mapi/glapi/gen/glX_proto_size.py
index f16ea4c..e32a069 100644
--- a/src/mapi/glapi/gen/glX_proto_size.py
+++ b/src/mapi/glapi/gen/glX_proto_size.py
@@ -68,7 +68,7 @@ class glx_enum_function:
 		for enum_name in enum_dict:
 			e = enum_dict[ enum_name ]
 
-			if e.functions.has_key( match_name ):
+			if match_name in e.functions:
 				[count, mode] = e.functions[ match_name ]
 
 				if mode_set and mode != self.mode:
@@ -76,11 +76,11 @@ class glx_enum_function:
 
 				self.mode = mode
 
-				if self.enums.has_key( e.value ):
+				if e.value in self.enums:
 					if e.name not in self.enums[ e.value ]:
 						self.enums[ e.value ].append( e )
 				else:
-					if not self.count.has_key( count ):
+					if count not in self.count:
 						self.count[ count ] = []
 
 					self.enums[ e.value ] = [ e ]
@@ -128,7 +128,7 @@ class glx_enum_function:
 		for a in self.enums:
 			count += 1
 
-		if self.count.has_key(-1):
+		if -1 in self.count:
 			return 0
 
 		# Determine if there is some mask M, such that M = (2^N) - 1,
@@ -166,19 +166,19 @@ class glx_enum_function:
 					masked_count[i] = c
 
 
-			print '    static const GLushort a[%u] = {' % (mask + 1)
+			print('    static const GLushort a[%u] = {' % (mask + 1))
 			for e in masked_enums:
-				print '        %s, ' % (masked_enums[e])
-			print '    };'
+				print('        %s, ' % (masked_enums[e]))
+			print('    };')
 
-			print '    static const GLubyte b[%u] = {' % (mask + 1)
+			print('    static const GLubyte b[%u] = {' % (mask + 1))
 			for c in masked_count:
-				print '        %u, ' % (masked_count[c])
-			print '    };'
+				print('        %u, ' % (masked_count[c]))
+			print('    };')
 
-			print '    const unsigned idx = (e & 0x%02xU);' % (mask)
-			print ''
-			print '    return (e == a[idx]) ? (GLint) b[idx] : 0;'
+			print('    const unsigned idx = (e & 0x%02xU);' % (mask))
+			print('')
+			print('    return (e == a[idx]) ? (GLint) b[idx] : 0;')
 			return 1;
 		else:
 			return 0;
@@ -188,7 +188,7 @@ class glx_enum_function:
 		"""Emit the body of the __gl*_size function using a 
 		switch-statement."""
 
-		print '    switch( e ) {'
+		print('    switch( e ) {')
 
 		for c in self.count:
 			for e in self.count[c]:
@@ -205,35 +205,34 @@ class glx_enum_function:
 				for enum_obj in self.enums[e]:
 					list[ enum_obj.priority() ] = enum_obj.name
 
-				keys = list.keys()
-				keys.sort()
+				keys = sorted(list.keys())
 				for k in keys:
 					j = list[k]
 					if first:
-						print '        case GL_%s:' % (j)
+						print('        case GL_%s:' % (j))
 						first = 0
 					else:
-						print '/*      case GL_%s:*/' % (j)
+						print('/*      case GL_%s:*/' % (j))
 					
 			if c == -1:
-				print '            return __gl%s_variable_size( e );' % (name)
+				print('            return __gl%s_variable_size( e );' % (name))
 			else:
-				print '            return %u;' % (c)
+				print('            return %u;' % (c))
 					
-		print '        default: return 0;'
-		print '    }'
+		print('        default: return 0;')
+		print('    }')
 
 
 	def Print(self, name):
-		print 'INTERNAL PURE FASTCALL GLint'
-		print '__gl%s_size( GLenum e )' % (name)
-		print '{'
+		print('INTERNAL PURE FASTCALL GLint')
+		print('__gl%s_size( GLenum e )' % (name))
+		print('{')
 
 		if not self.PrintUsingTable():
 			self.PrintUsingSwitch(name)
 
-		print '}'
-		print ''
+		print('}')
+		print('')
 
 
 class glx_server_enum_function(glx_enum_function):
@@ -272,8 +271,7 @@ class glx_server_enum_function(glx_enum_function):
 			o = f.offset_of( param_name )
 			foo[o] = param_name
 
-		keys = foo.keys()
-		keys.sort()
+		keys = sorted(foo.keys())
 		for o in keys:
 			p = f.parameters_by_name[ foo[o] ]
 
@@ -281,18 +279,18 @@ class glx_server_enum_function(glx_enum_function):
 			fixup.append( p.name )
 
 
-		print '    GLsizei compsize;'
-		print ''
+		print('    GLsizei compsize;')
+		print('')
 
 		printer.common_emit_fixups(fixup)
 
-		print ''
-		print '    compsize = __gl%s_size(%s);' % (f.name, string.join(f.count_parameter_list, ","))
+		print('')
+		print('    compsize = __gl%s_size(%s);' % (f.name, string.join(f.count_parameter_list, ",")))
 		p = f.variable_length_parameter()
-		print '    return __GLX_PAD(%s);' % (p.size_string())
+		print('    return __GLX_PAD(%s);' % (p.size_string()))
 
-		print '}'
-		print ''
+		print('}')
+		print('')
 
 
 class PrintGlxSizeStubs_common(gl_XML.gl_print_base):
@@ -312,38 +310,38 @@ class PrintGlxSizeStubs_common(gl_XML.gl_print_base):
 
 class PrintGlxSizeStubs_c(PrintGlxSizeStubs_common):
 	def printRealHeader(self):
-		print ''
-		print '#include <GL/gl.h>'
+		print('')
+		print('#include <GL/gl.h>')
 		if self.emit_get:
-			print '#include "indirect_size_get.h"'
-			print '#include "glxserver.h"'
-			print '#include "indirect_util.h"'
+			print('#include "indirect_size_get.h"')
+			print('#include "glxserver.h"')
+			print('#include "indirect_util.h"')
 		
-		print '#include "indirect_size.h"'
+		print('#include "indirect_size.h"')
 
-		print ''
+		print('')
 		self.printPure()
-		print ''
+		print('')
 		self.printFastcall()
-		print ''
+		print('')
 		self.printVisibility( "INTERNAL", "internal" )
-		print ''
-		print ''
-		print '#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(GLX_USE_APPLEGL)'
-		print '#  undef HAVE_ALIAS'
-		print '#endif'
-		print '#ifdef HAVE_ALIAS'
-		print '#  define ALIAS2(from,to) \\'
-		print '    INTERNAL PURE FASTCALL GLint __gl ## from ## _size( GLenum e ) \\'
-		print '        __attribute__ ((alias( # to )));'
-		print '#  define ALIAS(from,to) ALIAS2( from, __gl ## to ## _size )'
-		print '#else'
-		print '#  define ALIAS(from,to) \\'
-		print '    INTERNAL PURE FASTCALL GLint __gl ## from ## _size( GLenum e ) \\'
-		print '    { return __gl ## to ## _size( e ); }'
-		print '#endif'
-		print ''
-		print ''
+		print('')
+		print('')
+		print('#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(GLX_USE_APPLEGL)')
+		print('#  undef HAVE_ALIAS')
+		print('#endif')
+		print('#ifdef HAVE_ALIAS')
+		print('#  define ALIAS2(from,to) \\')
+		print('    INTERNAL PURE FASTCALL GLint __gl ## from ## _size( GLenum e ) \\')
+		print('        __attribute__ ((alias( # to )));')
+		print('#  define ALIAS(from,to) ALIAS2( from, __gl ## to ## _size )')
+		print('#else')
+		print('#  define ALIAS(from,to) \\')
+		print('    INTERNAL PURE FASTCALL GLint __gl ## from ## _size( GLenum e ) \\')
+		print('    { return __gl ## to ## _size( e ); }')
+		print('#endif')
+		print('')
+		print('')
 
 
 	def printBody(self, api):
@@ -357,7 +355,7 @@ class PrintGlxSizeStubs_c(PrintGlxSizeStubs_common):
 
 			if (ef.is_set() and self.emit_set) or (not ef.is_set() and self.emit_get):
 				sig = ef.signature()
-				if enum_sigs.has_key( sig ):
+				if sig in enum_sigs:
 					aliases.append( [func.name, enum_sigs[ sig ]] )
 				else:
 					enum_sigs[ sig ] = func.name
@@ -365,26 +363,26 @@ class PrintGlxSizeStubs_c(PrintGlxSizeStubs_common):
 
 
 		for [alias_name, real_name] in aliases:
-			print 'ALIAS( %s, %s )' % (alias_name, real_name)
+			print('ALIAS( %s, %s )' % (alias_name, real_name))
 
 
 				
 class PrintGlxSizeStubs_h(PrintGlxSizeStubs_common):
 	def printRealHeader(self):
-		print """/**
+		print("""/**
  * \\file
  * Prototypes for functions used to determine the number of data elements in
  * various GLX protocol messages.
  *
  * \\author Ian Romanick <idr@us.ibm.com>
  */
-"""
+""")
 		self.printPure();
-		print ''
+		print('')
 		self.printFastcall();
-		print ''
+		print('')
 		self.printVisibility( "INTERNAL", "internal" );
-		print ''
+		print('')
 
 
 	def printBody(self, api):
@@ -394,7 +392,7 @@ class PrintGlxSizeStubs_h(PrintGlxSizeStubs_common):
 				continue
 
 			if (ef.is_set() and self.emit_set) or (not ef.is_set() and self.emit_get):
-				print 'extern INTERNAL PURE FASTCALL GLint __gl%s_size(GLenum);' % (func.name)
+				print('extern INTERNAL PURE FASTCALL GLint __gl%s_size(GLenum);' % (func.name))
 
 
 class PrintGlxReqSize_common(gl_XML.gl_print_base):
@@ -419,15 +417,15 @@ class PrintGlxReqSize_h(PrintGlxReqSize_common):
 
 	def printRealHeader(self):
 		self.printVisibility("HIDDEN", "hidden")
-		print ''
+		print('')
 		self.printPure()
-		print ''
+		print('')
 
 
 	def printBody(self, api):
 		for func in api.functionIterateGlx():
 			if not func.ignore and func.has_variable_size_request():
-				print 'extern PURE HIDDEN int __glX%sReqSize(const GLbyte *pc, Bool swap);' % (func.name)
+				print('extern PURE HIDDEN int __glX%sReqSize(const GLbyte *pc, Bool swap);' % (func.name))
 
 
 class PrintGlxReqSize_c(PrintGlxReqSize_common):
@@ -444,30 +442,30 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 
 
 	def printRealHeader(self):
-		print ''
-		print '#include <GL/gl.h>'
-		print '#include "glxserver.h"'
-		print '#include "glxbyteorder.h"'
-		print '#include "indirect_size.h"'
-		print '#include "indirect_reqsize.h"'
-		print ''
-		print '#define __GLX_PAD(x)  (((x) + 3) & ~3)'
-		print ''
-		print '#if defined(__CYGWIN__) || defined(__MINGW32__)'
-		print '#  undef HAVE_ALIAS'
-		print '#endif'
-		print '#ifdef HAVE_ALIAS'
-		print '#  define ALIAS2(from,to) \\'
-		print '    GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap ) \\'
-		print '        __attribute__ ((alias( # to )));'
-		print '#  define ALIAS(from,to) ALIAS2( from, __glX ## to ## ReqSize )'
-		print '#else'
-		print '#  define ALIAS(from,to) \\'
-		print '    GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap ) \\'
-		print '    { return __glX ## to ## ReqSize( pc, swap ); }'
-		print '#endif'
-		print ''
-		print ''
+		print('')
+		print('#include <GL/gl.h>')
+		print('#include "glxserver.h"')
+		print('#include "glxbyteorder.h"')
+		print('#include "indirect_size.h"')
+		print('#include "indirect_reqsize.h"')
+		print('')
+		print('#define __GLX_PAD(x)  (((x) + 3) & ~3)')
+		print('')
+		print('#if defined(__CYGWIN__) || defined(__MINGW32__)')
+		print('#  undef HAVE_ALIAS')
+		print('#endif')
+		print('#ifdef HAVE_ALIAS')
+		print('#  define ALIAS2(from,to) \\')
+		print('    GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap ) \\')
+		print('        __attribute__ ((alias( # to )));')
+		print('#  define ALIAS(from,to) ALIAS2( from, __glX ## to ## ReqSize )')
+		print('#else')
+		print('#  define ALIAS(from,to) \\')
+		print('    GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap ) \\')
+		print('    { return __glX ## to ## ReqSize( pc, swap ); }')
+		print('#endif')
+		print('')
+		print('')
 
 
 	def printBody(self, api):
@@ -483,10 +481,10 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 
 			sig = ef.signature()
 
-			if not enum_functions.has_key(func.name):
+			if func.name not in enum_functions:
 				enum_functions[ func.name ] = sig
 
-			if not enum_sigs.has_key( sig ):
+			if sig not in enum_sigs:
 				enum_sigs[ sig ] = ef
 			
 
@@ -502,7 +500,7 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 			if func.server_handcode: continue
 			if not func.has_variable_size_request(): continue
 
-			if enum_functions.has_key(func.name):
+			if func.name in enum_functions:
 				sig = enum_functions[func.name]
 				ef = enum_sigs[ sig ]
 
@@ -519,7 +517,7 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 
 
 		for [alias_name, real_name] in aliases:
-			print 'ALIAS( %s, %s )' % (alias_name, real_name)
+			print('ALIAS( %s, %s )' % (alias_name, real_name))
 
 		return
 
@@ -528,10 +526,10 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 		"""Utility function to emit conditional byte-swaps."""
 
 		if fixup:
-			print '    if (swap) {'
+			print('    if (swap) {')
 			for name in fixup:
-				print '        %s = bswap_32(%s);' % (name, name)
-			print '    }'
+				print('        %s = bswap_32(%s);' % (name, name))
+			print('    }')
 
 		return
 
@@ -540,14 +538,14 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 		offset = p.offset
 		dst = p.string()
 		src = '(%s *)' % (p.type_string())
-		print '%-18s = *%11s(%s + %u);' % (dst, src, pc, offset + adjust);
+		print('%-18s = *%11s(%s + %u);' % (dst, src, pc, offset + adjust));
 		return
 
 
 	def common_func_print_just_header(self, f):
-		print 'int'
-		print '__glX%sReqSize( const GLbyte * pc, Bool swap )' % (f.name)
-		print '{'
+		print('int')
+		print('__glX%sReqSize( const GLbyte * pc, Bool swap )' % (f.name))
+		print('{')
 
 
 	def printPixelFunction(self, f):
@@ -556,20 +554,20 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 		f.offset_of( f.parameters[0].name )
 		[dim, w, h, d, junk] = f.get_images()[0].get_dimensions()
 
-		print '    GLint row_length   = *  (GLint *)(pc +  4);'
+		print('    GLint row_length   = *  (GLint *)(pc +  4);')
 
 		if dim < 3:
 			fixup = ['row_length', 'skip_rows', 'alignment']
-			print '    GLint image_height = 0;'
-			print '    GLint skip_images  = 0;'
-			print '    GLint skip_rows    = *  (GLint *)(pc +  8);'
-			print '    GLint alignment    = *  (GLint *)(pc + 16);'
+			print('    GLint image_height = 0;')
+			print('    GLint skip_images  = 0;')
+			print('    GLint skip_rows    = *  (GLint *)(pc +  8);')
+			print('    GLint alignment    = *  (GLint *)(pc + 16);')
 		else:
 			fixup = ['row_length', 'image_height', 'skip_rows', 'skip_images', 'alignment']
-			print '    GLint image_height = *  (GLint *)(pc +  8);'
-			print '    GLint skip_rows    = *  (GLint *)(pc + 16);'
-			print '    GLint skip_images  = *  (GLint *)(pc + 20);'
-			print '    GLint alignment    = *  (GLint *)(pc + 32);'
+			print('    GLint image_height = *  (GLint *)(pc +  8);')
+			print('    GLint skip_rows    = *  (GLint *)(pc + 16);')
+			print('    GLint skip_images  = *  (GLint *)(pc + 20);')
+			print('    GLint alignment    = *  (GLint *)(pc + 32);')
 
 		img = f.images[0]
 		for p in f.parameterIterateGlxSend():
@@ -577,21 +575,21 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 				self.common_emit_one_arg(p, "pc", 0)
 				fixup.append( p.name )
 
-		print ''
+		print('')
 
 		self.common_emit_fixups(fixup)
 
 		if img.img_null_flag:
-			print ''
-			print '	   if (*(CARD32 *) (pc + %s))' % (img.offset - 4)
-			print '	       return 0;'
-
-		print ''
-		print '    return __glXImageSize(%s, %s, %s, %s, %s, %s,' % (img.img_format, img.img_type, img.img_target, w, h, d )
-		print '                          image_height, row_length, skip_images,'
-		print '                          skip_rows, alignment);'
-		print '}'
-		print ''
+			print('')
+			print('	   if (*(CARD32 *) (pc + %s))' % (img.offset - 4))
+			print('	       return 0;')
+
+		print('')
+		print('    return __glXImageSize(%s, %s, %s, %s, %s, %s,' % (img.img_format, img.img_type, img.img_target, w, h, d ))
+		print('                          image_height, row_length, skip_images,')
+		print('                          skip_rows, alignment);')
+		print('}')
+		print('')
 		return
 
 
@@ -627,7 +625,7 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 		# already be emitted, don't emit this function.  Instead, add
 		# it to the list of function aliases.
 
-		if self.counter_sigs.has_key(sig):
+		if sig in self.counter_sigs:
 			n = self.counter_sigs[sig];
 			alias = [f.name, n]
 		else:
@@ -640,24 +638,24 @@ class PrintGlxReqSize_c(PrintGlxReqSize_common):
 				self.common_emit_one_arg(p, "pc", 0)
 
 
-			print ''
+			print('')
 			self.common_emit_fixups(fixup)
-			print ''
+			print('')
 
-			print '    return __GLX_PAD(%s);' % (size)
-			print '}'
-			print ''
+			print('    return __GLX_PAD(%s);' % (size))
+			print('}')
+			print('')
 
 		return alias
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] -m output_mode [--only-get | --only-set] [--get-alias-set]" % sys.argv[0]
-	print "    -m output_mode   Output mode can be one of 'size_c' or 'size_h'."
-	print "    --only-get       Only emit 'get'-type functions."
-	print "    --only-set       Only emit 'set'-type functions."
-	print ""
-	print "By default, both 'get' and 'set'-type functions are emitted."
+	print("Usage: %s [-f input_file_name] -m output_mode [--only-get | --only-set] [--get-alias-set]" % sys.argv[0])
+	print("    -m output_mode   Output mode can be one of 'size_c' or 'size_h'.")
+	print("    --only-get       Only emit 'get'-type functions.")
+	print("    --only-set       Only emit 'set'-type functions.")
+	print("")
+	print("By default, both 'get' and 'set'-type functions are emitted.")
 	sys.exit(1)
 
 
@@ -666,14 +664,14 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:h:", ["only-get", "only-set", "header-tag"])
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	mode = None
 	header_tag = None
 	which_functions = PrintGlxSizeStubs_common.do_get | PrintGlxSizeStubs_common.do_set
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-m":
diff --git a/src/mapi/glapi/gen/glX_server_table.py b/src/mapi/glapi/gen/glX_server_table.py
index f3962f8..b792181 100644
--- a/src/mapi/glapi/gen/glX_server_table.py
+++ b/src/mapi/glapi/gen/glX_server_table.py
@@ -106,7 +106,7 @@ class function_table:
 				empty = 0
 
 				for j in range(i, i + op_count):
-					if self.functions.has_key(j):
+					if j in self.functions:
 						used += 1;
 					else:
 						empty += 1;
@@ -155,7 +155,7 @@ class function_table:
 
 	def is_empty_leaf(self, base_opcode, M):
 		for op in range(base_opcode, base_opcode + (1 << M)):
-			if self.functions.has_key(op):
+			if op in self.functions:
 				return 0
 				break
 
@@ -172,8 +172,8 @@ class function_table:
 		if children == []:
 			return
 
-		print '    /* [%u] -> opcode range [%u, %u], node depth %u */' % (base_entry, base_opcode, base_opcode + (1 << remaining_bits), depth)
-		print '    %u,' % (M)
+		print('    /* [%u] -> opcode range [%u, %u], node depth %u */' % (base_entry, base_opcode, base_opcode + (1 << remaining_bits), depth))
+		print('    %u,' % (M))
 
 		base_entry += (1 << M) + 1
 
@@ -182,7 +182,7 @@ class function_table:
 		for child in children:
 			if child[1] == []:
 				if self.is_empty_leaf(child_base_opcode, child_M):
-					print '    EMPTY_LEAF,'
+					print('    EMPTY_LEAF,')
 				else:
 					# Emit the index of the next dispatch
 					# function.  Then add all the
@@ -190,10 +190,10 @@ class function_table:
 					# node to the dispatch function
 					# lookup table.
 
-					print '    LEAF(%u),' % (len(self.lookup_table))
+					print('    LEAF(%u),' % (len(self.lookup_table)))
 
 					for op in range(child_base_opcode, child_base_opcode + (1 << child_M)):
-						if self.functions.has_key(op):
+						if op in self.functions:
 							func = self.functions[op]
 							size = func.command_fixed_length()
 
@@ -218,12 +218,12 @@ class function_table:
 
 						self.lookup_table.append(temp)
 			else:
-				print '    %u,' % (child_index)
+				print('    %u,' % (child_index))
 				child_index += child[2]
 
 			child_base_opcode += 1 << child_M
 
-		print ''
+		print('')
 
 		child_index = base_entry
 		for child in children:
@@ -278,31 +278,31 @@ class function_table:
 
 		tree = self.divide_group(0, 0)
 
-		print '/*****************************************************************/'
-		print '/* tree depth = %u */' % (tree[3])
-		print 'static const int_fast16_t %s_dispatch_tree[%u] = {' % (self.name_base, tree[2])
+		print('/*****************************************************************/')
+		print('/* tree depth = %u */' % (tree[3]))
+		print('static const int_fast16_t %s_dispatch_tree[%u] = {' % (self.name_base, tree[2]))
 		self.dump_tree(tree, 0, self.max_bits, 0, 1)
-		print '};\n'
+		print('};\n')
 		
 		# After dumping the tree, dump the function lookup table.
 		
-		print 'static const void *%s_function_table[%u][2] = {' % (self.name_base, len(self.lookup_table))
+		print('static const void *%s_function_table[%u][2] = {' % (self.name_base, len(self.lookup_table)))
 		index = 0
 		for func in self.lookup_table:
 			opcode = func[0]
 			name = func[1]
 			name_swap = func[2]
 			
-			print '    /* [% 3u] = %5u */ {%s, %s},' % (index, opcode, name, name_swap)
+			print('    /* [% 3u] = %5u */ {%s, %s},' % (index, opcode, name, name_swap))
 			
 			index += 1
 
-		print '};\n'
+		print('};\n')
 		
 		if self.do_size_check:
 			var_table = []
 
-			print 'static const int_fast16_t %s_size_table[%u][2] = {' % (self.name_base, len(self.lookup_table))
+			print('static const int_fast16_t %s_size_table[%u][2] = {' % (self.name_base, len(self.lookup_table)))
 			index = 0
 			var_table = []
 			for func in self.lookup_table:
@@ -316,31 +316,31 @@ class function_table:
 				else:
 					var_offset = "~0"
 
-				print '    /* [%3u] = %5u */ {%3u, %s},' % (index, opcode, fixed, var_offset)
+				print('    /* [%3u] = %5u */ {%3u, %s},' % (index, opcode, fixed, var_offset))
 				index += 1
 
 				
-			print '};\n'
+			print('};\n')
 
 
-			print 'static const gl_proto_size_func %s_size_func_table[%u] = {' % (self.name_base, len(var_table))
+			print('static const gl_proto_size_func %s_size_func_table[%u] = {' % (self.name_base, len(var_table)))
 			for func in var_table:
-				print '   %s,' % (func)
+				print('   %s,' % (func))
  
-			print '};\n'
+			print('};\n')
 
 
-		print 'const struct __glXDispatchInfo %s_dispatch_info = {' % (self.name_base)
-		print '    %u,' % (self.max_bits)
-		print '    %s_dispatch_tree,' % (self.name_base)
-		print '    %s_function_table,' % (self.name_base)
+		print('const struct __glXDispatchInfo %s_dispatch_info = {' % (self.name_base))
+		print('    %u,' % (self.max_bits))
+		print('    %s_dispatch_tree,' % (self.name_base))
+		print('    %s_function_table,' % (self.name_base))
 		if self.do_size_check:
-			print '    %s_size_table,' % (self.name_base)
-			print '    %s_size_func_table' % (self.name_base)
+			print('    %s_size_table,' % (self.name_base))
+			print('    %s_size_func_table' % (self.name_base))
 		else:
-			print '    NULL,'
-			print '    NULL'
-		print '};\n'
+			print('    NULL,')
+			print('    NULL')
+		print('};\n')
 		return
 
 
@@ -357,14 +357,14 @@ class PrintGlxDispatchTables(glX_proto_common.glx_print_proto):
 
 
 	def printRealHeader(self):
-		print '#include <inttypes.h>'
-		print '#include "glxserver.h"'
-		print '#include "glxext.h"'
-		print '#include "indirect_dispatch.h"'
-		print '#include "indirect_reqsize.h"'
-		print '#include "g_disptab.h"'
-		print '#include "indirect_table.h"'
-		print ''
+		print('#include <inttypes.h>')
+		print('#include "glxserver.h"')
+		print('#include "glxext.h"')
+		print('#include "indirect_dispatch.h"')
+		print('#include "indirect_reqsize.h"')
+		print('#include "g_disptab.h"')
+		print('#include "indirect_table.h"')
+		print('')
 		return
 
 
@@ -389,11 +389,11 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	mode = "table_c"
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-m":
diff --git a/src/mapi/glapi/gen/gl_SPARC_asm.py b/src/mapi/glapi/gen/gl_SPARC_asm.py
index 400e684..8ce63bb 100644
--- a/src/mapi/glapi/gen/gl_SPARC_asm.py
+++ b/src/mapi/glapi/gen/gl_SPARC_asm.py
@@ -39,192 +39,192 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print '#ifdef __arch64__'
-		print '#define GL_OFF(N)\t((N) * 8)'
-		print '#define GL_LL\t\tldx'
-		print '#define GL_TIE_LD(SYM)\t%tie_ldx(SYM)'
-		print '#define GL_STACK_SIZE\t128'
-		print '#else'
-		print '#define GL_OFF(N)\t((N) * 4)'
-		print '#define GL_LL\t\tld'
-		print '#define GL_TIE_LD(SYM)\t%tie_ld(SYM)'
-		print '#define GL_STACK_SIZE\t64'
-		print '#endif'
-		print ''
-		print '#define GLOBL_FN(x) .globl x ; .type x, @function'
-		print '#define HIDDEN(x) .hidden x'
-		print ''
-		print '\t.register %g2, #scratch'
-		print '\t.register %g3, #scratch'
-		print ''
-		print '\t.text'
-		print ''
-		print '\tGLOBL_FN(__glapi_sparc_icache_flush)'
-		print '\tHIDDEN(__glapi_sparc_icache_flush)'
-		print '\t.type\t__glapi_sparc_icache_flush, @function'
-		print '__glapi_sparc_icache_flush: /* %o0 = insn_addr */'
-		print '\tflush\t%o0'
-		print '\tretl'
-		print '\t nop'
-		print ''
-		print '\t.align\t32'
-		print ''
-		print '\t.type\t__glapi_sparc_get_pc, @function'
-		print '__glapi_sparc_get_pc:'
-		print '\tretl'
-		print '\t add\t%o7, %g2, %g2'
-		print '\t.size\t__glapi_sparc_get_pc, .-__glapi_sparc_get_pc'
-		print ''
-		print '#ifdef GLX_USE_TLS'
-		print ''
-		print '\tGLOBL_FN(__glapi_sparc_get_dispatch)'
-		print '\tHIDDEN(__glapi_sparc_get_dispatch)'
-		print '__glapi_sparc_get_dispatch:'
-		print '\tmov\t%o7, %g1'
-		print '\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2'
-		print '\tcall\t__glapi_sparc_get_pc'
-		print '\tadd\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2'
-		print '\tmov\t%g1, %o7'
-		print '\tsethi\t%tie_hi22(_glapi_tls_Dispatch), %g1'
-		print '\tadd\t%g1, %tie_lo10(_glapi_tls_Dispatch), %g1'
-		print '\tGL_LL\t[%g2 + %g1], %g2, GL_TIE_LD(_glapi_tls_Dispatch)'
-		print '\tretl'
-		print '\t mov\t%g2, %o0'
-		print ''
-		print '\t.data'
-		print '\t.align\t32'
-		print ''
-		print '\t/* --> sethi %hi(_glapi_tls_Dispatch), %g1 */'
-		print '\t/* --> or %g1, %lo(_glapi_tls_Dispatch), %g1 */'
-		print '\tGLOBL_FN(__glapi_sparc_tls_stub)'
-		print '\tHIDDEN(__glapi_sparc_tls_stub)'
-		print '__glapi_sparc_tls_stub: /* Call offset in %g3 */'
-		print '\tmov\t%o7, %g1'
-		print '\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2'
-		print '\tcall\t__glapi_sparc_get_pc'
-		print '\tadd\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2'
-		print '\tmov\t%g1, %o7'
-		print '\tsrl\t%g3, 10, %g3'
-		print '\tsethi\t%tie_hi22(_glapi_tls_Dispatch), %g1'
-		print '\tadd\t%g1, %tie_lo10(_glapi_tls_Dispatch), %g1'
-		print '\tGL_LL\t[%g2 + %g1], %g2, GL_TIE_LD(_glapi_tls_Dispatch)'
-		print '\tGL_LL\t[%g7+%g2], %g1'
-		print '\tGL_LL\t[%g1 + %g3], %g1'
-		print '\tjmp\t%g1'
-		print '\t nop'
-		print '\t.size\t__glapi_sparc_tls_stub, .-__glapi_sparc_tls_stub'
-		print ''
-		print '#define GL_STUB(fn, off)\t\t\t\t\\'
-		print '\tGLOBL_FN(fn);\t\t\t\t\t\\'
-		print 'fn:\tba\t__glapi_sparc_tls_stub;\t\t\t\\'
-		print '\t sethi\tGL_OFF(off), %g3;\t\t\t\\'
-		print '\t.size\tfn,.-fn;'
-		print ''
-		print '#elif defined(PTHREADS)'
-		print ''
-		print '\t/* 64-bit 0x00 --> sethi %hh(_glapi_Dispatch), %g1 */'
-		print '\t/* 64-bit 0x04 --> sethi %lm(_glapi_Dispatch), %g2 */'
-		print '\t/* 64-bit 0x08 --> or %g1, %hm(_glapi_Dispatch), %g1 */'
-		print '\t/* 64-bit 0x0c --> sllx %g1, 32, %g1 */'
-		print '\t/* 64-bit 0x10 --> add %g1, %g2, %g1 */'
-		print '\t/* 64-bit 0x14 --> ldx [%g1 + %lo(_glapi_Dispatch)], %g1 */'
-		print ''
-		print '\t/* 32-bit 0x00 --> sethi %hi(_glapi_Dispatch), %g1 */'
-		print '\t/* 32-bit 0x04 --> ld [%g1 + %lo(_glapi_Dispatch)], %g1 */'
-		print ''
-		print '\t.data'
-		print '\t.align\t32'
-		print ''
-		print '\tGLOBL_FN(__glapi_sparc_pthread_stub)'
-		print '\tHIDDEN(__glapi_sparc_pthread_stub)'
-		print '__glapi_sparc_pthread_stub: /* Call offset in %g3 */'
-		print '\tmov\t%o7, %g1'
-		print '\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2'
-		print '\tcall\t__glapi_sparc_get_pc'
-		print '\t add\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2'
-		print '\tmov\t%g1, %o7'
-		print '\tsethi\t%hi(_glapi_Dispatch), %g1'
-		print '\tor\t%g1, %lo(_glapi_Dispatch), %g1'
-		print '\tsrl\t%g3, 10, %g3'
-		print '\tGL_LL\t[%g2+%g1], %g2'
-		print '\tGL_LL\t[%g2], %g1'
-		print '\tcmp\t%g1, 0'
-		print '\tbe\t2f'
-		print '\t nop'
-		print '1:\tGL_LL\t[%g1 + %g3], %g1'
-		print '\tjmp\t%g1'
-		print '\t nop'
-		print '2:\tsave\t%sp, GL_STACK_SIZE, %sp'
-		print '\tmov\t%g3, %l0'
-		print '\tcall\t_glapi_get_dispatch'
-		print '\t nop'
-		print '\tmov\t%o0, %g1'
-		print '\tmov\t%l0, %g3'
-		print '\tba\t1b'
-		print '\t restore %g0, %g0, %g0'
-		print '\t.size\t__glapi_sparc_pthread_stub, .-__glapi_sparc_pthread_stub'
-		print ''
-		print '#define GL_STUB(fn, off)\t\t\t\\'
-		print '\tGLOBL_FN(fn);\t\t\t\t\\'
-		print 'fn:\tba\t__glapi_sparc_pthread_stub;\t\\'
-		print '\t sethi\tGL_OFF(off), %g3;\t\t\\'
-		print '\t.size\tfn,.-fn;'
-		print ''
-		print '#else /* Non-threaded version. */'
-		print ''
-		print '\t.type	__glapi_sparc_nothread_stub, @function'
-		print '__glapi_sparc_nothread_stub: /* Call offset in %g3 */'
-		print '\tmov\t%o7, %g1'
-		print '\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2'
-		print '\tcall\t__glapi_sparc_get_pc'
-		print '\t add\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2'
-		print '\tmov\t%g1, %o7'
-		print '\tsrl\t%g3, 10, %g3'
-		print '\tsethi\t%hi(_glapi_Dispatch), %g1'
-		print '\tor\t%g1, %lo(_glapi_Dispatch), %g1'
-		print '\tGL_LL\t[%g2+%g1], %g2'
-		print '\tGL_LL\t[%g2], %g1'
-		print '\tGL_LL\t[%g1 + %g3], %g1'
-		print '\tjmp\t%g1'
-		print '\t nop'
-		print '\t.size\t__glapi_sparc_nothread_stub, .-__glapi_sparc_nothread_stub'
-		print ''
-		print '#define GL_STUB(fn, off)\t\t\t\\'
-		print '\tGLOBL_FN(fn);\t\t\t\t\\'
-		print 'fn:\tba\t__glapi_sparc_nothread_stub;\t\\'
-		print '\t sethi\tGL_OFF(off), %g3;\t\t\\'
-		print '\t.size\tfn,.-fn;'
-		print ''
-		print '#endif'
-		print ''
-		print '#define GL_STUB_ALIAS(fn, alias)		\\'
-		print '	.globl	fn;				\\'
-		print '	.set	fn, alias'
-		print ''
-		print '\t.text'
-		print '\t.align\t32'
-		print ''
-		print '\t.globl\tgl_dispatch_functions_start'
-		print '\tHIDDEN(gl_dispatch_functions_start)'
-		print 'gl_dispatch_functions_start:'
-		print ''
+		print('#ifdef __arch64__')
+		print('#define GL_OFF(N)\t((N) * 8)')
+		print('#define GL_LL\t\tldx')
+		print('#define GL_TIE_LD(SYM)\t%tie_ldx(SYM)')
+		print('#define GL_STACK_SIZE\t128')
+		print('#else')
+		print('#define GL_OFF(N)\t((N) * 4)')
+		print('#define GL_LL\t\tld')
+		print('#define GL_TIE_LD(SYM)\t%tie_ld(SYM)')
+		print('#define GL_STACK_SIZE\t64')
+		print('#endif')
+		print('')
+		print('#define GLOBL_FN(x) .globl x ; .type x, @function')
+		print('#define HIDDEN(x) .hidden x')
+		print('')
+		print('\t.register %g2, #scratch')
+		print('\t.register %g3, #scratch')
+		print('')
+		print('\t.text')
+		print('')
+		print('\tGLOBL_FN(__glapi_sparc_icache_flush)')
+		print('\tHIDDEN(__glapi_sparc_icache_flush)')
+		print('\t.type\t__glapi_sparc_icache_flush, @function')
+		print('__glapi_sparc_icache_flush: /* %o0 = insn_addr */')
+		print('\tflush\t%o0')
+		print('\tretl')
+		print('\t nop')
+		print('')
+		print('\t.align\t32')
+		print('')
+		print('\t.type\t__glapi_sparc_get_pc, @function')
+		print('__glapi_sparc_get_pc:')
+		print('\tretl')
+		print('\t add\t%o7, %g2, %g2')
+		print('\t.size\t__glapi_sparc_get_pc, .-__glapi_sparc_get_pc')
+		print('')
+		print('#ifdef GLX_USE_TLS')
+		print('')
+		print('\tGLOBL_FN(__glapi_sparc_get_dispatch)')
+		print('\tHIDDEN(__glapi_sparc_get_dispatch)')
+		print('__glapi_sparc_get_dispatch:')
+		print('\tmov\t%o7, %g1')
+		print('\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2')
+		print('\tcall\t__glapi_sparc_get_pc')
+		print('\tadd\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2')
+		print('\tmov\t%g1, %o7')
+		print('\tsethi\t%tie_hi22(_glapi_tls_Dispatch), %g1')
+		print('\tadd\t%g1, %tie_lo10(_glapi_tls_Dispatch), %g1')
+		print('\tGL_LL\t[%g2 + %g1], %g2, GL_TIE_LD(_glapi_tls_Dispatch)')
+		print('\tretl')
+		print('\t mov\t%g2, %o0')
+		print('')
+		print('\t.data')
+		print('\t.align\t32')
+		print('')
+		print('\t/* --> sethi %hi(_glapi_tls_Dispatch), %g1 */')
+		print('\t/* --> or %g1, %lo(_glapi_tls_Dispatch), %g1 */')
+		print('\tGLOBL_FN(__glapi_sparc_tls_stub)')
+		print('\tHIDDEN(__glapi_sparc_tls_stub)')
+		print('__glapi_sparc_tls_stub: /* Call offset in %g3 */')
+		print('\tmov\t%o7, %g1')
+		print('\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2')
+		print('\tcall\t__glapi_sparc_get_pc')
+		print('\tadd\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2')
+		print('\tmov\t%g1, %o7')
+		print('\tsrl\t%g3, 10, %g3')
+		print('\tsethi\t%tie_hi22(_glapi_tls_Dispatch), %g1')
+		print('\tadd\t%g1, %tie_lo10(_glapi_tls_Dispatch), %g1')
+		print('\tGL_LL\t[%g2 + %g1], %g2, GL_TIE_LD(_glapi_tls_Dispatch)')
+		print('\tGL_LL\t[%g7+%g2], %g1')
+		print('\tGL_LL\t[%g1 + %g3], %g1')
+		print('\tjmp\t%g1')
+		print('\t nop')
+		print('\t.size\t__glapi_sparc_tls_stub, .-__glapi_sparc_tls_stub')
+		print('')
+		print('#define GL_STUB(fn, off)\t\t\t\t\\')
+		print('\tGLOBL_FN(fn);\t\t\t\t\t\\')
+		print('fn:\tba\t__glapi_sparc_tls_stub;\t\t\t\\')
+		print('\t sethi\tGL_OFF(off), %g3;\t\t\t\\')
+		print('\t.size\tfn,.-fn;')
+		print('')
+		print('#elif defined(PTHREADS)')
+		print('')
+		print('\t/* 64-bit 0x00 --> sethi %hh(_glapi_Dispatch), %g1 */')
+		print('\t/* 64-bit 0x04 --> sethi %lm(_glapi_Dispatch), %g2 */')
+		print('\t/* 64-bit 0x08 --> or %g1, %hm(_glapi_Dispatch), %g1 */')
+		print('\t/* 64-bit 0x0c --> sllx %g1, 32, %g1 */')
+		print('\t/* 64-bit 0x10 --> add %g1, %g2, %g1 */')
+		print('\t/* 64-bit 0x14 --> ldx [%g1 + %lo(_glapi_Dispatch)], %g1 */')
+		print('')
+		print('\t/* 32-bit 0x00 --> sethi %hi(_glapi_Dispatch), %g1 */')
+		print('\t/* 32-bit 0x04 --> ld [%g1 + %lo(_glapi_Dispatch)], %g1 */')
+		print('')
+		print('\t.data')
+		print('\t.align\t32')
+		print('')
+		print('\tGLOBL_FN(__glapi_sparc_pthread_stub)')
+		print('\tHIDDEN(__glapi_sparc_pthread_stub)')
+		print('__glapi_sparc_pthread_stub: /* Call offset in %g3 */')
+		print('\tmov\t%o7, %g1')
+		print('\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2')
+		print('\tcall\t__glapi_sparc_get_pc')
+		print('\t add\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2')
+		print('\tmov\t%g1, %o7')
+		print('\tsethi\t%hi(_glapi_Dispatch), %g1')
+		print('\tor\t%g1, %lo(_glapi_Dispatch), %g1')
+		print('\tsrl\t%g3, 10, %g3')
+		print('\tGL_LL\t[%g2+%g1], %g2')
+		print('\tGL_LL\t[%g2], %g1')
+		print('\tcmp\t%g1, 0')
+		print('\tbe\t2f')
+		print('\t nop')
+		print('1:\tGL_LL\t[%g1 + %g3], %g1')
+		print('\tjmp\t%g1')
+		print('\t nop')
+		print('2:\tsave\t%sp, GL_STACK_SIZE, %sp')
+		print('\tmov\t%g3, %l0')
+		print('\tcall\t_glapi_get_dispatch')
+		print('\t nop')
+		print('\tmov\t%o0, %g1')
+		print('\tmov\t%l0, %g3')
+		print('\tba\t1b')
+		print('\t restore %g0, %g0, %g0')
+		print('\t.size\t__glapi_sparc_pthread_stub, .-__glapi_sparc_pthread_stub')
+		print('')
+		print('#define GL_STUB(fn, off)\t\t\t\\')
+		print('\tGLOBL_FN(fn);\t\t\t\t\\')
+		print('fn:\tba\t__glapi_sparc_pthread_stub;\t\\')
+		print('\t sethi\tGL_OFF(off), %g3;\t\t\\')
+		print('\t.size\tfn,.-fn;')
+		print('')
+		print('#else /* Non-threaded version. */')
+		print('')
+		print('\t.type	__glapi_sparc_nothread_stub, @function')
+		print('__glapi_sparc_nothread_stub: /* Call offset in %g3 */')
+		print('\tmov\t%o7, %g1')
+		print('\tsethi\t%hi(_GLOBAL_OFFSET_TABLE_-4), %g2')
+		print('\tcall\t__glapi_sparc_get_pc')
+		print('\t add\t%g2, %lo(_GLOBAL_OFFSET_TABLE_+4), %g2')
+		print('\tmov\t%g1, %o7')
+		print('\tsrl\t%g3, 10, %g3')
+		print('\tsethi\t%hi(_glapi_Dispatch), %g1')
+		print('\tor\t%g1, %lo(_glapi_Dispatch), %g1')
+		print('\tGL_LL\t[%g2+%g1], %g2')
+		print('\tGL_LL\t[%g2], %g1')
+		print('\tGL_LL\t[%g1 + %g3], %g1')
+		print('\tjmp\t%g1')
+		print('\t nop')
+		print('\t.size\t__glapi_sparc_nothread_stub, .-__glapi_sparc_nothread_stub')
+		print('')
+		print('#define GL_STUB(fn, off)\t\t\t\\')
+		print('\tGLOBL_FN(fn);\t\t\t\t\\')
+		print('fn:\tba\t__glapi_sparc_nothread_stub;\t\\')
+		print('\t sethi\tGL_OFF(off), %g3;\t\t\\')
+		print('\t.size\tfn,.-fn;')
+		print('')
+		print('#endif')
+		print('')
+		print('#define GL_STUB_ALIAS(fn, alias)		\\')
+		print('	.globl	fn;				\\')
+		print('	.set	fn, alias')
+		print('')
+		print('\t.text')
+		print('\t.align\t32')
+		print('')
+		print('\t.globl\tgl_dispatch_functions_start')
+		print('\tHIDDEN(gl_dispatch_functions_start)')
+		print('gl_dispatch_functions_start:')
+		print('')
 		return
 
 	def printRealFooter(self):
-		print ''
-		print '\t.globl\tgl_dispatch_functions_end'
-		print '\tHIDDEN(gl_dispatch_functions_end)'
-		print 'gl_dispatch_functions_end:'
+		print('')
+		print('\t.globl\tgl_dispatch_functions_end')
+		print('\tHIDDEN(gl_dispatch_functions_end)')
+		print('gl_dispatch_functions_end:')
 		return
 
 	def printBody(self, api):
 		for f in api.functionIterateByOffset():
 			name = f.dispatch_name()
 
-			print '\tGL_STUB(gl%s, %d)' % (name, f.offset)
+			print('\tGL_STUB(gl%s, %d)' % (name, f.offset))
 
 			if not f.is_static_entry_point(f.name):
-				print '\tHIDDEN(gl%s)' % (name)
+				print('\tHIDDEN(gl%s)' % (name))
 
 		for f in api.functionIterateByOffset():
 			name = f.dispatch_name()
@@ -235,17 +235,17 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 						text = '\tGL_STUB_ALIAS(gl%s, gl%s)' % (n, f.name)
 
 						if f.has_different_protocol(n):
-							print '#ifndef GLX_INDIRECT_RENDERING'
-							print text
-							print '#endif'
+							print('#ifndef GLX_INDIRECT_RENDERING')
+							print(text)
+							print('#endif')
 						else:
-							print text
+							print(text)
 
 		return
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0]
+	print("Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0])
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -254,10 +254,10 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "m:f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == '-m':
 			mode = val
 		elif arg == "-f":
@@ -266,7 +266,7 @@ if __name__ == '__main__':
 	if mode == "generic":
 		printer = PrintGenericStubs()
 	else:
-		print "ERROR: Invalid mode \"%s\" specified." % mode
+		print("ERROR: Invalid mode \"%s\" specified." % mode)
 		show_usage()
 
 	api = gl_XML.parse_GL_API(file_name, glX_XML.glx_item_factory())
diff --git a/src/mapi/glapi/gen/gl_XML.py b/src/mapi/glapi/gen/gl_XML.py
index 4d414e8..f76e1b2 100644
--- a/src/mapi/glapi/gen/gl_XML.py
+++ b/src/mapi/glapi/gen/gl_XML.py
@@ -127,17 +127,17 @@ class gl_print_base:
 	def printHeader(self):
 		"""Print the header associated with all files and call the printRealHeader method."""
 
-		print '/* DO NOT EDIT - This file generated automatically by %s script */' \
-			% (self.name)
-		print ''
-		print '/*'
-		print ' * ' + self.license.replace('\n', '\n * ')
-		print ' */'
-		print ''
+		print('/* DO NOT EDIT - This file generated automatically by %s script */' \
+			% (self.name))
+		print('')
+		print('/*')
+		print(' * ' + self.license.replace('\n', '\n * '))
+		print(' */')
+		print('')
 		if self.header_tag:
-		    print '#if !defined( %s )' % (self.header_tag)
-		    print '#  define %s' % (self.header_tag)
-		    print ''
+		    print('#if !defined( %s )' % (self.header_tag))
+		    print('#  define %s' % (self.header_tag))
+		    print('')
 		self.printRealHeader();
 		return
 
@@ -148,13 +148,13 @@ class gl_print_base:
 		self.printRealFooter()
 
 		if self.undef_list:
-			print ''
+			print('')
 			for u in self.undef_list:
-				print "#  undef %s" % (u)
+				print("#  undef %s" % (u))
 
 		if self.header_tag:
-			print ''
-			print '#endif /* !defined( %s ) */' % (self.header_tag)
+			print('')
+			print('#endif /* !defined( %s ) */' % (self.header_tag))
 
 
 	def printRealHeader(self):
@@ -184,11 +184,11 @@ class gl_print_base:
 		The name is also added to the file's undef_list.
 		"""
 		self.undef_list.append("PURE")
-		print """#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+		print("""#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
 #    define PURE __attribute__((pure))
 #  else
 #    define PURE
-#  endif"""
+#  endif""")
 		return
 
 
@@ -204,11 +204,11 @@ class gl_print_base:
 		"""
 
 		self.undef_list.append("FASTCALL")
-		print """#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+		print("""#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
 #    define FASTCALL __attribute__((fastcall))
 #  else
 #    define FASTCALL
-#  endif"""
+#  endif""")
 		return
 
 
@@ -224,11 +224,11 @@ class gl_print_base:
 		"""
 
 		self.undef_list.append(S)
-		print """#  if (defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590) && defined(__ELF__))
+		print("""#  if (defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590) && defined(__ELF__))
 #    define %s  __attribute__((visibility("%s")))
 #  else
 #    define %s
-#  endif""" % (S, s, S)
+#  endif""" % (S, s, S))
 		return
 
 
@@ -244,11 +244,11 @@ class gl_print_base:
 		"""
 
 		self.undef_list.append("NOINLINE")
-		print """#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+		print("""#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
 #    define NOINLINE __attribute__((noinline))
 #  else
 #    define NOINLINE
-#  endif"""
+#  endif""")
 		return
 
 
@@ -283,7 +283,7 @@ def classify_category(name, number):
 
 	try:
 		core_version = float(name)
-	except Exception,e:
+	except Exception as e:
 		core_version = 0.0
 
 	if core_version > 0.0:
@@ -319,7 +319,7 @@ def create_parameter_string(parameters, include_names):
 
 	if len(list) == 0: list = ["void"]
 
-	return string.join(list, ", ")
+	return ", ".join(list)
 
 
 class gl_item:
@@ -362,7 +362,7 @@ class gl_enum( gl_item ):
 		else:
 			try:
 				c = int(temp)
-			except Exception,e:
+			except Exception as e:
 				raise RuntimeError('Invalid count value "%s" for enum "%s" in function "%s" when an integer was expected.' % (temp, self.name, n))
 
 			self.default_count = c
@@ -423,7 +423,7 @@ class gl_parameter:
 			count = int(c)
 			self.count = count
 			self.counter = None
-		except Exception,e:
+		except Exception as e:
 			count = 1
 			self.count = 0
 			self.counter = c
@@ -575,9 +575,9 @@ class gl_parameter:
 				list.append( str(s) )
 
 			if len(list) > 1 and use_parens :
-				return "(%s)" % (string.join(list, " * "))
+				return "(%s)" % (" * ".join(list))
 			else:
-				return string.join(list, " * ")
+				return " * ".join(list)
 
 		elif self.is_image():
 			return "compsize"
@@ -646,7 +646,7 @@ class gl_function( gl_item ):
 				try:
 					o = int( offset )
 					self.offset = o
-				except Exception, e:
+				except Exception as e:
 					self.offset = -1
 					if offset == "assign":
 						self.assign_offset = 1
@@ -832,7 +832,7 @@ class gl_api:
 					temp_name = child.nsProp( "name", None )
 					self.category_dict[ temp_name ] = [cat_name, cat_number]
 
-					if self.functions_by_name.has_key( func_name ):
+					if func_name in self.functions_by_name:
 						func = self.functions_by_name[ func_name ]
 						func.process_element( child )
 					else:
@@ -872,20 +872,18 @@ class gl_api:
 			if (cat == None) or (cat == cat_name):
 				[func_cat_type, key] = classify_category(cat_name, cat_number)
 
-				if not lists[func_cat_type].has_key(key):
+				if key not in lists[func_cat_type]:
 					lists[func_cat_type][key] = {}
 
 				lists[func_cat_type][key][func.name] = func
 
 
 		functions = []
-		for func_cat_type in range(0,4):
-			keys = lists[func_cat_type].keys()
-			keys.sort()
+		for func_cat_type in range(0, 4):
+			keys = sorted(lists[func_cat_type].keys())
 
 			for key in keys:
-				names = lists[func_cat_type][key].keys()
-				names.sort()
+				names = sorted(lists[func_cat_type][key].keys())
 
 				for name in names:
 					functions.append(lists[func_cat_type][key][name])
@@ -895,13 +893,13 @@ class gl_api:
 
 	def functionIterateByOffset(self):
 		max_offset = -1
-		for func in self.functions_by_name.itervalues():
+		for func in self.functions_by_name.values():
 			if func.offset > max_offset:
 				max_offset = func.offset
 
 
 		temp = [None for i in range(0, max_offset + 1)]
-		for func in self.functions_by_name.itervalues():
+		for func in self.functions_by_name.values():
 			if func.offset != -1:
 				temp[ func.offset ] = func
 
@@ -915,12 +913,11 @@ class gl_api:
 
 
 	def functionIterateAll(self):
-		return self.functions_by_name.itervalues()
+		return iter(self.functions_by_name.values())
 
 
 	def enumIterateByName(self):
-		keys = self.enums_by_name.keys()
-		keys.sort()
+		keys = sorted(self.enums_by_name.keys())
 		
 		list = []
 		for enum in keys:
@@ -938,9 +935,8 @@ class gl_api:
 		"""
 
 		list = []
-		for cat_type in range(0,4):
-			keys = self.categories[cat_type].keys()
-			keys.sort()
+		for cat_type in range(0, 4):
+			keys = sorted(self.categories[cat_type].keys())
 			
 			for key in keys:
 				list.append(self.categories[cat_type][key])
@@ -949,19 +945,19 @@ class gl_api:
 
 
 	def get_category_for_name( self, name ):
-		if self.category_dict.has_key(name):
+		if name in self.category_dict:
 			return self.category_dict[name]
 		else:
 			return ["<unknown category>", None]
 
 
 	def typeIterate(self):
-		return self.types_by_name.itervalues()
+		return iter(self.types_by_name.values())
 
 
 	def find_type( self, type_name ):
 		if type_name in self.types_by_name:
 			return self.types_by_name[ type_name ].type_expr
 		else:
-			print "Unable to find base type matching \"%s\"." % (type_name)
+			print("Unable to find base type matching \"%s\"." % (type_name))
 			return None
diff --git a/src/mapi/glapi/gen/gl_apitemp.py b/src/mapi/glapi/gen/gl_apitemp.py
index 41a40fb..1630270 100644
--- a/src/mapi/glapi/gen/gl_apitemp.py
+++ b/src/mapi/glapi/gen/gl_apitemp.py
@@ -92,25 +92,25 @@ class PrintGlOffsets(gl_XML.gl_print_base):
 			if (cat.startswith("es") or cat.startswith("GL_OES")):
 				need_proto = True
 		if need_proto:
-			print '%s %s KEYWORD2 NAME(%s)(%s);' % (keyword, f.return_type, n, f.get_parameter_string(name))
-			print ''
+			print('%s %s KEYWORD2 NAME(%s)(%s);' % (keyword, f.return_type, n, f.get_parameter_string(name)))
+			print('')
 
-		print '%s %s KEYWORD2 NAME(%s)(%s)' % (keyword, f.return_type, n, f.get_parameter_string(name))
-		print '{'
+		print('%s %s KEYWORD2 NAME(%s)(%s)' % (keyword, f.return_type, n, f.get_parameter_string(name)))
+		print('{')
 		if p_string == "":
-			print '   %s(%s, (), (F, "gl%s();\\n"));' \
-				% (dispatch, f.name, name)
+			print('   %s(%s, (), (F, "gl%s();\\n"));' \
+				% (dispatch, f.name, name))
 		else:
-			print '   %s(%s, (%s), (F, "gl%s(%s);\\n", %s));' \
-				% (dispatch, f.name, p_string, name, t_string, o_string)
-		print '}'
-		print ''
+			print('   %s(%s, (%s), (F, "gl%s(%s);\\n", %s));' \
+				% (dispatch, f.name, p_string, name, t_string, o_string))
+		print('}')
+		print('')
 		return
 
 	def printRealHeader(self):
-		print ''
+		print('')
 		self.printVisibility( "HIDDEN", "hidden" )
-		print """
+		print("""
 /*
  * This file is a template which generates the OpenGL API entry point
  * functions.  It should be included by a .c file which first defines
@@ -157,13 +157,13 @@ class PrintGlOffsets(gl_XML.gl_print_base):
 #error RETURN_DISPATCH must be defined
 #endif
 
-"""
+""")
 		return
 
     
 
 	def printInitDispatch(self, api):
-		print """
+		print("""
 #endif /* defined( NAME ) */
 
 /*
@@ -180,31 +180,31 @@ class PrintGlOffsets(gl_XML.gl_print_base):
 #error _GLAPI_SKIP_NORMAL_ENTRY_POINTS must not be defined
 #endif
 
-_glapi_proc DISPATCH_TABLE_NAME[] = {"""
+_glapi_proc DISPATCH_TABLE_NAME[] = {""")
 		for f in api.functionIterateByOffset():
-			print '   TABLE_ENTRY(%s),' % (f.dispatch_name())
+			print('   TABLE_ENTRY(%s),' % (f.dispatch_name()))
 
-		print '   /* A whole bunch of no-op functions.  These might be called'
-		print '    * when someone tries to call a dynamically-registered'
-		print '    * extension function without a current rendering context.'
-		print '    */'
+		print('   /* A whole bunch of no-op functions.  These might be called')
+		print('    * when someone tries to call a dynamically-registered')
+		print('    * extension function without a current rendering context.')
+		print('    */')
 		for i in range(1, 100):
-			print '   TABLE_ENTRY(Unused),'
+			print('   TABLE_ENTRY(Unused),')
 
-		print '};'
-		print '#endif /* DISPATCH_TABLE_NAME */'
-		print ''
+		print('};')
+		print('#endif /* DISPATCH_TABLE_NAME */')
+		print('')
 		return
 
 
 	def printAliasedTable(self, api):
-		print """
+		print("""
 /*
  * This is just used to silence compiler warnings.
  * We list the functions which are not otherwise used.
  */
 #ifdef UNUSED_TABLE_NAME
-_glapi_proc UNUSED_TABLE_NAME[] = {"""
+_glapi_proc UNUSED_TABLE_NAME[] = {""")
 
 		normal_entries = []
 		proto_entries = []
@@ -223,18 +223,18 @@ _glapi_proc UNUSED_TABLE_NAME[] = {"""
 			normal_entries.extend(normal_ents)
 			proto_entries.extend(proto_ents)
 
-		print '#ifndef _GLAPI_SKIP_NORMAL_ENTRY_POINTS'
+		print('#ifndef _GLAPI_SKIP_NORMAL_ENTRY_POINTS')
 		for ent in normal_entries:
-			print '   TABLE_ENTRY(%s),' % (ent)
-		print '#endif /* _GLAPI_SKIP_NORMAL_ENTRY_POINTS */'
-		print '#ifndef _GLAPI_SKIP_PROTO_ENTRY_POINTS'
+			print('   TABLE_ENTRY(%s),' % (ent))
+		print('#endif /* _GLAPI_SKIP_NORMAL_ENTRY_POINTS */')
+		print('#ifndef _GLAPI_SKIP_PROTO_ENTRY_POINTS')
 		for ent in proto_entries:
-			print '   TABLE_ENTRY(%s),' % (ent)
-		print '#endif /* _GLAPI_SKIP_PROTO_ENTRY_POINTS */'
+			print('   TABLE_ENTRY(%s),' % (ent))
+		print('#endif /* _GLAPI_SKIP_PROTO_ENTRY_POINTS */')
 
-		print '};'
-		print '#endif /*UNUSED_TABLE_NAME*/'
-		print ''
+		print('};')
+		print('#endif /*UNUSED_TABLE_NAME*/')
+		print('')
 		return
 
 
@@ -271,23 +271,23 @@ _glapi_proc UNUSED_TABLE_NAME[] = {"""
 			normal_entry_points.append((func, normal_ents))
 			proto_entry_points.append((func, proto_ents))
 
-		print '#ifndef _GLAPI_SKIP_NORMAL_ENTRY_POINTS'
-		print ''
+		print('#ifndef _GLAPI_SKIP_NORMAL_ENTRY_POINTS')
+		print('')
 		for func, ents in normal_entry_points:
 			for ent in ents:
 				self.printFunction(func, ent)
-		print ''
-		print '#endif /* _GLAPI_SKIP_NORMAL_ENTRY_POINTS */'
-		print ''
-		print '/* these entry points might require different protocols */'
-		print '#ifndef _GLAPI_SKIP_PROTO_ENTRY_POINTS'
-		print ''
+		print('')
+		print('#endif /* _GLAPI_SKIP_NORMAL_ENTRY_POINTS */')
+		print('')
+		print('/* these entry points might require different protocols */')
+		print('#ifndef _GLAPI_SKIP_PROTO_ENTRY_POINTS')
+		print('')
 		for func, ents in proto_entry_points:
 			for ent in ents:
 				self.printFunction(func, ent)
-		print ''
-		print '#endif /* _GLAPI_SKIP_PROTO_ENTRY_POINTS */'
-		print ''
+		print('')
+		print('#endif /* _GLAPI_SKIP_PROTO_ENTRY_POINTS */')
+		print('')
 
 		self.printInitDispatch(api)
 		self.printAliasedTable(api)
@@ -295,8 +295,8 @@ _glapi_proc UNUSED_TABLE_NAME[] = {"""
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-c]" % sys.argv[0]
-	print "-c          Enable compatibility with OpenGL ES."
+	print("Usage: %s [-f input_file_name] [-c]" % sys.argv[0])
+	print("-c          Enable compatibility with OpenGL ES.")
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -304,11 +304,11 @@ if __name__ == '__main__':
     
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:c")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	es = False
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-c":
diff --git a/src/mapi/glapi/gen/gl_enums.py b/src/mapi/glapi/gen/gl_enums.py
index d51b74a..db3bcec 100644
--- a/src/mapi/glapi/gen/gl_enums.py
+++ b/src/mapi/glapi/gen/gl_enums.py
@@ -42,21 +42,21 @@ class PrintGlEnums(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print '#include "main/glheader.h"'
-		print '#include "main/mfeatures.h"'
-		print '#include "main/enums.h"'
-		print '#include "main/imports.h"'
-		print '#include "main/mtypes.h"'
-		print ''
-		print 'typedef struct {'
-		print '   size_t offset;'
-		print '   int n;'
-		print '} enum_elt;'
-		print ''
+		print('#include "main/glheader.h"')
+		print('#include "main/mfeatures.h"')
+		print('#include "main/enums.h"')
+		print('#include "main/imports.h"')
+		print('#include "main/mtypes.h"')
+		print('')
+		print('typedef struct {')
+		print('   size_t offset;')
+		print('   int n;')
+		print('} enum_elt;')
+		print('')
 		return
 
 	def print_code(self):
-		print """
+		print("""
 typedef int (*cfunc)(const void *, const void *);
 
 /**
@@ -159,7 +159,7 @@ int _mesa_lookup_enum_by_name( const char *symbol )
    return (f != NULL) ? f->n : -1;
 }
 
-"""
+""")
 		return
 
 
@@ -168,8 +168,7 @@ int _mesa_lookup_enum_by_name( const char *symbol )
 		for api in api_list:
 			self.process_enums( api )
 
-		keys = self.enum_table.keys()
-		keys.sort()
+		keys = sorted(self.enum_table.keys())
 
 		name_table = []
 		enum_table = {}
@@ -188,34 +187,34 @@ int _mesa_lookup_enum_by_name( const char *symbol )
 
 		string_offsets = {}
 		i = 0;
-		print 'LONGSTRING static const char enum_string_table[] = '
+		print('LONGSTRING static const char enum_string_table[] = ')
 		for [name, enum] in name_table:
-			print '   "%s\\0"' % (name)
+			print('   "%s\\0"' % (name))
 			string_offsets[ name ] = i
 			i += len(name) + 1
 
-		print '   ;'
-		print ''
+		print('   ;')
+		print('')
 
 
-		print 'static const enum_elt all_enums[%u] =' % (len(name_table))
-		print '{'
+		print('static const enum_elt all_enums[%u] =' % (len(name_table)))
+		print('{')
 		for [name, enum] in name_table:
-			print '   { %5u, 0x%08X }, /* %s */' % (string_offsets[name], enum, name)
-		print '};'
-		print ''
+			print('   { %5u, 0x%08X }, /* %s */' % (string_offsets[name], enum, name))
+		print('};')
+		print('')
 
-		print 'static const unsigned reduced_enums[%u] =' % (len(keys))
-		print '{'
+		print('static const unsigned reduced_enums[%u] =' % (len(keys)))
+		print('{')
 		for enum in keys:
 			name = enum_table[ enum ]
 			if [name, enum] not in name_table:
-				print '      /* Error! %s, 0x%04x */ 0,' % (name, enum)
+				print('      /* Error! %s, 0x%04x */ 0,' % (name, enum))
 			else:
 				i = name_table.index( [name, enum] )
 
-				print '      %4u, /* %s */' % (i, name)
-		print '};'
+				print('      %4u, /* %s */' % (i, name))
+		print('};')
 
 
 		self.print_code()
@@ -240,17 +239,17 @@ int _mesa_lookup_enum_by_name( const char *symbol )
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name]" % sys.argv[0]
+	print("Usage: %s [-f input_file_name]" % sys.argv[0])
 	sys.exit(1)
 
 if __name__ == '__main__':
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	api_list = []
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			api = gl_XML.parse_GL_API( val )
 			api_list.append(api);
diff --git a/src/mapi/glapi/gen/gl_gentable.py b/src/mapi/glapi/gen/gl_gentable.py
index 814238a..4a9f79f 100644
--- a/src/mapi/glapi/gen/gl_gentable.py
+++ b/src/mapi/glapi/gen/gl_gentable.py
@@ -134,12 +134,12 @@ class PrintCode(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print header
+		print(header)
 		return
 
 
 	def printRealFooter(self):
-		print footer
+		print(footer)
 		return
 
 
@@ -149,11 +149,11 @@ class PrintCode(gl_XML.gl_print_base):
 				vars = { 'entry_point' : entry_point,
 				         'name' : f.name }
 
-				print body_template % vars
+				print(body_template % vars)
 		return
 
 def show_usage():
-	print "Usage: %s [-f input_file_name]" % sys.argv[0]
+	print("Usage: %s [-f input_file_name]" % sys.argv[0])
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -161,10 +161,10 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "m:f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 
diff --git a/src/mapi/glapi/gen/gl_offsets.py b/src/mapi/glapi/gen/gl_offsets.py
index 54867b3..4b064c4 100644
--- a/src/mapi/glapi/gen/gl_offsets.py
+++ b/src/mapi/glapi/gen/gl_offsets.py
@@ -42,8 +42,8 @@ class PrintGlOffsets(gl_XML.gl_print_base):
 		return
 
 	def printBody(self, api):
-		print '/* this file should not be included directly in mesa */'
-		print ''
+		print('/* this file should not be included directly in mesa */')
+		print('')
 
 		functions = []
 		abi_functions = []
@@ -62,41 +62,41 @@ class PrintGlOffsets(gl_XML.gl_print_base):
 					alias_functions.append(f)
 
 		for f in abi_functions:
-			print '#define _gloffset_%s %d' % (f.name, f.offset)
+			print('#define _gloffset_%s %d' % (f.name, f.offset))
 			last_static = f.offset
 
-		print ''
-		print '#if !defined(_GLAPI_USE_REMAP_TABLE)'
-		print ''
+		print('')
+		print('#if !defined(_GLAPI_USE_REMAP_TABLE)')
+		print('')
 
 		for [f, index] in functions:
-			print '#define _gloffset_%s %d' % (f.name, f.offset)
+			print('#define _gloffset_%s %d' % (f.name, f.offset))
 
-		print '#define _gloffset_FIRST_DYNAMIC %d' % (api.next_offset)
+		print('#define _gloffset_FIRST_DYNAMIC %d' % (api.next_offset))
 
-		print ''
-		print '#else'
-		print ''
+		print('')
+		print('#else')
+		print('')
 
 		for [f, index] in functions:
-			print '#define _gloffset_%s driDispatchRemapTable[%s_remap_index]' % (f.name, f.name)
+			print('#define _gloffset_%s driDispatchRemapTable[%s_remap_index]' % (f.name, f.name))
 
-		print ''
-		print '#endif /* !defined(_GLAPI_USE_REMAP_TABLE) */'
+		print('')
+		print('#endif /* !defined(_GLAPI_USE_REMAP_TABLE) */')
 
 		if alias_functions:
-			print ''
-			print '/* define aliases for compatibility */'
+			print('')
+			print('/* define aliases for compatibility */')
 			for f in alias_functions:
 				for name in f.entry_points:
 					if name != f.name:
-						print '#define _gloffset_%s _gloffset_%s' % (name, f.name)
+						print('#define _gloffset_%s _gloffset_%s' % (name, f.name))
 		return
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-c]" % sys.argv[0]
-	print "    -c        Enable compatibility with OpenGL ES."
+	print("Usage: %s [-f input_file_name] [-c]" % sys.argv[0])
+	print("    -c        Enable compatibility with OpenGL ES.")
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -104,11 +104,11 @@ if __name__ == '__main__':
     
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:c")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	es = False
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-c":
diff --git a/src/mapi/glapi/gen/gl_procs.py b/src/mapi/glapi/gen/gl_procs.py
index a9ba482..56fd288 100644
--- a/src/mapi/glapi/gen/gl_procs.py
+++ b/src/mapi/glapi/gen/gl_procs.py
@@ -42,7 +42,7 @@ class PrintGlProcs(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print """
+		print("""
 /* This file is only included by glapi.c and is used for
  * the GetProcAddress() function
  */
@@ -65,31 +65,31 @@ typedef struct {
 #  define NAME_FUNC_OFFSET(n,f1,f2,f3,o) { n , (_glapi_proc) f3 , o }
 #endif
 
-"""
+""")
 		return
 
 	def printRealFooter(self):
-		print ''
-		print '#undef NAME_FUNC_OFFSET'
+		print('')
+		print('#undef NAME_FUNC_OFFSET')
 		return
 
 	def printFunctionString(self, name):
 		if self.long_strings:
-			print '    "gl%s\\0"' % (name)
+			print('    "gl%s\\0"' % (name))
 		else:
-			print "    'g','l',",
+			print("    'g','l',", end=' ')
 			for c in name:
-				print "'%s'," % (c),
+				print("'%s'," % (c), end=' ')
 			
-			print "'\\0',"
+			print("'\\0',")
 
 
 	def printBody(self, api):
-		print ''
+		print('')
 		if self.long_strings:
-			print 'static const char gl_string_table[] ='
+			print('static const char gl_string_table[] =')
 		else:
-			print 'static const char gl_string_table[] = {'
+			print('static const char gl_string_table[] = {')
 
 		base_offset = 0
 		table = []
@@ -120,26 +120,26 @@ typedef struct {
 
 
 		if self.long_strings:
-			print '    ;'
+			print('    ;')
 		else:
-			print '};'
+			print('};')
 
-		print ''
-		print ''
-		print "#ifdef USE_MGL_NAMESPACE"
+		print('')
+		print('')
+		print("#ifdef USE_MGL_NAMESPACE")
 		for func in api.functionIterateByOffset():
 			for n in func.entry_points:
 				if (not func.is_static_entry_point(func.name)) or (func.has_different_protocol(n) and not func.is_static_entry_point(n)):
-					print '#define gl_dispatch_stub_%u mgl_dispatch_stub_%u' % (func.offset, func.offset)
+					print('#define gl_dispatch_stub_%u mgl_dispatch_stub_%u' % (func.offset, func.offset))
 					break
-		print "#endif /* USE_MGL_NAMESPACE */"
-		print ''
-		print ''
-		print '#if defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING)'
+		print("#endif /* USE_MGL_NAMESPACE */")
+		print('')
+		print('')
+		print('#if defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING)')
 		for func in api.functionIterateByOffset():
 			for n in func.entry_points:
 				if (not func.is_static_entry_point(func.name)) or (func.has_different_protocol(n) and not func.is_static_entry_point(n)):
-					print '%s GLAPIENTRY gl_dispatch_stub_%u(%s);' % (func.return_type, func.offset, func.get_parameter_string())
+					print('%s GLAPIENTRY gl_dispatch_stub_%u(%s);' % (func.return_type, func.offset, func.get_parameter_string()))
 					break
 
 		if self.es:
@@ -148,43 +148,42 @@ typedef struct {
 				for n in func.entry_points:
 					cat, num = api.get_category_for_name(n)
 					if (cat.startswith("es") or cat.startswith("GL_OES")):
-						if not categories.has_key(cat):
+						if cat not in categories:
 							categories[cat] = []
 						proto = 'GLAPI %s GLAPIENTRY %s(%s);' \
 								% (func.return_type, "gl" + n, func.get_parameter_string(n))
 						categories[cat].append(proto)
 			if categories:
-				print ''
-				print '/* OpenGL ES specific prototypes */'
-				print ''
-				keys = categories.keys()
-				keys.sort()
+				print('')
+				print('/* OpenGL ES specific prototypes */')
+				print('')
+				keys = sorted(categories.keys())
 				for key in keys:
-					print '/* category %s */' % key
-					print "\n".join(categories[key])
-				print ''
+					print('/* category %s */' % key)
+					print("\n".join(categories[key]))
+				print('')
 
-		print '#endif /* defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING) */'
+		print('#endif /* defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING) */')
 
-		print ''
-		print 'static const glprocs_table_t static_functions[] = {'
+		print('')
+		print('static const glprocs_table_t static_functions[] = {')
 
 		for info in table:
-			print '    NAME_FUNC_OFFSET(%5u, %s, %s, %s, %d),' % info
+			print('    NAME_FUNC_OFFSET(%5u, %s, %s, %s, %d),' % info)
 
-		print '    NAME_FUNC_OFFSET(-1, NULL, NULL, NULL, 0)'
-		print '};'
+		print('    NAME_FUNC_OFFSET(-1, NULL, NULL, NULL, 0)')
+		print('};')
 		return
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m mode] [-c]" % sys.argv[0]
-	print "-c          Enable compatibility with OpenGL ES."
-	print "-m mode     mode can be one of:"
-	print "    long  - Create code for compilers that can handle very"
-	print "            long string constants. (default)"
-	print "    short - Create code for compilers that can only handle"
-	print "            ANSI C89 string constants."
+	print("Usage: %s [-f input_file_name] [-m mode] [-c]" % sys.argv[0])
+	print("-c          Enable compatibility with OpenGL ES.")
+	print("-m mode     mode can be one of:")
+	print("    long  - Create code for compilers that can handle very")
+	print("            long string constants. (default)")
+	print("    short - Create code for compilers that can only handle")
+	print("            ANSI C89 string constants.")
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -192,12 +191,12 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:c")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	long_string = 1
 	es = False
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-m":
diff --git a/src/mapi/glapi/gen/gl_table.py b/src/mapi/glapi/gen/gl_table.py
index 05979e3..497510f 100644
--- a/src/mapi/glapi/gen/gl_table.py
+++ b/src/mapi/glapi/gen/gl_table.py
@@ -45,26 +45,26 @@ class PrintGlTable(gl_XML.gl_print_base):
 	def printBody(self, api):
 		for f in api.functionIterateByOffset():
 			arg_string = f.get_parameter_string()
-			print '   %s (GLAPIENTRYP %s)(%s); /* %d */' % (f.return_type, f.name, arg_string, f.offset)
+			print('   %s (GLAPIENTRYP %s)(%s); /* %d */' % (f.return_type, f.name, arg_string, f.offset))
 
 
 	def printRealHeader(self):
-		print '#ifndef GLAPIENTRYP'
-		print '# ifndef GLAPIENTRY'
-		print '#  define GLAPIENTRY'
-		print '# endif'
-		print ''
-		print '# define GLAPIENTRYP GLAPIENTRY *'
-		print '#endif'
-		print ''
-		print ''
-		print 'struct _glapi_table'
-		print '{'
+		print('#ifndef GLAPIENTRYP')
+		print('# ifndef GLAPIENTRY')
+		print('#  define GLAPIENTRY')
+		print('# endif')
+		print('')
+		print('# define GLAPIENTRYP GLAPIENTRY *')
+		print('#endif')
+		print('')
+		print('')
+		print('struct _glapi_table')
+		print('{')
 		return
 
 
 	def printRealFooter(self):
-		print '};'
+		print('};')
 		return
 
 
@@ -80,7 +80,7 @@ class PrintRemapTable(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print """
+		print("""
 /**
  * \\file main/dispatch.h
  * Macros for handling GL dispatch tables.
@@ -93,26 +93,26 @@ class PrintRemapTable(gl_XML.gl_print_base):
  */
 
 #include "main/mfeatures.h"
-"""
+""")
 		return
 
 	def printBody(self, api):
-		print '#define CALL_by_offset(disp, cast, offset, parameters) \\'
-		print '    (*(cast (GET_by_offset(disp, offset)))) parameters'
-		print '#define GET_by_offset(disp, offset) \\'
-		print '    (offset >= 0) ? (((_glapi_proc *)(disp))[offset]) : NULL'
-		print '#define SET_by_offset(disp, offset, fn) \\'
-		print '    do { \\'
-		print '        if ( (offset) < 0 ) { \\'
-		print '            /* fprintf( stderr, "[%s:%u] SET_by_offset(%p, %d, %s)!\\n", */ \\'
-		print '            /*         __func__, __LINE__, disp, offset, # fn); */ \\'
-		print '            /* abort(); */ \\'
-		print '        } \\'
-		print '        else { \\'
-		print '            ( (_glapi_proc *) (disp) )[offset] = (_glapi_proc) fn; \\'
-		print '        } \\'
-		print '    } while(0)'
-		print ''
+		print('#define CALL_by_offset(disp, cast, offset, parameters) \\')
+		print('    (*(cast (GET_by_offset(disp, offset)))) parameters')
+		print('#define GET_by_offset(disp, offset) \\')
+		print('    (offset >= 0) ? (((_glapi_proc *)(disp))[offset]) : NULL')
+		print('#define SET_by_offset(disp, offset, fn) \\')
+		print('    do { \\')
+		print('        if ( (offset) < 0 ) { \\')
+		print('            /* fprintf( stderr, "[%s:%u] SET_by_offset(%p, %d, %s)!\\n", */ \\')
+		print('            /*         __func__, __LINE__, disp, offset, # fn); */ \\')
+		print('            /* abort(); */ \\')
+		print('        } \\')
+		print('        else { \\')
+		print('            ( (_glapi_proc *) (disp) )[offset] = (_glapi_proc) fn; \\')
+		print('        } \\')
+		print('    } while(0)')
+		print('')
 
 		functions = []
 		abi_functions = []
@@ -130,90 +130,90 @@ class PrintRemapTable(gl_XML.gl_print_base):
 				if len(f.entry_points) > 1:
 					alias_functions.append(f)
 
-		print '/* total number of offsets below */'
-		print '#define _gloffset_COUNT %d' % (len(abi_functions + functions))
-		print ''
+		print('/* total number of offsets below */')
+		print('#define _gloffset_COUNT %d' % (len(abi_functions + functions)))
+		print('')
 
 		for f, index in abi_functions:
-			print '#define _gloffset_%s %d' % (f.name, f.offset)
+			print('#define _gloffset_%s %d' % (f.name, f.offset))
 
-		print ''
-		print '#if !FEATURE_remap_table'
-		print ''
+		print('')
+		print('#if !FEATURE_remap_table')
+		print('')
 
 		for f, index in functions:
-			print '#define _gloffset_%s %d' % (f.name, f.offset)
+			print('#define _gloffset_%s %d' % (f.name, f.offset))
 
-		print ''
-		print '#else /* !FEATURE_remap_table */'
-		print ''
+		print('')
+		print('#else /* !FEATURE_remap_table */')
+		print('')
 
 		if self.es:
 			remap_table = "esLocalRemapTable"
 
-			print '#define %s_size %u' % (remap_table, count)
-			print 'static int %s[ %s_size ];' % (remap_table, remap_table)
-			print ''
+			print('#define %s_size %u' % (remap_table, count))
+			print('static int %s[ %s_size ];' % (remap_table, remap_table))
+			print('')
 		else:
 			remap_table = "driDispatchRemapTable"
 
-			print '#define %s_size %u' % (remap_table, count)
-			print 'extern int %s[ %s_size ];' % (remap_table, remap_table)
-			print ''
+			print('#define %s_size %u' % (remap_table, count))
+			print('extern int %s[ %s_size ];' % (remap_table, remap_table))
+			print('')
 
 		for f, index in functions:
-			print '#define %s_remap_index %u' % (f.name, index)
+			print('#define %s_remap_index %u' % (f.name, index))
 
-		print ''
+		print('')
 
 		for f, index in functions:
-			print '#define _gloffset_%s %s[%s_remap_index]' % (f.name, remap_table, f.name)
+			print('#define _gloffset_%s %s[%s_remap_index]' % (f.name, remap_table, f.name))
 
-		print ''
-		print '#endif /* !FEATURE_remap_table */'
-		print ''
+		print('')
+		print('#endif /* !FEATURE_remap_table */')
+		print('')
 
 		for f, index in abi_functions + functions:
 			arg_string = gl_XML.create_parameter_string( f.parameters, 0 )
 
-			print 'typedef %s (GLAPIENTRYP _glptr_%s)(%s);' % (f.return_type, f.name, arg_string)
-			print '#define CALL_%s(disp, parameters) \\' % (f.name)
-			print '    (* GET_%s(disp)) parameters' % (f.name)
-			print 'static INLINE _glptr_%s GET_%s(struct _glapi_table *disp) {' % (f.name, f.name)
-			print '   return (_glptr_%s) (GET_by_offset(disp, _gloffset_%s));' % (f.name, f.name)
-			print '}'
-			print
-			print 'static INLINE void SET_%s(struct _glapi_table *disp, %s (GLAPIENTRYP fn)(%s)) {' % (f.name, f.return_type, arg_string)
-			print '   SET_by_offset(disp, _gloffset_%s, fn);' % (f.name)
-			print '}'
-			print
+			print('typedef %s (GLAPIENTRYP _glptr_%s)(%s);' % (f.return_type, f.name, arg_string))
+			print('#define CALL_%s(disp, parameters) \\' % (f.name))
+			print('    (* GET_%s(disp)) parameters' % (f.name))
+			print('static INLINE _glptr_%s GET_%s(struct _glapi_table *disp) {' % (f.name, f.name))
+			print('   return (_glptr_%s) (GET_by_offset(disp, _gloffset_%s));' % (f.name, f.name))
+			print('}')
+			print()
+			print('static INLINE void SET_%s(struct _glapi_table *disp, %s (GLAPIENTRYP fn)(%s)) {' % (f.name, f.return_type, arg_string))
+			print('   SET_by_offset(disp, _gloffset_%s, fn);' % (f.name))
+			print('}')
+			print()
 
 		if alias_functions:
-			print ''
-			print '/* define aliases for compatibility */'
+			print('')
+			print('/* define aliases for compatibility */')
 			for f in alias_functions:
 				for name in f.entry_points:
 					if name != f.name:
-						print '#define CALL_%s(disp, parameters) CALL_%s(disp, parameters)' % (name, f.name)
-						print '#define GET_%s(disp) GET_%s(disp)' % (name, f.name)
-						print '#define SET_%s(disp, fn) SET_%s(disp, fn)' % (name, f.name)
-			print ''
+						print('#define CALL_%s(disp, parameters) CALL_%s(disp, parameters)' % (name, f.name))
+						print('#define GET_%s(disp) GET_%s(disp)' % (name, f.name))
+						print('#define SET_%s(disp, fn) SET_%s(disp, fn)' % (name, f.name))
+			print('')
 
-			print '#if FEATURE_remap_table'
+			print('#if FEATURE_remap_table')
 			for f in alias_functions:
 				for name in f.entry_points:
 					if name != f.name:
-						print '#define %s_remap_index %s_remap_index' % (name, f.name)
-			print '#endif /* FEATURE_remap_table */'
-			print ''
+						print('#define %s_remap_index %s_remap_index' % (name, f.name))
+			print('#endif /* FEATURE_remap_table */')
+			print('')
 
 		return
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m mode] [-c]" % sys.argv[0]
-	print "    -m mode   Mode can be 'table' or 'remap_table'."
-	print "    -c        Enable compatibility with OpenGL ES."
+	print("Usage: %s [-f input_file_name] [-m mode] [-c]" % sys.argv[0])
+	print("    -m mode   Mode can be 'table' or 'remap_table'.")
+	print("    -c        Enable compatibility with OpenGL ES.")
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -221,12 +221,12 @@ if __name__ == '__main__':
     
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:c")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
 	mode = "table"
 	es = False
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 		elif arg == "-m":
diff --git a/src/mapi/glapi/gen/gl_x86-64_asm.py b/src/mapi/glapi/gen/gl_x86-64_asm.py
index 11cd9af..1ff3f3a 100644
--- a/src/mapi/glapi/gen/gl_x86-64_asm.py
+++ b/src/mapi/glapi/gen/gl_x86-64_asm.py
@@ -53,7 +53,7 @@ def save_all_regs(registers):
 	adjust_stack = 0
 	if not should_use_push(registers):
 		adjust_stack = local_size(registers)
-		print '\tsubq\t$%u, %%rsp' % (adjust_stack)
+		print('\tsubq\t$%u, %%rsp' % (adjust_stack))
 
 	for [reg, stack_offset] in registers:
 		save_reg( reg, stack_offset, adjust_stack )
@@ -71,18 +71,18 @@ def restore_all_regs(registers):
 		restore_reg(reg, stack_offset, adjust_stack)
 
 	if adjust_stack:
-		print '\taddq\t$%u, %%rsp' % (adjust_stack)
+		print('\taddq\t$%u, %%rsp' % (adjust_stack))
 	return
 
 
 def save_reg(reg, offset, use_move):
 	if use_move:
 		if offset == 0:
-			print '\tmovq\t%s, (%%rsp)' % (reg)
+			print('\tmovq\t%s, (%%rsp)' % (reg))
 		else:
-			print '\tmovq\t%s, %u(%%rsp)' % (reg, offset)
+			print('\tmovq\t%s, %u(%%rsp)' % (reg, offset))
 	else:
-		print '\tpushq\t%s' % (reg)
+		print('\tpushq\t%s' % (reg))
 
 	return
 
@@ -90,11 +90,11 @@ def save_reg(reg, offset, use_move):
 def restore_reg(reg, offset, use_move):
 	if use_move:
 		if offset == 0:
-			print '\tmovq\t(%%rsp), %s' % (reg)
+			print('\tmovq\t(%%rsp), %s' % (reg))
 		else:
-			print '\tmovq\t%u(%%rsp), %s' % (offset, reg)
+			print('\tmovq\t%u(%%rsp), %s' % (offset, reg))
 	else:
-		print '\tpopq\t%s' % (reg)
+		print('\tpopq\t%s' % (reg))
 
 	return
 
@@ -118,85 +118,85 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print "/* If we build with gcc's -fvisibility=hidden flag, we'll need to change"
-		print " * the symbol visibility mode to 'default'."
-		print ' */'
-		print ''
-		print '#include "x86/assyntax.h"'
-		print ''
-		print '#ifdef __GNUC__'
-		print '#  pragma GCC visibility push(default)'
-		print '#  define HIDDEN(x) .hidden x'
-		print '#else'
-		print '#  define HIDDEN(x)'
-		print '#endif'
-		print ''
-		print '# if defined(USE_MGL_NAMESPACE)'
-		print '#  define GL_PREFIX(n) GLNAME(CONCAT(mgl,n))'
-		print '#  define _glapi_Dispatch _mglapi_Dispatch'
-		print '# else'
-		print '#  define GL_PREFIX(n) GLNAME(CONCAT(gl,n))'
-		print '# endif'
-		print ''
-		print '#if defined(PTHREADS) || defined(WIN32) || defined(BEOS_THREADS)'
-		print '#  define THREADS'
-		print '#endif'
-		print ''
-		print '\t.text'
-		print ''
-		print '#ifdef GLX_USE_TLS'
-		print ''
-		print '\t.globl _x86_64_get_get_dispatch; HIDDEN(_x86_64_get_get_dispatch)'
-		print '_x86_64_get_get_dispatch:'
-		print '\tlea\t_x86_64_get_dispatch(%rip), %rax'
-		print '\tret'
-		print ''
-		print '\t.p2align\t4,,15'
-		print '_x86_64_get_dispatch:'
-		print '\tmovq\t_glapi_tls_Dispatch@GOTTPOFF(%rip), %rax'
-		print '\tmovq\t%fs:(%rax), %rax'
-		print '\tret'
-		print '\t.size\t_x86_64_get_dispatch, .-_x86_64_get_dispatch'
-		print ''
-		print '#elif defined(PTHREADS)'
-		print ''
-		print '\t.extern\t_glapi_Dispatch'
-		print '\t.extern\t_gl_DispatchTSD'
-		print '\t.extern\tpthread_getspecific'
-		print ''
-		print '\t.p2align\t4,,15'
-		print '_x86_64_get_dispatch:'
-		print '\tmovq\t_gl_DispatchTSD@GOTPCREL(%rip), %rax'
-		print '\tmovl\t(%rax), %edi'
-		print '\tjmp\tpthread_getspecific@PLT'
-		print ''
-		print '#elif defined(THREADS)'
-		print ''
-		print '\t.extern\t_glapi_get_dispatch'
-		print ''
-		print '#endif'
-		print ''
+		print("/* If we build with gcc's -fvisibility=hidden flag, we'll need to change")
+		print(" * the symbol visibility mode to 'default'.")
+		print(' */')
+		print('')
+		print('#include "x86/assyntax.h"')
+		print('')
+		print('#ifdef __GNUC__')
+		print('#  pragma GCC visibility push(default)')
+		print('#  define HIDDEN(x) .hidden x')
+		print('#else')
+		print('#  define HIDDEN(x)')
+		print('#endif')
+		print('')
+		print('# if defined(USE_MGL_NAMESPACE)')
+		print('#  define GL_PREFIX(n) GLNAME(CONCAT(mgl,n))')
+		print('#  define _glapi_Dispatch _mglapi_Dispatch')
+		print('# else')
+		print('#  define GL_PREFIX(n) GLNAME(CONCAT(gl,n))')
+		print('# endif')
+		print('')
+		print('#if defined(PTHREADS) || defined(WIN32) || defined(BEOS_THREADS)')
+		print('#  define THREADS')
+		print('#endif')
+		print('')
+		print('\t.text')
+		print('')
+		print('#ifdef GLX_USE_TLS')
+		print('')
+		print('\t.globl _x86_64_get_get_dispatch; HIDDEN(_x86_64_get_get_dispatch)')
+		print('_x86_64_get_get_dispatch:')
+		print('\tlea\t_x86_64_get_dispatch(%rip), %rax')
+		print('\tret')
+		print('')
+		print('\t.p2align\t4,,15')
+		print('_x86_64_get_dispatch:')
+		print('\tmovq\t_glapi_tls_Dispatch@GOTTPOFF(%rip), %rax')
+		print('\tmovq\t%fs:(%rax), %rax')
+		print('\tret')
+		print('\t.size\t_x86_64_get_dispatch, .-_x86_64_get_dispatch')
+		print('')
+		print('#elif defined(PTHREADS)')
+		print('')
+		print('\t.extern\t_glapi_Dispatch')
+		print('\t.extern\t_gl_DispatchTSD')
+		print('\t.extern\tpthread_getspecific')
+		print('')
+		print('\t.p2align\t4,,15')
+		print('_x86_64_get_dispatch:')
+		print('\tmovq\t_gl_DispatchTSD@GOTPCREL(%rip), %rax')
+		print('\tmovl\t(%rax), %edi')
+		print('\tjmp\tpthread_getspecific@PLT')
+		print('')
+		print('#elif defined(THREADS)')
+		print('')
+		print('\t.extern\t_glapi_get_dispatch')
+		print('')
+		print('#endif')
+		print('')
 		return
 
 
 	def printRealFooter(self):
-		print ''
-		print '#if defined(GLX_USE_TLS) && defined(__linux__)'
-		print '	.section ".note.ABI-tag", "a"'
-		print '	.p2align 2'
-		print '	.long	1f - 0f   /* name length */'
-		print '	.long	3f - 2f   /* data length */'
-		print '	.long	1         /* note length */'
-		print '0:	.asciz "GNU"      /* vendor name */'
-		print '1:	.p2align 2'
-		print '2:	.long	0         /* note data: the ABI tag */'
-		print '	.long	2,4,20    /* Minimum kernel version w/TLS */'
-		print '3:	.p2align 2        /* pad out section */'
-		print '#endif /* GLX_USE_TLS */'
-		print ''
-		print '#if defined (__ELF__) && defined (__linux__)'
-		print '	.section .note.GNU-stack,"",%progbits'
-		print '#endif'
+		print('')
+		print('#if defined(GLX_USE_TLS) && defined(__linux__)')
+		print('	.section ".note.ABI-tag", "a"')
+		print('	.p2align 2')
+		print('	.long	1f - 0f   /* name length */')
+		print('	.long	3f - 2f   /* data length */')
+		print('	.long	1         /* note length */')
+		print('0:	.asciz "GNU"      /* vendor name */')
+		print('1:	.p2align 2')
+		print('2:	.long	0         /* note data: the ABI tag */')
+		print('	.long	2,4,20    /* Minimum kernel version w/TLS */')
+		print('3:	.p2align 2        /* pad out section */')
+		print('#endif /* GLX_USE_TLS */')
+		print('')
+		print('#if defined (__ELF__) && defined (__linux__)')
+		print('	.section .note.GNU-stack,"",%progbits')
+		print('#endif')
 		return
 
 
@@ -241,47 +241,47 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 
 		name = f.dispatch_name()
 
-		print '\t.p2align\t4,,15'
-		print '\t.globl\tGL_PREFIX(%s)' % (name)
-		print '\t.type\tGL_PREFIX(%s), @function' % (name)
+		print('\t.p2align\t4,,15')
+		print('\t.globl\tGL_PREFIX(%s)' % (name))
+		print('\t.type\tGL_PREFIX(%s), @function' % (name))
 		if not f.is_static_entry_point(f.name):
-			print '\tHIDDEN(GL_PREFIX(%s))' % (name)
-		print 'GL_PREFIX(%s):' % (name)
-		print '#if defined(GLX_USE_TLS)'
-		print '\tcall\t_x86_64_get_dispatch@PLT'
-		print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
-		print '\tjmp\t*%r11'
-		print '#elif defined(PTHREADS)'
+			print('\tHIDDEN(GL_PREFIX(%s))' % (name))
+		print('GL_PREFIX(%s):' % (name))
+		print('#if defined(GLX_USE_TLS)')
+		print('\tcall\t_x86_64_get_dispatch@PLT')
+		print('\tmovq\t%u(%%rax), %%r11' % (f.offset * 8))
+		print('\tjmp\t*%r11')
+		print('#elif defined(PTHREADS)')
 		
 		save_all_regs(registers)
-		print '\tcall\t_x86_64_get_dispatch@PLT'
+		print('\tcall\t_x86_64_get_dispatch@PLT')
 		restore_all_regs(registers)
 
 		if f.offset == 0:
-			print '\tmovq\t(%rax), %r11'
+			print('\tmovq\t(%rax), %r11')
 		else:
-			print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
+			print('\tmovq\t%u(%%rax), %%r11' % (f.offset * 8))
 
-		print '\tjmp\t*%r11'
+		print('\tjmp\t*%r11')
 
-		print '#else'
-		print '\tmovq\t_glapi_Dispatch(%rip), %rax'
-		print '\ttestq\t%rax, %rax'
-		print '\tje\t1f'
-		print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
-		print '\tjmp\t*%r11'
-		print '1:'
+		print('#else')
+		print('\tmovq\t_glapi_Dispatch(%rip), %rax')
+		print('\ttestq\t%rax, %rax')
+		print('\tje\t1f')
+		print('\tmovq\t%u(%%rax), %%r11' % (f.offset * 8))
+		print('\tjmp\t*%r11')
+		print('1:')
 
 		save_all_regs(registers)
-		print '\tcall\t_glapi_get_dispatch'
+		print('\tcall\t_glapi_get_dispatch')
 		restore_all_regs(registers)
 
-		print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
-		print '\tjmp\t*%r11'
-		print '#endif /* defined(GLX_USE_TLS) */'
+		print('\tmovq\t%u(%%rax), %%r11' % (f.offset * 8))
+		print('\tjmp\t*%r11')
+		print('#endif /* defined(GLX_USE_TLS) */')
 
-		print '\t.size\tGL_PREFIX(%s), .-GL_PREFIX(%s)' % (name, name)
-		print ''
+		print('\t.size\tGL_PREFIX(%s), .-GL_PREFIX(%s)' % (name, name))
+		print('')
 		return
 
 
@@ -298,16 +298,16 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 						text = '\t.globl GL_PREFIX(%s) ; .set GL_PREFIX(%s), GL_PREFIX(%s)' % (n, n, dispatch)
 
 						if f.has_different_protocol(n):
-							print '#ifndef GLX_INDIRECT_RENDERING'
-							print text
-							print '#endif'
+							print('#ifndef GLX_INDIRECT_RENDERING')
+							print(text)
+							print('#endif')
 						else:
-							print text
+							print(text)
 
 		return
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0]
+	print("Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0])
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -316,10 +316,10 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "m:f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == '-m':
 			mode = val
 		elif arg == "-f":
@@ -328,7 +328,7 @@ if __name__ == '__main__':
 	if mode == "generic":
 		printer = PrintGenericStubs()
 	else:
-		print "ERROR: Invalid mode \"%s\" specified." % mode
+		print("ERROR: Invalid mode \"%s\" specified." % mode)
 		show_usage()
 
 	api = gl_XML.parse_GL_API(file_name, glX_XML.glx_item_factory())
diff --git a/src/mapi/glapi/gen/gl_x86_asm.py b/src/mapi/glapi/gen/gl_x86_asm.py
index 4ef4acb..1a24c1a 100644
--- a/src/mapi/glapi/gen/gl_x86_asm.py
+++ b/src/mapi/glapi/gen/gl_x86_asm.py
@@ -53,158 +53,158 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print '#include "x86/assyntax.h"'
-		print ''
-		print '#if defined(STDCALL_API)'
-		print '# if defined(USE_MGL_NAMESPACE)'
-		print '#  define GL_PREFIX(n,n2) GLNAME(CONCAT(mgl,n2))'
-		print '# else'
-		print '#  define GL_PREFIX(n,n2) GLNAME(CONCAT(gl,n2))'
-		print '# endif'
-		print '#else'
-		print '# if defined(USE_MGL_NAMESPACE)'
-		print '#  define GL_PREFIX(n,n2) GLNAME(CONCAT(mgl,n))'
-		print '#  define _glapi_Dispatch _mglapi_Dispatch'
-		print '# else'
-		print '#  define GL_PREFIX(n,n2) GLNAME(CONCAT(gl,n))'
-		print '# endif'
-		print '#endif'
-		print ''
-		print '#define GL_OFFSET(x) CODEPTR(REGOFF(4 * x, EAX))'
-		print ''
-		print '#if defined(GNU_ASSEMBLER) && !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__)'
-		print '#define GLOBL_FN(x) GLOBL x ; .type x, @function'
-		print '#else'
-		print '#define GLOBL_FN(x) GLOBL x'
-		print '#endif'
-		print ''
-		print '#if defined(PTHREADS) || defined(WIN32) || defined(BEOS_THREADS)'
-		print '#  define THREADS'
-		print '#endif'
-		print ''
-		print '#ifdef GLX_USE_TLS'
-		print ''
-		print '#ifdef GLX_X86_READONLY_TEXT'
-		print '# define CTX_INSNS MOV_L(GS:(EAX), EAX)'
-		print '#else'
-		print '# define CTX_INSNS NOP /* Pad for init_glapi_relocs() */'
-		print '#endif'
-		print ''
-		print '#  define GL_STUB(fn,off,fn_alt)\t\t\t\\'
-		print 'ALIGNTEXT16;\t\t\t\t\t\t\\'
-		print 'GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\'
-		print 'GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\'
-		print '\tCALL(_x86_get_dispatch) ;\t\t\t\\'
-		print '\tCTX_INSNS ;					\\'
-		print '\tJMP(GL_OFFSET(off))'
-		print ''
-		print '#elif defined(PTHREADS)'
-		print '#  define GL_STUB(fn,off,fn_alt)\t\t\t\\'
-		print 'ALIGNTEXT16;\t\t\t\t\t\t\\'
-		print 'GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\'
-		print 'GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\'
-		print '\tMOV_L(CONTENT(GLNAME(_glapi_Dispatch)), EAX) ;\t\\'
-		print '\tTEST_L(EAX, EAX) ;\t\t\t\t\\'
-		print '\tJE(1f) ;\t\t\t\t\t\\'
-		print '\tJMP(GL_OFFSET(off)) ;\t\t\t\t\\'
-		print '1:\tCALL(_x86_get_dispatch) ;\t\t\t\\'
-		print '\tJMP(GL_OFFSET(off))'
-		print '#elif defined(THREADS)'
-		print '#  define GL_STUB(fn,off,fn_alt)\t\t\t\\'
-		print 'ALIGNTEXT16;\t\t\t\t\t\t\\'
-		print 'GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\'
-		print 'GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\'
-		print '\tMOV_L(CONTENT(GLNAME(_glapi_Dispatch)), EAX) ;\t\\'
-		print '\tTEST_L(EAX, EAX) ;\t\t\t\t\\'
-		print '\tJE(1f) ;\t\t\t\t\t\\'
-		print '\tJMP(GL_OFFSET(off)) ;\t\t\t\t\\'
-		print '1:\tCALL(_glapi_get_dispatch) ;\t\t\t\\'
-		print '\tJMP(GL_OFFSET(off))'
-		print '#else /* Non-threaded version. */'
-		print '#  define GL_STUB(fn,off,fn_alt)\t\t\t\\'
-		print 'ALIGNTEXT16;\t\t\t\t\t\t\\'
-		print 'GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\'
-		print 'GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\'
-		print '\tMOV_L(CONTENT(GLNAME(_glapi_Dispatch)), EAX) ;\t\\'
-		print '\tJMP(GL_OFFSET(off))'
-		print '#endif'
-		print ''
-		print '#ifdef HAVE_ALIAS'
-		print '#  define GL_STUB_ALIAS(fn,off,fn_alt,alias,alias_alt)\t\\'
-		print '\t.globl\tGL_PREFIX(fn, fn_alt) ;\t\t\t\\'
-		print '\t.set\tGL_PREFIX(fn, fn_alt), GL_PREFIX(alias, alias_alt)'
-		print '#else'
-		print '#  define GL_STUB_ALIAS(fn,off,fn_alt,alias,alias_alt)\t\\'
-		print '    GL_STUB(fn, off, fn_alt)'
-		print '#endif'
-		print ''
-		print 'SEG_TEXT'
-		print ''
-		print '#ifdef GLX_USE_TLS'
-		print ''
-		print '\tGLOBL\tGLNAME(_x86_get_dispatch)'
-		print '\tHIDDEN(GLNAME(_x86_get_dispatch))'
-		print 'ALIGNTEXT16'
-		print 'GLNAME(_x86_get_dispatch):'
-		print '\tcall	1f'
-		print '1:\tpopl	%eax'
-		print '\taddl	$_GLOBAL_OFFSET_TABLE_+[.-1b], %eax'
-		print '\tmovl	_glapi_tls_Dispatch@GOTNTPOFF(%eax), %eax'
-		print '\tret'
-		print ''
-		print '#elif defined(PTHREADS)'
-		print 'EXTERN GLNAME(_glapi_Dispatch)'
-		print 'EXTERN GLNAME(_gl_DispatchTSD)'
-		print 'EXTERN GLNAME(pthread_getspecific)'
-		print ''
-		print 'ALIGNTEXT16'
-		print 'GLNAME(_x86_get_dispatch):'
-		print '\tSUB_L(CONST(24), ESP)'
-		print '\tPUSH_L(GLNAME(_gl_DispatchTSD))'
-		print '\tCALL(GLNAME(pthread_getspecific))'
-		print '\tADD_L(CONST(28), ESP)'
-		print '\tRET'
-		print '#elif defined(THREADS)'
-		print 'EXTERN GLNAME(_glapi_get_dispatch)'
-		print '#endif'
-		print ''
+		print('#include "x86/assyntax.h"')
+		print('')
+		print('#if defined(STDCALL_API)')
+		print('# if defined(USE_MGL_NAMESPACE)')
+		print('#  define GL_PREFIX(n,n2) GLNAME(CONCAT(mgl,n2))')
+		print('# else')
+		print('#  define GL_PREFIX(n,n2) GLNAME(CONCAT(gl,n2))')
+		print('# endif')
+		print('#else')
+		print('# if defined(USE_MGL_NAMESPACE)')
+		print('#  define GL_PREFIX(n,n2) GLNAME(CONCAT(mgl,n))')
+		print('#  define _glapi_Dispatch _mglapi_Dispatch')
+		print('# else')
+		print('#  define GL_PREFIX(n,n2) GLNAME(CONCAT(gl,n))')
+		print('# endif')
+		print('#endif')
+		print('')
+		print('#define GL_OFFSET(x) CODEPTR(REGOFF(4 * x, EAX))')
+		print('')
+		print('#if defined(GNU_ASSEMBLER) && !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__)')
+		print('#define GLOBL_FN(x) GLOBL x ; .type x, @function')
+		print('#else')
+		print('#define GLOBL_FN(x) GLOBL x')
+		print('#endif')
+		print('')
+		print('#if defined(PTHREADS) || defined(WIN32) || defined(BEOS_THREADS)')
+		print('#  define THREADS')
+		print('#endif')
+		print('')
+		print('#ifdef GLX_USE_TLS')
+		print('')
+		print('#ifdef GLX_X86_READONLY_TEXT')
+		print('# define CTX_INSNS MOV_L(GS:(EAX), EAX)')
+		print('#else')
+		print('# define CTX_INSNS NOP /* Pad for init_glapi_relocs() */')
+		print('#endif')
+		print('')
+		print('#  define GL_STUB(fn,off,fn_alt)\t\t\t\\')
+		print('ALIGNTEXT16;\t\t\t\t\t\t\\')
+		print('GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\')
+		print('GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\')
+		print('\tCALL(_x86_get_dispatch) ;\t\t\t\\')
+		print('\tCTX_INSNS ;					\\')
+		print('\tJMP(GL_OFFSET(off))')
+		print('')
+		print('#elif defined(PTHREADS)')
+		print('#  define GL_STUB(fn,off,fn_alt)\t\t\t\\')
+		print('ALIGNTEXT16;\t\t\t\t\t\t\\')
+		print('GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\')
+		print('GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\')
+		print('\tMOV_L(CONTENT(GLNAME(_glapi_Dispatch)), EAX) ;\t\\')
+		print('\tTEST_L(EAX, EAX) ;\t\t\t\t\\')
+		print('\tJE(1f) ;\t\t\t\t\t\\')
+		print('\tJMP(GL_OFFSET(off)) ;\t\t\t\t\\')
+		print('1:\tCALL(_x86_get_dispatch) ;\t\t\t\\')
+		print('\tJMP(GL_OFFSET(off))')
+		print('#elif defined(THREADS)')
+		print('#  define GL_STUB(fn,off,fn_alt)\t\t\t\\')
+		print('ALIGNTEXT16;\t\t\t\t\t\t\\')
+		print('GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\')
+		print('GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\')
+		print('\tMOV_L(CONTENT(GLNAME(_glapi_Dispatch)), EAX) ;\t\\')
+		print('\tTEST_L(EAX, EAX) ;\t\t\t\t\\')
+		print('\tJE(1f) ;\t\t\t\t\t\\')
+		print('\tJMP(GL_OFFSET(off)) ;\t\t\t\t\\')
+		print('1:\tCALL(_glapi_get_dispatch) ;\t\t\t\\')
+		print('\tJMP(GL_OFFSET(off))')
+		print('#else /* Non-threaded version. */')
+		print('#  define GL_STUB(fn,off,fn_alt)\t\t\t\\')
+		print('ALIGNTEXT16;\t\t\t\t\t\t\\')
+		print('GLOBL_FN(GL_PREFIX(fn, fn_alt));\t\t\t\\')
+		print('GL_PREFIX(fn, fn_alt):\t\t\t\t\t\\')
+		print('\tMOV_L(CONTENT(GLNAME(_glapi_Dispatch)), EAX) ;\t\\')
+		print('\tJMP(GL_OFFSET(off))')
+		print('#endif')
+		print('')
+		print('#ifdef HAVE_ALIAS')
+		print('#  define GL_STUB_ALIAS(fn,off,fn_alt,alias,alias_alt)\t\\')
+		print('\t.globl\tGL_PREFIX(fn, fn_alt) ;\t\t\t\\')
+		print('\t.set\tGL_PREFIX(fn, fn_alt), GL_PREFIX(alias, alias_alt)')
+		print('#else')
+		print('#  define GL_STUB_ALIAS(fn,off,fn_alt,alias,alias_alt)\t\\')
+		print('    GL_STUB(fn, off, fn_alt)')
+		print('#endif')
+		print('')
+		print('SEG_TEXT')
+		print('')
+		print('#ifdef GLX_USE_TLS')
+		print('')
+		print('\tGLOBL\tGLNAME(_x86_get_dispatch)')
+		print('\tHIDDEN(GLNAME(_x86_get_dispatch))')
+		print('ALIGNTEXT16')
+		print('GLNAME(_x86_get_dispatch):')
+		print('\tcall	1f')
+		print('1:\tpopl	%eax')
+		print('\taddl	$_GLOBAL_OFFSET_TABLE_+[.-1b], %eax')
+		print('\tmovl	_glapi_tls_Dispatch@GOTNTPOFF(%eax), %eax')
+		print('\tret')
+		print('')
+		print('#elif defined(PTHREADS)')
+		print('EXTERN GLNAME(_glapi_Dispatch)')
+		print('EXTERN GLNAME(_gl_DispatchTSD)')
+		print('EXTERN GLNAME(pthread_getspecific)')
+		print('')
+		print('ALIGNTEXT16')
+		print('GLNAME(_x86_get_dispatch):')
+		print('\tSUB_L(CONST(24), ESP)')
+		print('\tPUSH_L(GLNAME(_gl_DispatchTSD))')
+		print('\tCALL(GLNAME(pthread_getspecific))')
+		print('\tADD_L(CONST(28), ESP)')
+		print('\tRET')
+		print('#elif defined(THREADS)')
+		print('EXTERN GLNAME(_glapi_get_dispatch)')
+		print('#endif')
+		print('')
 
-		print '#if defined( GLX_USE_TLS ) && !defined( GLX_X86_READONLY_TEXT )'
-		print '\t\t.section\twtext, "awx", @progbits'
-		print '#endif /* defined( GLX_USE_TLS ) */'
+		print('#if defined( GLX_USE_TLS ) && !defined( GLX_X86_READONLY_TEXT )')
+		print('\t\t.section\twtext, "awx", @progbits')
+		print('#endif /* defined( GLX_USE_TLS ) */')
 
-		print ''
-		print '\t\tALIGNTEXT16'
-		print '\t\tGLOBL GLNAME(gl_dispatch_functions_start)'
-		print '\t\tHIDDEN(GLNAME(gl_dispatch_functions_start))'
-		print 'GLNAME(gl_dispatch_functions_start):'
-		print ''
+		print('')
+		print('\t\tALIGNTEXT16')
+		print('\t\tGLOBL GLNAME(gl_dispatch_functions_start)')
+		print('\t\tHIDDEN(GLNAME(gl_dispatch_functions_start))')
+		print('GLNAME(gl_dispatch_functions_start):')
+		print('')
 		return
 
 
 	def printRealFooter(self):
-		print ''
-		print '\t\tGLOBL\tGLNAME(gl_dispatch_functions_end)'
-		print '\t\tHIDDEN(GLNAME(gl_dispatch_functions_end))'
-		print '\t\tALIGNTEXT16'
-		print 'GLNAME(gl_dispatch_functions_end):'
-		print ''
-		print '#if defined(GLX_USE_TLS) && defined(__linux__)'
-		print '	.section ".note.ABI-tag", "a"'
-		print '	.p2align 2'
-		print '	.long	1f - 0f   /* name length */'
-		print '	.long	3f - 2f   /* data length */'
-		print '	.long	1         /* note length */'
-		print '0:	.asciz "GNU"      /* vendor name */'
-		print '1:	.p2align 2'
-		print '2:	.long	0         /* note data: the ABI tag */'
-		print '	.long	2,4,20    /* Minimum kernel version w/TLS */'
-		print '3:	.p2align 2        /* pad out section */'
-		print '#endif /* GLX_USE_TLS */'
-		print ''
-		print '#if defined (__ELF__) && defined (__linux__)'
-		print '	.section .note.GNU-stack,"",%progbits'
-		print '#endif'
+		print('')
+		print('\t\tGLOBL\tGLNAME(gl_dispatch_functions_end)')
+		print('\t\tHIDDEN(GLNAME(gl_dispatch_functions_end))')
+		print('\t\tALIGNTEXT16')
+		print('GLNAME(gl_dispatch_functions_end):')
+		print('')
+		print('#if defined(GLX_USE_TLS) && defined(__linux__)')
+		print('	.section ".note.ABI-tag", "a"')
+		print('	.p2align 2')
+		print('	.long	1f - 0f   /* name length */')
+		print('	.long	3f - 2f   /* data length */')
+		print('	.long	1         /* note length */')
+		print('0:	.asciz "GNU"      /* vendor name */')
+		print('1:	.p2align 2')
+		print('2:	.long	0         /* note data: the ABI tag */')
+		print('	.long	2,4,20    /* Minimum kernel version w/TLS */')
+		print('3:	.p2align 2        /* pad out section */')
+		print('#endif /* GLX_USE_TLS */')
+		print('')
+		print('#if defined (__ELF__) && defined (__linux__)')
+		print('	.section .note.GNU-stack,"",%progbits')
+		print('#endif')
 		return
 
 
@@ -214,10 +214,10 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 			stack = self.get_stack_size(f)
 			alt = "%s@%u" % (name, stack)
 
-			print '\tGL_STUB(%s, %d, %s)' % (name, f.offset, alt)
+			print('\tGL_STUB(%s, %d, %s)' % (name, f.offset, alt))
 
 			if not f.is_static_entry_point(f.name):
-				print '\tHIDDEN(GL_PREFIX(%s, %s))' % (name, alt)
+				print('\tHIDDEN(GL_PREFIX(%s, %s))' % (name, alt))
 
 
 		for f in api.functionIterateByOffset():
@@ -232,16 +232,16 @@ class PrintGenericStubs(gl_XML.gl_print_base):
 						text = '\tGL_STUB_ALIAS(%s, %d, %s, %s, %s)' % (n, f.offset, alt2, name, alt)
 
 						if f.has_different_protocol(n):
-							print '#ifndef GLX_INDIRECT_RENDERING'
-							print text
-							print '#endif'
+							print('#ifndef GLX_INDIRECT_RENDERING')
+							print(text)
+							print('#endif')
 						else:
-							print text
+							print(text)
 
 		return
 
 def show_usage():
-	print "Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0]
+	print("Usage: %s [-f input_file_name] [-m output_mode]" % sys.argv[0])
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -250,10 +250,10 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "m:f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == '-m':
 			mode = val
 		elif arg == "-f":
@@ -262,7 +262,7 @@ if __name__ == '__main__':
 	if mode == "generic":
 		printer = PrintGenericStubs()
 	else:
-		print "ERROR: Invalid mode \"%s\" specified." % mode
+		print("ERROR: Invalid mode \"%s\" specified." % mode)
 		show_usage()
 
 	api = gl_XML.parse_GL_API(file_name, glX_XML.glx_item_factory())
diff --git a/src/mapi/glapi/gen/mesadef.py b/src/mapi/glapi/gen/mesadef.py
index 38b0246..38aabe8 100644
--- a/src/mapi/glapi/gen/mesadef.py
+++ b/src/mapi/glapi/gen/mesadef.py
@@ -40,147 +40,147 @@ import string
 
 
 def PrintHead():
-	print '; DO NOT EDIT - This file generated automatically by mesadef.py script'
-	print 'DESCRIPTION \'Mesa (OpenGL work-alike) for Win32\''
-	print 'VERSION 6.0'
-	print ';'
-	print '; Module definition file for Mesa (OPENGL32.DLL)'
-	print ';'
-	print '; Note: The OpenGL functions use the STDCALL'
-	print '; function calling convention.  Microsoft\'s'
-	print '; OPENGL32 uses this convention and so must the'
-	print '; Mesa OPENGL32 so that the Mesa DLL can be used'
-	print '; as a drop-in replacement.'
-	print ';'
-	print '; The linker exports STDCALL entry points with'
-	print '; \'decorated\' names; e.g., _glBegin@0, where the'
-	print '; trailing number is the number of bytes of '
-	print '; parameter data pushed onto the stack.  The'
-	print '; callee is responsible for popping this data'
-	print '; off the stack, usually via a RETF n instruction.'
-	print ';'
-	print '; However, the Microsoft OPENGL32.DLL does not export'
-	print '; the decorated names, even though the calling convention'
-	print '; is STDCALL.  So, this module definition file is'
-	print '; needed to force the Mesa OPENGL32.DLL to export the'
-	print '; symbols in the same manner as the Microsoft DLL.'
-	print '; Were it not for this problem, this file would not'
-	print '; be needed (for the gl* functions) since the entry'
-	print '; points are compiled with dllexport declspec.'
-	print ';'
-	print '; However, this file is still needed to export "internal"'
-	print '; Mesa symbols for the benefit of the OSMESA32.DLL.'
-	print ';'
-	print 'EXPORTS'
+	print('; DO NOT EDIT - This file generated automatically by mesadef.py script')
+	print('DESCRIPTION \'Mesa (OpenGL work-alike) for Win32\'')
+	print('VERSION 6.0')
+	print(';')
+	print('; Module definition file for Mesa (OPENGL32.DLL)')
+	print(';')
+	print('; Note: The OpenGL functions use the STDCALL')
+	print('; function calling convention.  Microsoft\'s')
+	print('; OPENGL32 uses this convention and so must the')
+	print('; Mesa OPENGL32 so that the Mesa DLL can be used')
+	print('; as a drop-in replacement.')
+	print(';')
+	print('; The linker exports STDCALL entry points with')
+	print('; \'decorated\' names; e.g., _glBegin@0, where the')
+	print('; trailing number is the number of bytes of ')
+	print('; parameter data pushed onto the stack.  The')
+	print('; callee is responsible for popping this data')
+	print('; off the stack, usually via a RETF n instruction.')
+	print(';')
+	print('; However, the Microsoft OPENGL32.DLL does not export')
+	print('; the decorated names, even though the calling convention')
+	print('; is STDCALL.  So, this module definition file is')
+	print('; needed to force the Mesa OPENGL32.DLL to export the')
+	print('; symbols in the same manner as the Microsoft DLL.')
+	print('; Were it not for this problem, this file would not')
+	print('; be needed (for the gl* functions) since the entry')
+	print('; points are compiled with dllexport declspec.')
+	print(';')
+	print('; However, this file is still needed to export "internal"')
+	print('; Mesa symbols for the benefit of the OSMESA32.DLL.')
+	print(';')
+	print('EXPORTS')
 	return
 #enddef
 
 
 def PrintTail():
-	print ';'
-	print '; WGL API'
-	print '\twglChoosePixelFormat'
-	print '\twglCopyContext'
-	print '\twglCreateContext'
-	print '\twglCreateLayerContext'
-	print '\twglDeleteContext'
-	print '\twglDescribeLayerPlane'
-	print '\twglDescribePixelFormat'
-	print '\twglGetCurrentContext'
-	print '\twglGetCurrentDC'
-	print '\twglGetExtensionsStringARB'
-	print '\twglGetLayerPaletteEntries'
-	print '\twglGetPixelFormat'
-	print '\twglGetProcAddress'
-	print '\twglMakeCurrent'
-	print '\twglRealizeLayerPalette'
-	print '\twglSetLayerPaletteEntries'
-	print '\twglSetPixelFormat'
-	print '\twglShareLists'
-	print '\twglSwapBuffers'
-	print '\twglSwapLayerBuffers'
-	print '\twglUseFontBitmapsA'
-	print '\twglUseFontBitmapsW'
-	print '\twglUseFontOutlinesA'
-	print '\twglUseFontOutlinesW'
-	print ';'
-	print '; Mesa internals - mostly for OSMESA'
-	print '\t_ac_CreateContext'
-	print '\t_ac_DestroyContext'
-	print '\t_ac_InvalidateState'
-	print '\t_glapi_get_context'
-	print '\t_glapi_get_proc_address'
-	print '\t_mesa_buffer_data'
-	print '\t_mesa_buffer_map'
-	print '\t_mesa_buffer_subdata'
-	print '\t_mesa_choose_tex_format'
-	print '\t_mesa_compressed_texture_size'
-	print '\t_mesa_create_framebuffer'
-	print '\t_mesa_create_visual'
-	print '\t_mesa_delete_buffer_object'
-	print '\t_mesa_delete_texture_object'
-	print '\t_mesa_destroy_framebuffer'
-	print '\t_mesa_destroy_visual'
-	print '\t_mesa_enable_1_3_extensions'
-	print '\t_mesa_enable_1_4_extensions'
-	print '\t_mesa_enable_1_5_extensions'
-	print '\t_mesa_enable_sw_extensions'
-	print '\t_mesa_error'
-	print '\t_mesa_free_context_data'
-	print '\t_mesa_get_current_context'
-	print '\t_mesa_init_default_imports'
-	print '\t_mesa_initialize_context'
-	print '\t_mesa_make_current'
-	print '\t_mesa_new_buffer_object'
-	print '\t_mesa_new_texture_object'
-	print '\t_mesa_problem'
-	print '\t_mesa_ResizeBuffersMESA'
-	print '\t_mesa_store_compressed_teximage1d'
-	print '\t_mesa_store_compressed_teximage2d'
-	print '\t_mesa_store_compressed_teximage3d'
-	print '\t_mesa_store_compressed_texsubimage1d'
-	print '\t_mesa_store_compressed_texsubimage2d'
-	print '\t_mesa_store_compressed_texsubimage3d'
-	print '\t_mesa_store_teximage1d'
-	print '\t_mesa_store_teximage2d'
-	print '\t_mesa_store_teximage3d'
-	print '\t_mesa_store_texsubimage1d'
-	print '\t_mesa_store_texsubimage2d'
-	print '\t_mesa_store_texsubimage3d'
-	print '\t_mesa_test_proxy_teximage'
-	print '\t_mesa_Viewport'
-	print '\t_mesa_meta_CopyColorSubTable'
-	print '\t_mesa_meta_CopyColorTable'
-	print '\t_mesa_meta_CopyConvolutionFilter1D'
-	print '\t_mesa_meta_CopyConvolutionFilter2D'
-	print '\t_mesa_meta_CopyTexImage1D'
-	print '\t_mesa_meta_CopyTexImage2D'
-	print '\t_mesa_meta_CopyTexSubImage1D'
-	print '\t_mesa_meta_CopyTexSubImage2D'
-	print '\t_mesa_meta_CopyTexSubImage3D'
-	print '\t_swrast_Accum'
-	print '\t_swrast_alloc_buffers'
-	print '\t_swrast_Bitmap'
-	print '\t_swrast_CopyPixels'
-	print '\t_swrast_DrawPixels'
-	print '\t_swrast_GetDeviceDriverReference'
-	print '\t_swrast_Clear'
-	print '\t_swrast_choose_line'
-	print '\t_swrast_choose_triangle'
-	print '\t_swrast_CreateContext'
-	print '\t_swrast_DestroyContext'
-	print '\t_swrast_InvalidateState'
-	print '\t_swrast_ReadPixels'
-	print '\t_swrast_zbuffer_address'
-	print '\t_swsetup_Wakeup'
-	print '\t_swsetup_CreateContext'
-	print '\t_swsetup_DestroyContext'
-	print '\t_swsetup_InvalidateState'
-	print '\t_tnl_CreateContext'
-	print '\t_tnl_DestroyContext'
-	print '\t_tnl_InvalidateState'
-	print '\t_tnl_MakeCurrent'
-	print '\t_tnl_run_pipeline'
+	print(';')
+	print('; WGL API')
+	print('\twglChoosePixelFormat')
+	print('\twglCopyContext')
+	print('\twglCreateContext')
+	print('\twglCreateLayerContext')
+	print('\twglDeleteContext')
+	print('\twglDescribeLayerPlane')
+	print('\twglDescribePixelFormat')
+	print('\twglGetCurrentContext')
+	print('\twglGetCurrentDC')
+	print('\twglGetExtensionsStringARB')
+	print('\twglGetLayerPaletteEntries')
+	print('\twglGetPixelFormat')
+	print('\twglGetProcAddress')
+	print('\twglMakeCurrent')
+	print('\twglRealizeLayerPalette')
+	print('\twglSetLayerPaletteEntries')
+	print('\twglSetPixelFormat')
+	print('\twglShareLists')
+	print('\twglSwapBuffers')
+	print('\twglSwapLayerBuffers')
+	print('\twglUseFontBitmapsA')
+	print('\twglUseFontBitmapsW')
+	print('\twglUseFontOutlinesA')
+	print('\twglUseFontOutlinesW')
+	print(';')
+	print('; Mesa internals - mostly for OSMESA')
+	print('\t_ac_CreateContext')
+	print('\t_ac_DestroyContext')
+	print('\t_ac_InvalidateState')
+	print('\t_glapi_get_context')
+	print('\t_glapi_get_proc_address')
+	print('\t_mesa_buffer_data')
+	print('\t_mesa_buffer_map')
+	print('\t_mesa_buffer_subdata')
+	print('\t_mesa_choose_tex_format')
+	print('\t_mesa_compressed_texture_size')
+	print('\t_mesa_create_framebuffer')
+	print('\t_mesa_create_visual')
+	print('\t_mesa_delete_buffer_object')
+	print('\t_mesa_delete_texture_object')
+	print('\t_mesa_destroy_framebuffer')
+	print('\t_mesa_destroy_visual')
+	print('\t_mesa_enable_1_3_extensions')
+	print('\t_mesa_enable_1_4_extensions')
+	print('\t_mesa_enable_1_5_extensions')
+	print('\t_mesa_enable_sw_extensions')
+	print('\t_mesa_error')
+	print('\t_mesa_free_context_data')
+	print('\t_mesa_get_current_context')
+	print('\t_mesa_init_default_imports')
+	print('\t_mesa_initialize_context')
+	print('\t_mesa_make_current')
+	print('\t_mesa_new_buffer_object')
+	print('\t_mesa_new_texture_object')
+	print('\t_mesa_problem')
+	print('\t_mesa_ResizeBuffersMESA')
+	print('\t_mesa_store_compressed_teximage1d')
+	print('\t_mesa_store_compressed_teximage2d')
+	print('\t_mesa_store_compressed_teximage3d')
+	print('\t_mesa_store_compressed_texsubimage1d')
+	print('\t_mesa_store_compressed_texsubimage2d')
+	print('\t_mesa_store_compressed_texsubimage3d')
+	print('\t_mesa_store_teximage1d')
+	print('\t_mesa_store_teximage2d')
+	print('\t_mesa_store_teximage3d')
+	print('\t_mesa_store_texsubimage1d')
+	print('\t_mesa_store_texsubimage2d')
+	print('\t_mesa_store_texsubimage3d')
+	print('\t_mesa_test_proxy_teximage')
+	print('\t_mesa_Viewport')
+	print('\t_mesa_meta_CopyColorSubTable')
+	print('\t_mesa_meta_CopyColorTable')
+	print('\t_mesa_meta_CopyConvolutionFilter1D')
+	print('\t_mesa_meta_CopyConvolutionFilter2D')
+	print('\t_mesa_meta_CopyTexImage1D')
+	print('\t_mesa_meta_CopyTexImage2D')
+	print('\t_mesa_meta_CopyTexSubImage1D')
+	print('\t_mesa_meta_CopyTexSubImage2D')
+	print('\t_mesa_meta_CopyTexSubImage3D')
+	print('\t_swrast_Accum')
+	print('\t_swrast_alloc_buffers')
+	print('\t_swrast_Bitmap')
+	print('\t_swrast_CopyPixels')
+	print('\t_swrast_DrawPixels')
+	print('\t_swrast_GetDeviceDriverReference')
+	print('\t_swrast_Clear')
+	print('\t_swrast_choose_line')
+	print('\t_swrast_choose_triangle')
+	print('\t_swrast_CreateContext')
+	print('\t_swrast_DestroyContext')
+	print('\t_swrast_InvalidateState')
+	print('\t_swrast_ReadPixels')
+	print('\t_swrast_zbuffer_address')
+	print('\t_swsetup_Wakeup')
+	print('\t_swsetup_CreateContext')
+	print('\t_swsetup_DestroyContext')
+	print('\t_swsetup_InvalidateState')
+	print('\t_tnl_CreateContext')
+	print('\t_tnl_DestroyContext')
+	print('\t_tnl_InvalidateState')
+	print('\t_tnl_MakeCurrent')
+	print('\t_tnl_run_pipeline')
 #enddef
 
 
@@ -204,7 +204,7 @@ def EmitEntry(name, returnType, argTypeList, argNameList, alias, offset):
 	if offset < 0:
 		offset = FindOffset(dispatchName)
 	if offset >= 0 and string.find(name, "unused") == -1:
-		print '\tgl%s' % (name)
+		print('\tgl%s' % (name))
 		# save this info in case we need to look up an alias later
 		records.append((name, dispatchName, offset))
 
diff --git a/src/mapi/glapi/gen/remap_helper.py b/src/mapi/glapi/gen/remap_helper.py
index 69b8e5e..7595966 100644
--- a/src/mapi/glapi/gen/remap_helper.py
+++ b/src/mapi/glapi/gen/remap_helper.py
@@ -64,19 +64,19 @@ class PrintGlRemap(gl_XML.gl_print_base):
 
 
 	def printRealHeader(self):
-		print '#include "main/dispatch.h"'
-		print '#include "main/remap.h"'
-		print ''
+		print('#include "main/dispatch.h"')
+		print('#include "main/remap.h"')
+		print('')
 		return
 
 
 	def printBody(self, api):
 		pool_indices = {}
 
-		print '/* this is internal to remap.c */'
-		print '#ifdef need_MESA_remap_table'
-		print ''
-		print 'static const char _mesa_function_pool[] ='
+		print('/* this is internal to remap.c */')
+		print('#ifdef need_MESA_remap_table')
+		print('')
+		print('static const char _mesa_function_pool[] =')
 
 		# output string pool
 		index = 0;
@@ -94,26 +94,26 @@ class PrintGlRemap(gl_XML.gl_print_base):
 			else:
 				comments = "dynamic"
 
-			print '   /* _mesa_function_pool[%d]: %s (%s) */' \
-					% (index, f.name, comments)
+			print('   /* _mesa_function_pool[%d]: %s (%s) */' \
+					% (index, f.name, comments))
 			for line in spec:
-				print '   "%s\\0"' % line
+				print('   "%s\\0"' % line)
 				index += len(line) + 1
-		print '   ;'
-		print ''
+		print('   ;')
+		print('')
 
-		print '/* these functions need to be remapped */'
-		print 'static const struct gl_function_pool_remap MESA_remap_table_functions[] = {'
+		print('/* these functions need to be remapped */')
+		print('static const struct gl_function_pool_remap MESA_remap_table_functions[] = {')
 		# output all functions that need to be remapped
 		# iterate by offsets so that they are sorted by remap indices
 		for f in api.functionIterateByOffset():
 			if not f.assign_offset:
 				continue
-			print '   { %5d, %s_remap_index },' \
-					% (pool_indices[f], f.name)
-		print '   {    -1, -1 }'
-		print '};'
-		print ''
+			print('   { %5d, %s_remap_index },' \
+					% (pool_indices[f], f.name))
+		print('   {    -1, -1 }')
+		print('};')
+		print('')
 
 		# collect functions by versions/extensions
 		extension_functions = {}
@@ -124,7 +124,7 @@ class PrintGlRemap(gl_XML.gl_print_base):
 				# consider only GL_VERSION_X_Y or extensions
 				c = gl_XML.real_category_name(category)
 				if c.startswith("GL_"):
-					if not extension_functions.has_key(c):
+					if c not in extension_functions:
 						extension_functions[c] = []
 					extension_functions[c].append(f)
 					# remember the ext names of the ABI
@@ -135,12 +135,11 @@ class PrintGlRemap(gl_XML.gl_print_base):
 		for ext in abi_extensions:
 			extension_functions.pop(ext)
 
-		extensions = extension_functions.keys()
-		extensions.sort()
+		extensions = sorted(extension_functions.keys())
 
 		# output ABI functions that have alternative names (with ext suffix)
-		print '/* these functions are in the ABI, but have alternative names */'
-		print 'static const struct gl_function_remap MESA_alt_functions[] = {'
+		print('/* these functions are in the ABI, but have alternative names */')
+		print('static const struct gl_function_remap MESA_alt_functions[] = {')
 		for ext in extensions:
 			funcs = []
 			for f in extension_functions[ext]:
@@ -149,16 +148,16 @@ class PrintGlRemap(gl_XML.gl_print_base):
 					funcs.append(f)
 			if not funcs:
 				continue
-			print '   /* from %s */' % ext
+			print('   /* from %s */' % ext)
 			for f in funcs:
-				print '   { %5d, _gloffset_%s },' \
-						% (pool_indices[f], f.name)
-		print '   {    -1, -1 }'
-		print '};'
-		print ''
+				print('   { %5d, _gloffset_%s },' \
+						% (pool_indices[f], f.name))
+		print('   {    -1, -1 }')
+		print('};')
+		print('')
 
-		print '#endif /* need_MESA_remap_table */'
-		print ''
+		print('#endif /* need_MESA_remap_table */')
+		print('')
 
 		# output remap helpers for DRI drivers
 
@@ -174,30 +173,30 @@ class PrintGlRemap(gl_XML.gl_print_base):
 					# abi, or have offset -1
 					funcs.append(f)
 
-			print '#if defined(need_%s)' % (ext)
+			print('#if defined(need_%s)' % (ext))
 			if remapped:
-				print '/* functions defined in MESA_remap_table_functions are excluded */'
+				print('/* functions defined in MESA_remap_table_functions are excluded */')
 
 			# output extension functions that need to be mapped
-			print 'static const struct gl_function_remap %s_functions[] = {' % (ext)
+			print('static const struct gl_function_remap %s_functions[] = {' % (ext))
 			for f in funcs:
 				if f.offset >= 0:
-					print '   { %5d, _gloffset_%s },' \
-							% (pool_indices[f], f.name)
+					print('   { %5d, _gloffset_%s },' \
+							% (pool_indices[f], f.name))
 				else:
-					print '   { %5d, -1 }, /* %s */' % \
-							(pool_indices[f], f.name)
-			print '   {    -1, -1 }'
-			print '};'
+					print('   { %5d, -1 }, /* %s */' % \
+							(pool_indices[f], f.name))
+			print('   {    -1, -1 }')
+			print('};')
 
-			print '#endif'
-			print ''
+			print('#endif')
+			print('')
 
 		return
 
 
 def show_usage():
-	print "Usage: %s [-f input_file_name]" % sys.argv[0]
+	print("Usage: %s [-f input_file_name]" % sys.argv[0])
 	sys.exit(1)
 
 if __name__ == '__main__':
@@ -205,10 +204,10 @@ if __name__ == '__main__':
 
 	try:
 		(args, trail) = getopt.getopt(sys.argv[1:], "f:")
-	except Exception,e:
+	except Exception as e:
 		show_usage()
 
-	for (arg,val) in args:
+	for (arg, val) in args:
 		if arg == "-f":
 			file_name = val
 
diff --git a/src/mapi/glapi/gen/typeexpr.py b/src/mapi/glapi/gen/typeexpr.py
index 8ba7de4..67cbc98 100644
--- a/src/mapi/glapi/gen/typeexpr.py
+++ b/src/mapi/glapi/gen/typeexpr.py
@@ -125,7 +125,7 @@ class type_expression:
 
 		# Replace '*' with ' * ' in type_string.  Then, split the string
 		# into tokens, separated by spaces.
-		tokens = string.split( string.replace( type_string, "*", " * " ) )
+		tokens = type_string.replace("*", " * " ).split()
 
 		const = 0
 		t = None
@@ -287,6 +287,6 @@ if __name__ == '__main__':
 	create_initial_types()
 
 	for t in types_to_try:
-		print 'Trying "%s"...' % (t)
+		print('Trying "%s"...' % (t))
 		te = type_expression( t )
-		print 'Got "%s" (%u, %u).' % (te.string(), te.get_stack_size(), te.get_element_size())
+		print('Got "%s" (%u, %u).' % (te.string(), te.get_stack_size(), te.get_element_size()))
diff --git a/src/mapi/mapi/mapi_abi.py b/src/mapi/mapi/mapi_abi.py
index cb9fc0e..cb56506 100644
--- a/src/mapi/mapi/mapi_abi.py
+++ b/src/mapi/mapi/mapi_abi.py
@@ -26,6 +26,7 @@
 # Authors:
 #    Chia-I Wu <olv@lunarg.com>
 
+from operator import attrgetter
 import sys
 import re
 from optparse import OptionParser
@@ -112,19 +113,17 @@ class ABIEntry(object):
     def __str__(self):
         return self.c_prototype()
 
-    def __cmp__(self, other):
+    def __lt__(self, other):
         # compare slot, alias, and then name
-        res = cmp(self.slot, other.slot)
-        if not res:
+        if self.slot == other.slot:
             if not self.alias:
-                res = -1
+                return True
             elif not other.alias:
-                res = 1
+                return False
 
-            if not res:
-                res = cmp(self.name, other.name)
+            return self.name < other.name
 
-        return res
+        return self.slot < other.slot
 
 def abi_parse_xml(xml):
     """Parse a GLAPI XML file for ABI entries."""
@@ -164,7 +163,7 @@ def abi_parse_xml(xml):
             else:
                 attrs['handcode'] = None
 
-            if entry_dict.has_key(name):
+            if name in entry_dict:
                 raise Exception('%s is duplicated' % (name))
 
             cols = []
@@ -176,8 +175,7 @@ def abi_parse_xml(xml):
             ent = ABIEntry(cols, attrs)
             entry_dict[ent.name] = ent
 
-    entries = entry_dict.values()
-    entries.sort()
+    entries = sorted(entry_dict.values())
 
     return entries
 
@@ -242,12 +240,11 @@ def abi_parse(filename):
             raise Exception('invalid slot in %s' % (line))
 
         ent = ABIEntry(cols, attrs)
-        if entry_dict.has_key(ent.name):
+        if ent.name in entry_dict:
             raise Exception('%s is duplicated' % (ent.name))
         entry_dict[ent.name] = ent
 
-    entries = entry_dict.values()
-    entries.sort()
+    entries = sorted(entry_dict.values())
 
     return entries
 
@@ -258,7 +255,7 @@ def abi_sanity_check(entries):
     all_names = []
     last_slot = entries[-1].slot
     i = 0
-    for slot in xrange(last_slot + 1):
+    for slot in range(last_slot + 1):
         if entries[i].slot != slot:
             raise Exception('entries are not ordered by slots')
         if entries[i].alias:
@@ -289,8 +286,7 @@ class ABIPrinter(object):
         self.entries = entries
 
         # sort entries by their names
-        self.entries_sorted_by_names = self.entries[:]
-        self.entries_sorted_by_names.sort(lambda x, y: cmp(x.name, y.name))
+        self.entries_sorted_by_names = sorted(self.entries, key=attrgetter('name'))
 
         self.indent = ' ' * 3
         self.noop_warn = 'noop_warn'
@@ -468,8 +464,7 @@ class ABIPrinter(object):
     def c_stub_string_pool(self):
         """Return the string pool for use by stubs."""
         # sort entries by their names
-        sorted_entries = self.entries[:]
-        sorted_entries.sort(lambda x, y: cmp(x.name, y.name))
+        sorted_entries = sorted(self.entries, key=attrgetter('name'))
 
         pool = []
         offsets = {}
@@ -559,79 +554,79 @@ class ABIPrinter(object):
         return "\n".join(asm)
 
     def output_for_lib(self):
-        print self.c_notice()
+        print(self.c_notice())
 
         if self.c_header:
-            print
-            print self.c_header
+            print()
+            print(self.c_header)
 
-        print
-        print '#ifdef MAPI_TMP_DEFINES'
-        print self.c_public_includes()
-        print
-        print self.c_public_declarations(self.prefix_lib)
-        print '#undef MAPI_TMP_DEFINES'
-        print '#endif /* MAPI_TMP_DEFINES */'
+        print()
+        print('#ifdef MAPI_TMP_DEFINES')
+        print(self.c_public_includes())
+        print()
+        print(self.c_public_declarations(self.prefix_lib))
+        print('#undef MAPI_TMP_DEFINES')
+        print('#endif /* MAPI_TMP_DEFINES */')
 
         if self.lib_need_table_size:
-            print
-            print '#ifdef MAPI_TMP_TABLE'
-            print self.c_mapi_table()
-            print '#undef MAPI_TMP_TABLE'
-            print '#endif /* MAPI_TMP_TABLE */'
+            print()
+            print('#ifdef MAPI_TMP_TABLE')
+            print(self.c_mapi_table())
+            print('#undef MAPI_TMP_TABLE')
+            print('#endif /* MAPI_TMP_TABLE */')
 
         if self.lib_need_noop_array:
-            print
-            print '#ifdef MAPI_TMP_NOOP_ARRAY'
-            print '#ifdef DEBUG'
-            print
-            print self.c_noop_functions(self.prefix_noop, self.prefix_warn)
-            print
-            print 'const mapi_func table_%s_array[] = {' % (self.prefix_noop)
-            print self.c_noop_initializer(self.prefix_noop, False)
-            print '};'
-            print
-            print '#else /* DEBUG */'
-            print
-            print 'const mapi_func table_%s_array[] = {' % (self.prefix_noop)
-            print self.c_noop_initializer(self.prefix_noop, True)
-            print '};'
-            print
-            print '#endif /* DEBUG */'
-            print '#undef MAPI_TMP_NOOP_ARRAY'
-            print '#endif /* MAPI_TMP_NOOP_ARRAY */'
+            print()
+            print('#ifdef MAPI_TMP_NOOP_ARRAY')
+            print('#ifdef DEBUG')
+            print()
+            print(self.c_noop_functions(self.prefix_noop, self.prefix_warn))
+            print()
+            print('const mapi_func table_%s_array[] = {' % (self.prefix_noop))
+            print(self.c_noop_initializer(self.prefix_noop, False))
+            print('};')
+            print()
+            print('#else /* DEBUG */')
+            print()
+            print('const mapi_func table_%s_array[] = {' % (self.prefix_noop))
+            print(self.c_noop_initializer(self.prefix_noop, True))
+            print('};')
+            print()
+            print('#endif /* DEBUG */')
+            print('#undef MAPI_TMP_NOOP_ARRAY')
+            print('#endif /* MAPI_TMP_NOOP_ARRAY */')
 
         if self.lib_need_stubs:
             pool, pool_offsets = self.c_stub_string_pool()
-            print
-            print '#ifdef MAPI_TMP_PUBLIC_STUBS'
-            print 'static const char public_string_pool[] ='
-            print pool
-            print
-            print 'static const struct mapi_stub public_stubs[] = {'
-            print self.c_stub_initializer(self.prefix_lib, pool_offsets)
-            print '};'
-            print '#undef MAPI_TMP_PUBLIC_STUBS'
-            print '#endif /* MAPI_TMP_PUBLIC_STUBS */'
+            print()
+            print('#ifdef MAPI_TMP_PUBLIC_STUBS')
+            print('static const char public_string_pool[] =')
+            print(pool)
+            print()
+            print('static const struct mapi_stub public_stubs[] = {')
+            print(self.c_stub_initializer(self.prefix_lib, pool_offsets))
+            print('};')
+            print('#undef MAPI_TMP_PUBLIC_STUBS')
+            print('#endif /* MAPI_TMP_PUBLIC_STUBS */')
 
         if self.lib_need_all_entries:
-            print
-            print '#ifdef MAPI_TMP_PUBLIC_ENTRIES'
-            print self.c_public_dispatches(self.prefix_lib, False)
-            print
-            print 'static const mapi_func public_entries[] = {'
-            print self.c_public_initializer(self.prefix_lib)
-            print '};'
-            print '#undef MAPI_TMP_PUBLIC_ENTRIES'
-            print '#endif /* MAPI_TMP_PUBLIC_ENTRIES */'
-
-            print
-            print '#ifdef MAPI_TMP_STUB_ASM_GCC'
-            print '__asm__('
-            print self.c_asm_gcc(self.prefix_lib, False)
-            print ');'
-            print '#undef MAPI_TMP_STUB_ASM_GCC'
-            print '#endif /* MAPI_TMP_STUB_ASM_GCC */'
+            print()
+            print('#ifdef MAPI_TMP_PUBLIC_ENTRIES')
+            print(self.c_public_dispatches(self.prefix_lib, False))
+            print()
+            print('static const mapi_func public_entries[] = {')
+            print(self.c_public_initializer(self.prefix_lib))
+            print('};')
+            print('#undef MAPI_TMP_PUBLIC_ENTRIES')
+            print('#endif /* MAPI_TMP_PUBLIC_ENTRIES */')
+
+            print()
+            print('#ifdef MAPI_TMP_STUB_ASM_GCC')
+            print('__asm__(')
+            print(self.c_asm_gcc(self.prefix_lib, False))
+            print(');')
+            print('#undef MAPI_TMP_STUB_ASM_GCC')
+            print('#endif /* MAPI_TMP_STUB_ASM_GCC */')
 
         if self.lib_need_non_hidden_entries:
             all_hidden = True
@@ -640,37 +635,37 @@ class ABIPrinter(object):
                     all_hidden = False
                     break
             if not all_hidden:
-                print
-                print '#ifdef MAPI_TMP_PUBLIC_ENTRIES_NO_HIDDEN'
-                print self.c_public_dispatches(self.prefix_lib, True)
-                print
-                print '/* does not need public_entries */'
-                print '#undef MAPI_TMP_PUBLIC_ENTRIES_NO_HIDDEN'
-                print '#endif /* MAPI_TMP_PUBLIC_ENTRIES_NO_HIDDEN */'
-
-                print
-                print '#ifdef MAPI_TMP_STUB_ASM_GCC_NO_HIDDEN'
-                print '__asm__('
-                print self.c_asm_gcc(self.prefix_lib, True)
-                print ');'
-                print '#undef MAPI_TMP_STUB_ASM_GCC_NO_HIDDEN'
-                print '#endif /* MAPI_TMP_STUB_ASM_GCC_NO_HIDDEN */'
+                print()
+                print('#ifdef MAPI_TMP_PUBLIC_ENTRIES_NO_HIDDEN')
+                print(self.c_public_dispatches(self.prefix_lib, True))
+                print()
+                print('/* does not need public_entries */')
+                print('#undef MAPI_TMP_PUBLIC_ENTRIES_NO_HIDDEN')
+                print('#endif /* MAPI_TMP_PUBLIC_ENTRIES_NO_HIDDEN */')
+
+                print()
+                print('#ifdef MAPI_TMP_STUB_ASM_GCC_NO_HIDDEN')
+                print('__asm__(')
+                print(self.c_asm_gcc(self.prefix_lib, True))
+                print(');')
+                print('#undef MAPI_TMP_STUB_ASM_GCC_NO_HIDDEN')
+                print('#endif /* MAPI_TMP_STUB_ASM_GCC_NO_HIDDEN */')
 
     def output_for_app(self):
-        print self.c_notice()
-        print
-        print self.c_private_declarations(self.prefix_app)
-        print
-        print '#ifdef API_TMP_DEFINE_SPEC'
-        print
-        print 'static const char %s_spec[] =' % (self.prefix_app)
-        print self.c_mapi_table_spec()
-        print
-        print 'static const mapi_proc %s_procs[] = {' % (self.prefix_app)
-        print self.c_mapi_table_initializer(self.prefix_app)
-        print '};'
-        print
-        print '#endif /* API_TMP_DEFINE_SPEC */'
+        print(self.c_notice())
+        print()
+        print(self.c_private_declarations(self.prefix_app))
+        print()
+        print('#ifdef API_TMP_DEFINE_SPEC')
+        print()
+        print('static const char %s_spec[] =' % (self.prefix_app))
+        print(self.c_mapi_table_spec())
+        print()
+        print('static const mapi_proc %s_procs[] = {' % (self.prefix_app))
+        print(self.c_mapi_table_initializer(self.prefix_app))
+        print('};')
+        print()
+        print('#endif /* API_TMP_DEFINE_SPEC */')
 
 class GLAPIPrinter(ABIPrinter):
     """OpenGL API Printer"""
@@ -723,8 +718,7 @@ class GLAPIPrinter(ABIPrinter):
         if missed:
             raise Exception('%s is missing' % str(missed))
 
-        entries = api_entries.values()
-        entries.sort()
+        entries = sorted(api_entries.values())
 
         return entries
 
diff --git a/src/mesa/main/APIspec.py b/src/mesa/main/APIspec.py
index 6947f73..17c2d32 100644
--- a/src/mesa/main/APIspec.py
+++ b/src/mesa/main/APIspec.py
@@ -53,7 +53,7 @@ class Spec(object):
             node = node.next
 
         # find an implementation
-        for name, node in self.api_nodes.iteritems():
+        for name, node in self.api_nodes.items():
             if node.prop("implementation") == "true":
                 self.impl_node = node
                 break
@@ -99,7 +99,7 @@ class API(object):
             try:
                 func = Function(tmpl_node, func_node, self.is_impl,
                                 self.categories)
-            except SpecError, e:
+            except SpecError as e:
                 func_name = func_node.prop("name")
                 raise SpecError("failed to parse %s: %s" % (func_name, e))
             self.functions.append(func)
@@ -279,7 +279,7 @@ class Function(object):
             return (False, False)
 
         need_conv = False
-        for i in xrange(len(self.params)):
+        for i in range(len(self.params)):
             src = other.params[i]
             dst = self.params[i]
             if (src.is_vector != dst.is_vector or src.size != dst.size):
@@ -350,7 +350,7 @@ class Checker(object):
         """Validate the checker against a function."""
         tmp = Checker()
 
-        for switch in self.switches.itervalues():
+        for switch in self.switches.values():
             valid_descs = []
             for desc in switch:
                 if desc.validate(func, param_nodes):
@@ -369,7 +369,7 @@ class Checker(object):
     def flatten(self, name=None):
         """Return a flat list of all descriptions of the named parameter."""
         flat_list = []
-        for switch in self.switches.itervalues():
+        for switch in self.switches.values():
             for desc in switch:
                 if not name or desc.name == name:
                     flat_list.append(desc)
@@ -382,7 +382,7 @@ class Checker(object):
             return True
 
         # a param is always checked if any of the switch always checks it
-        for switch in self.switches.itervalues():
+        for switch in self.switches.values():
             # a switch always checks it if all of the descs always check it
             always = True
             for desc in switch:
@@ -414,7 +414,7 @@ class Checker(object):
             if desc.values:
                 for val in desc.values:
                     stmts.append("case %s:" % val)
-                for dep_name in desc.checker.switches.iterkeys():
+                for dep_name in desc.checker.switches.keys():
                     dep_stmts = [indent + s for s in desc.checker._c_switch(dep_name, indent)]
                     stmts.extend(dep_stmts)
                 stmts.append(indent + "break;")
@@ -429,9 +429,9 @@ class Checker(object):
     def dump(self, indent="\t"):
         """Dump the descriptions in C code."""
         stmts = []
-        for name in self.switches.iterkeys():
+        for name in self.switches.keys():
             c_switch = self._c_switch(name)
-            print "\n".join(c_switch)
+            print("\n".join(c_switch))
 
 
 class Description(object):
@@ -480,7 +480,7 @@ class Description(object):
                     if not self._has_enum and base.startswith("GL_"):
                         self._has_enum = True
                     # expand range
-                    for i in xrange(first, last + 1):
+                    for i in range(first, last + 1):
                         self.values.append("%s%d" % (base, i))
                 else: # dependent desc
                     dep_nodes.append(node)
@@ -610,7 +610,7 @@ def main():
 
     doc.freeDoc()
 
-    print "%s is successfully parsed" % filename
+    print("%s is successfully parsed" % filename)
 
 
 if __name__ == "__main__":
diff --git a/src/mesa/main/APIspecutil.py b/src/mesa/main/APIspecutil.py
index 9e604bb..033497d 100644
--- a/src/mesa/main/APIspecutil.py
+++ b/src/mesa/main/APIspecutil.py
@@ -61,7 +61,7 @@ def _ParseXML(filename, apiname):
         if not alias:
             # external functions are manually dispatched
             if not func.is_external:
-                print >>sys.stderr, "Error: unable to dispatch %s" % func.name
+                print("Error: unable to dispatch %s" % func.name, file=sys.stderr)
             alias = func
             need_conv = False
 
@@ -117,17 +117,17 @@ def _ValidValues(func, param):
                 valid_values.append((val, None, None, [], desc.error, None))
             continue
 
-        items = desc.checker.switches.items()
+        items = list(desc.checker.switches.items())
         if len(items) > 1:
-            print >>sys.stderr, "%s: more than one parameter depend on %s" % \
-                    (func.name, desc.name)
+            print("%s: more than one parameter depend on %s" % \
+                    (func.name, desc.name), file=sys.stderr)
         dep_name, dep_switch = items[0]
 
         for dep_desc in dep_switch:
             if dep_desc.index >= 0 and dep_desc.index != 0:
-                print >>sys.stderr, "%s: not first element of a vector" % func.name
+                print("%s: not first element of a vector" % func.name, file=sys.stderr)
             if dep_desc.checker.switches:
-                print >>sys.stderr, "%s: deep nested dependence" % func.name
+                print("%s: deep nested dependence" % func.name, file=sys.stderr)
 
             convert = None if dep_desc.convert else "noconvert"
             for val in desc.values:
@@ -188,9 +188,8 @@ def _MaxVecSize(func, param):
     if not size:
         need_conv = __aliases[func.name][1]
         if need_conv:
-            print >>sys.stderr, \
-                    "Error: unable to dicide the max size of %s in %s" % \
-                    (param.name, func.name)
+            print("Error: unable to dicide the max size of %s in %s" % \
+                    (param.name, func.name), file=sys.stderr)
     return size
 
 
@@ -231,7 +230,7 @@ def FunctionPrefix(funcname):
 
 def FindParamIndex(params, paramname):
     """Find the index of a named parameter."""
-    for i in xrange(len(params)):
+    for i in range(len(params)):
         if params[i][0] == paramname:
             return i
     return None
diff --git a/src/mesa/main/es_generator.py b/src/mesa/main/es_generator.py
index c0b0a44..34e6a43 100644
--- a/src/mesa/main/es_generator.py
+++ b/src/mesa/main/es_generator.py
@@ -31,7 +31,7 @@ import APIspecutil as apiutil
 Converters = {
     'GLfloat': {
         'GLdouble': "(GLdouble) (%s)",
-        'GLfixed' : "(GLint) (%s * 65536)",
+        'GLfixed': "(GLint) (%s * 65536)",
     },
     'GLfixed': {
         'GLfloat': "(GLfloat) (%s / 65536.0f)",
@@ -69,12 +69,12 @@ def ConvertValue(value, fromType, toType):
     """Returns a string that represents the given parameter string, 
     type-converted if necessary."""
 
-    if not Converters.has_key(fromType):
-        print >> sys.stderr, "No base converter for type '%s' found.  Ignoring." % fromType
+    if fromType not in Converters:
+        print("No base converter for type '%s' found.  Ignoring." % fromType, file=sys.stderr)
         return value
 
-    if not Converters[fromType].has_key(toType):
-        print >> sys.stderr, "No converter found for type '%s' to type '%s'.  Ignoring." % (fromType, toType)
+    if toType not in Converters[fromType]:
+        print("No converter found for type '%s' to type '%s'.  Ignoring." % (fromType, toType), file=sys.stderr)
         return value
 
     # This part is simple.  Return the proper conversion.
@@ -82,13 +82,13 @@ def ConvertValue(value, fromType, toType):
     return conversionString % value
 
 FormatStrings = {
-    'GLenum' : '0x%x',
-    'GLfloat' : '%f',
-    'GLint' : '%d',
-    'GLbitfield' : '0x%x',
+    'GLenum': '0x%x',
+    'GLfloat': '%f',
+    'GLint': '%d',
+    'GLbitfield': '0x%x',
 }
 def GetFormatString(type):
-    if FormatStrings.has_key(type):
+    if type in FormatStrings:
         return FormatStrings[type]
     else:
         return None
@@ -131,7 +131,7 @@ import getopt, time
 options = "hvV:S:"
 try:
     optlist, args = getopt.getopt(sys.argv[1:], options)
-except getopt.GetoptError, message:
+except getopt.GetoptError as message:
     sys.stderr.write("%s: %s.  Use -h for help.\n" % (program, message))
     sys.exit(1)
 
@@ -142,7 +142,7 @@ for option, optarg in optlist:
         sys.stderr.write("-h gives help\n")
         sys.stderr.write("-v is verbose\n")
         sys.stderr.write("-V specifies GLES version to generate [%s]:\n" % version)
-        for key in VersionSpecificValues.keys():
+        for key in list(VersionSpecificValues.keys()):
             sys.stderr.write("    %s - %s\n" % (key, VersionSpecificValues[key]['description']))
         sys.stderr.write("-S specifies API specification file to use [%s]\n" % functionList)
         sys.exit(1)
@@ -159,7 +159,7 @@ if len(args) >  0:
     sys.exit(1)
 
 # If we don't have a valid version, abort.
-if not VersionSpecificValues.has_key(version):
+if version not in VersionSpecificValues:
     sys.stderr.write("%s: version '%s' is not valid - use -h for help\n" % (program, version))
     sys.exit(1)
 
@@ -178,16 +178,16 @@ keys = apiutil.GetAllFunctions(functionList, version)
 
 allSpecials = apiutil.AllSpecials()
 
-print """/* DO NOT EDIT *************************************************
+print("""/* DO NOT EDIT *************************************************
  * THIS FILE AUTOMATICALLY GENERATED BY THE %s SCRIPT
  * API specification file:   %s
  * GLES version:             %s
  * date:                     %s
  */
-""" % (program, functionList, version, time.strftime("%Y-%m-%d %H:%M:%S"))
+""" % (program, functionList, version, time.strftime("%Y-%m-%d %H:%M:%S")))
 
 # The headers we choose are version-specific.
-print """
+print("""
 #include "%s"
 #include "%s"
 #include "main/mfeatures.h"
@@ -199,10 +199,10 @@ print """
 #ifndef GLAPIENTRYP
 #define GLAPIENTRYP GL_APIENTRYP
 #endif
-""" % (versionHeader, versionExtHeader, shortname.upper())
+""" % (versionHeader, versionExtHeader, shortname.upper()))
 
 # Everyone needs these types.
-print """
+print("""
 /* These types are needed for the Mesa veneer, but are not defined in
  * the standard GLES headers.
  */
@@ -212,13 +212,13 @@ typedef double GLclampd;
 /* Mesa error handling requires these */
 extern void *_mesa_get_current_context(void);
 extern void _mesa_error(void *ctx, GLenum error, const char *fmtString, ... );
-"""
+""")
 
 # Finally we get to the all-important functions
-print """/*************************************************************
+print("""/*************************************************************
  * Generated functions begin here
  */
-"""
+""")
 for funcName in keys:
     if verbose > 0: sys.stderr.write("%s: processing function %s\n" % (program, funcName))
 
@@ -577,8 +577,8 @@ for funcName in keys:
     # header files.  The easiest way to manage declarations
     # is to create them ourselves.
     if funcName in allSpecials:
-        print "/* this function is special and is defined elsewhere */"
-    print "extern %s GL_APIENTRY %s(%s);" % (returnType, passthroughFuncName, passthroughDeclarationString)
+        print("/* this function is special and is defined elsewhere */")
+    print("extern %s GL_APIENTRY %s(%s);" % (returnType, passthroughFuncName, passthroughDeclarationString))
 
     # A function may be a core function (i.e. it exists in
     # the core specification), a core addition (extension
@@ -620,36 +620,36 @@ for funcName in keys:
         # Now the generated function.  The text used to mark an API-level
         # function, oddly, is version-specific.
         if extensionName:
-            print "/* Extension %s */" % extensionName
+            print("/* Extension %s */" % extensionName)
 
         if (not variables and
             not switchCode and
             not conversionCodeOutgoing and
             not conversionCodeIncoming):
             # pass through directly
-            print "#define %s %s" % (fullFuncName, passthroughFuncName)
-            print
+            print("#define %s %s" % (fullFuncName, passthroughFuncName))
+            print()
             continue
 
-        print "static %s GL_APIENTRY %s(%s)" % (returnType, fullFuncName, declarationString)
-        print "{"
+        print("static %s GL_APIENTRY %s(%s)" % (returnType, fullFuncName, declarationString))
+        print("{")
 
         # Start printing our code pieces.  Start with any local
         # variables we need.  This unusual syntax joins the 
         # lines in the variables[] array with the "\n" separator.
         if len(variables) > 0:
-            print "\n".join(variables) + "\n"
+            print("\n".join(variables) + "\n")
 
         # If there's any sort of parameter checking or variable
         # array sizing, the switch code will contain it.
         if len(switchCode) > 0:
-            print "\n".join(switchCode) + "\n"
+            print("\n".join(switchCode) + "\n")
 
         # In the case of an outgoing conversion (i.e. parameters must
         # be converted before calling the underlying Mesa function),
         # use the appropriate code.
         if "get" not in props and len(conversionCodeOutgoing) > 0:
-            print "\n".join(conversionCodeOutgoing) + "\n"
+            print("\n".join(conversionCodeOutgoing) + "\n")
 
         # Call the Mesa function.  Note that there are very few functions
         # that return a value (i.e. returnType is not "void"), and that
@@ -658,24 +658,24 @@ for funcName in keys:
         # even though it's not completely independent.
 
         if returnType == "void":
-            print "    %s(%s);" % (passthroughFuncName, passthroughCallString)
+            print("    %s(%s);" % (passthroughFuncName, passthroughCallString))
         else:
-            print "    return %s(%s);" % (passthroughFuncName, passthroughCallString)
+            print("    return %s(%s);" % (passthroughFuncName, passthroughCallString))
 
         # If the function is one that returns values (i.e. "get" in props),
         # it might return values of a different type than we need, that
         # require conversion before passing back to the application.
         if "get" in props and len(conversionCodeIncoming) > 0:
-            print "\n".join(conversionCodeIncoming)
+            print("\n".join(conversionCodeIncoming))
 
         # All done.
-        print "}"
-        print
+        print("}")
+        print()
     # end for each category provided for a function
 
 # end for each function
 
-print """
+print("""
 #include "glapi/glapi.h"
 
 #if FEATURE_remap_table
@@ -736,7 +736,7 @@ _mesa_create_exec_table_%s(void)
       return NULL;
 
    init_remap_table();
-""" % (shortname, shortname, shortname, shortname)
+""" % (shortname, shortname, shortname, shortname))
 
 for func in keys:
     prefix = "_es_" if func not in allSpecials else "_check_"
@@ -749,10 +749,10 @@ for func in keys:
         if ext:
             suffix = ext[0].split("_")[0]
             entry += suffix
-        print "    SET_%s(exec, %s%s);" % (entry, prefix, entry)
-print ""
-print "   return exec;"
-print "}"
+        print("    SET_%s(exec, %s%s);" % (entry, prefix, entry))
+print("")
+print("   return exec;")
+print("}")
 
-print """
-#endif /* FEATURE_%s */""" % (shortname.upper())
+print("""
+#endif /* FEATURE_%s */""" % (shortname.upper()))
