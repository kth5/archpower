#!/usr/bin/env python3
"""
Script to analyze PKGBUILDs and determine build order for kf6 packages.
This script parses all PKGBUILDs in the current directory and creates a
topological sort based on dependencies.
"""

import os
import re
from collections import defaultdict, deque
from typing import Dict, List, Set, Tuple

def parse_pkgbuild(pkgbuild_path: str) -> Tuple[str, List[str], List[str]]:
    """Parse a PKGBUILD file and extract package name, depends, and makedepends."""
    pkgname = None
    depends = []
    makedepends = []
    
    try:
        with open(pkgbuild_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        # Extract pkgname
        pkgname_match = re.search(r'pkgname=([^\s\n]+)', content)
        if pkgname_match:
            pkgname = pkgname_match.group(1)
        
        # Extract depends
        depends_match = re.search(r'depends=\((.*?)\)', content, re.DOTALL)
        if depends_match:
            depends_text = depends_match.group(1)
            # Split by newlines and clean up
            depends = [dep.strip() for dep in depends_text.split('\n') if dep.strip()]
            # Remove empty strings and clean up
            depends = [dep for dep in depends if dep and not dep.startswith('#')]
        
        # Extract makedepends
        makedepends_match = re.search(r'makedepends=\((.*?)\)', content, re.DOTALL)
        if makedepends_match:
            makedepends_text = makedepends_match.group(1)
            # Split by newlines and clean up
            makedepends = [dep.strip() for dep in makedepends_text.split('\n') if dep.strip()]
            # Remove empty strings and clean up
            makedepends = [dep for dep in makedepends if dep and not dep.startswith('#')]
            
    except Exception as e:
        print(f"Error parsing {pkgbuild_path}: {e}")
        return None, [], []
    
    return pkgname, depends, makedepends

def get_kf6_packages() -> Dict[str, Tuple[List[str], List[str]]]:
    """Get all kf6 packages and their dependencies."""
    packages = {}
    
    # Get all directories in current path
    current_dir = os.getcwd()
    for item in os.listdir(current_dir):
        item_path = os.path.join(current_dir, item)
        if os.path.isdir(item_path):
            pkgbuild_path = os.path.join(item_path, 'PKGBUILD')
            if os.path.exists(pkgbuild_path):
                pkgname, depends, makedepends = parse_pkgbuild(pkgbuild_path)
                if pkgname:
                    packages[pkgname] = (depends, makedepends)
    
    return packages

def filter_kf6_dependencies(deps: List[str], kf6_packages: Set[str]) -> List[str]:
    """Filter dependencies to only include kf6 packages."""
    return [dep for dep in deps if dep in kf6_packages]

def topological_sort(packages: Dict[str, Tuple[List[str], List[str]]]) -> List[List[str]]:
    """Perform topological sort to determine build order."""
    # Create dependency graph
    graph = defaultdict(list)
    in_degree = defaultdict(int)
    
    # Initialize all packages
    for pkg in packages:
        in_degree[pkg] = 0
    
    # Build dependency graph
    for pkg, (depends, makedepends) in packages.items():
        all_deps = depends + makedepends
        kf6_deps = filter_kf6_dependencies(all_deps, set(packages.keys()))
        
        for dep in kf6_deps:
            if dep in packages:  # Only consider kf6 packages
                graph[dep].append(pkg)
                in_degree[pkg] += 1
    
    # Topological sort using Kahn's algorithm
    tiers = []
    queue = deque([pkg for pkg in packages if in_degree[pkg] == 0])
    
    while queue:
        current_tier = []
        tier_size = len(queue)
        
        for _ in range(tier_size):
            pkg = queue.popleft()
            current_tier.append(pkg)
            
            # Remove this package from dependencies
            for dependent in graph[pkg]:
                in_degree[dependent] -= 1
                if in_degree[dependent] == 0:
                    queue.append(dependent)
        
        if current_tier:
            tiers.append(sorted(current_tier))
    
    return tiers

def write_build_order(tiers: List[List[str]], output_file: str = 'kf6_build_order.txt'):
    """Write the build order to a file with tier comments."""
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# KF6 Package Build Order\n")
        f.write("# Generated by dependency analysis\n")
        f.write("# Each tier can be built in parallel\n\n")
        
        for i, tier in enumerate(tiers, 1):
            f.write(f"# Tier {i} - Build these packages first (no internal dependencies)\n")
            for pkg in tier:
                f.write(f"{pkg}\n")
            f.write("\n")
        
        f.write("# Build order summary:\n")
        for i, tier in enumerate(tiers, 1):
            f.write(f"# Tier {i}: {', '.join(tier)}\n")

def main():
    """Main function to analyze dependencies and create build order."""
    print("Analyzing kf6 package dependencies...")
    
    # Get all kf6 packages
    packages = get_kf6_packages()
    print(f"Found {len(packages)} kf6 packages")
    
    # Perform topological sort
    tiers = topological_sort(packages)
    
    # Write build order to file
    write_build_order(tiers)
    
    print(f"\nBuild order written to kf6_build_order.txt")
    print(f"Found {len(tiers)} tiers:")
    
    for i, tier in enumerate(tiers, 1):
        print(f"  Tier {i}: {len(tier)} packages - {', '.join(tier)}")
    
    # Check for circular dependencies
    total_packages = sum(len(tier) for tier in tiers)
    if total_packages != len(packages):
        print(f"\nWARNING: {len(packages) - total_packages} packages have circular dependencies!")
        print("Packages not included in build order:")
        included = set()
        for tier in tiers:
            included.update(tier)
        missing = set(packages.keys()) - included
        print(f"Missing: {', '.join(sorted(missing))}")

if __name__ == "__main__":
    main()
